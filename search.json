[{"title":"Wic**Me分析","url":"/2022/05/18/Wic-Me分析/","content":"\n### 0x1 应用信息\napp name: WickrMe \nbundle id: com.mywickr.wickr\nversion: v5.100.8 \n\n### 0x2 消息解密\n\n通过分析得知消息保存在数据库中，数据库路径如下\n```\npath: /var/mobile/Containers/Shared/AppGroup/*****/wickrLocal.sqlite\n```\n\n数据使用AES-GCM模式加密\n\n解密流程如下:\n\n- 1.读取keychain中的!devid! + bundle id计算sha256,作为第一次解密数据的key\n```\nService: wickr me\nAccount: !devid!\nEntitlement Group: W8RC3R952A.com.mywickr.wickr\nLabel: (null)\nAccessible Attribute: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, protection level 4\nDescription: (null)\nComment: (null)\nSynchronizable: 0\nGeneric Field: (null)\nKeychain Data (Hex): 0xae******5a803f35b43d7bff9db67a9742433943433246352d444642372d344241392d423136302d464335353638343843434135\n```\n\n- 2.读取数据库ZSECEX_ACCOUNT表中的ZPH字段,使用第一步生成的key解密\n- 3.继续解密第二步的数据,解密key为keychain中activeAccount的数据\n```\nService: wickr\nAccount: activeAccount\nEntitlement Group: W8RC3R952A.com.mywickr.wickr\nLabel: (null)\nAccessible Attribute: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, protection level 4\nDescription: (null)\nComment: (null)\nSynchronizable: 0\nGeneric Field: (null)\nKeychain Data (Hex): 0x00dd6******fdb2703b4dc6a71ff1a6747560664e7fa36a4\n```\n- 4.读取数据库ZWICKR_MESSAGE表中的ZBODY字段,使用第三步解密后数据的第五到第三十七字节做key解密\n- 5.对第四步数据进行反序列化(Protobuf)即为明文数据\n\n```python\n# -*- coding: utf-8 -*-  \n\n# app name: WickrMe \n# bundle id: com.mywickr.wickr\n# version: v5.100.8 \n# path: /var/mobile/Containers/Shared/AppGroup/*****/wickrLocal.sqlite\n# 解密流程\n# 1.keychain中的!devid! + bundle id计算sha256,作为第一次解密数据的key\n# 2.读取数据库ZSECEX_ACCOUNT表中的ZPH字段,使用第一步生成的key解密\n# 3.继续解密第二步的数据,解密key为keychain中activeAccount的数据\n# 4.读取数据库ZWICKR_MESSAGE表中的ZBODY字段,使用第三步解密后数据的第五到第三十七字节做key解密\n# 5.对第四步数据进行反序列化即为明文数据\n\nfrom Crypto.Hash import SHA256\nfrom Crypto.Cipher import AES\nimport binascii\nimport blackboxprotobuf\n\nimport message_pb2\nimport test_proto_pb2\n\ndef gen_key(devid):\n    hash = SHA256.new(devid)\n    key = hash.digest()\n    return key\n\ndef aes_decrypt(key,buffer):\n    print(\"aes key:\",binascii.hexlify(key))\n    cipher = AES.new(key,AES.MODE_GCM,bytes(buffer[1:13]))\n    buffer = cipher.decrypt_and_verify(bytes(buffer[29:]), bytes(buffer[13:29]))\n    return buffer\n\ndef aes_file_decrypt(key,buffer):\n    # f (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, cipher_result->cipher.iv_len, NULL))\n    # EVP_CTRL_GCM_SET_IVLEN = 0x9\n    # EVP_CTRL_AEAD_SET_TAG = 0x11\n    print(\"aes key:\",binascii.hexlify(key))\n    cipher = AES.new(key,AES.MODE_GCM,bytes(buffer[1:13]))\n    buffer = cipher.decrypt_and_verify(bytes(buffer[29:]), bytes(buffer[13:29]))\n    return buffer\n\ndef main():\n    str = b'BC9CC2F5-DFB7-4BA9-B160-FC556848CCA5com.mywickr.wickr'\n    key = gen_key(str)\n\n    # ZSECEX_ACCOUNT表中的ZPH字段\n    zph = [\n        0x00, 0x3A, 0x68, 0x81, 0xA8, 0xCF, 0xD9, 0x40, 0xD3, 0xEA, 0x23, 0x70, 0x3C, 0x28, 0xAF, 0xBD,\n        0xD7, 0x75, 0x15, 0x3C, 0xAE, 0x4B, 0x97, 0xC8, 0x01, 0xDE, 0x1D, 0x01, 0xEC, 0x67, 0x60, 0x0D,\n        0x0E, 0x71, 0x8A, 0x5E, 0xF8, 0x96, 0xB0, 0xEE, 0x9B, 0x23, 0xDB, 0xED, 0x75, 0x3A, 0xAE, 0x47,\n        0x80, 0x90, 0x44, 0xC6, 0xAF, 0xE3, 0x0C, 0x9E, 0xDC, 0x9A, 0xFB, 0x98, 0xE8, 0x48, 0x79, 0x05,\n        0x98, 0x15, 0x72, 0x17, 0xD4, 0x37, 0x56, 0x42, 0xC6, 0xEB, 0xC0, 0xCF, 0x28, 0xF8, 0xA7, 0xFF,\n        0xF0, 0x66, 0x5F, 0xA2, 0x3D, 0xAF, 0x2F, 0x0A, 0xB8, 0x72, 0xCC, 0x44, 0x81, 0x96, 0x38, 0xBA,\n        0x3C, 0xD8, 0x57, 0x98, 0xF2, 0xE3, 0xA5, 0xE2, 0x01, 0x7E, 0x21, 0xFA, 0xA9, 0x3F, 0x75, 0x35,\n        0x12, 0xD1, 0xF1, 0xD7, 0x86, 0x5D, 0x13, 0x67, 0xBF, 0x44, 0x2D, 0xF9, 0x7A, 0x4D, 0xED, 0x0E,\n        0x80, 0xBE \n    ]\n    \n    buffer = aes_decrypt(key,zph)\n\n    key = b'2450ced0b8f367aa7cd15b8fe5d70ed6a3fe98ab7ba0f2041055d3c7a4da0f7a'\n    buffer = aes_decrypt(binascii.a2b_hex(key),buffer)\n\n    # ZWICKR_MESSAGE表中的ZBODY字段\n    zbody = [\n        0x00, 0x00\n    ]\n\n    zbody_file = [\n        0x00, 0x00\n    ]\n\n    zfile_span = [\n        0x00, 0x00\n    ]\n\n    z_title = [\n        0x00, 0x00\n    ]\n\n    file_key = buffer[5:37]\n    buffer = aes_decrypt(buffer[5:37],zbody_file)\n\n    try:\n        message = blackboxprotobuf.protobuf_to_json(buffer)\n        # print(message)\n        # print(binascii.hexlify(buffer))\n    except:\n        print(buffer)\n\n\n    file_key = [ \n        0x00, 0x00\n    ]\n\n    print(binascii.hexlify(gen_key(b'e14382e9fd9d96d0b63dfc69be3831758db541028965472050f463e2ba351a4c')))\n    with open('0a7a0f20-8b45-41ad-95a6-55dfd4fdc9a4','rb') as f:\n        buffer = f.read()\n    buffer = aes_file_decrypt(bytes(file_key[1:]),buffer)\n    \n    with open('/0a7a0f20-8b45-41ad-95a6-55dfd4fdc9a4_dec','wb') as f:\n        f.write(buffer)\n\nif __name__==\"__main__\":\n    main()\n\n\n```","tags":["reverse"],"categories":["reverse"]},{"title":"E***gma分析","url":"/2022/05/12/E-gma分析/","content":"\n```javascript\n// +[IMSubDbm egdbWithPath:encrypt:fts:](id a1, SEL a2, id a3, bool a4, bool a5)\nvar IMSubDbm = ObjC.classes.IMSubDbm;\nInterceptor.attach(IMSubDbm[\"+ egdbWithPath:encrypt:fts:\"].implementation, {\n\tonEnter: function (args) {\n\t\tshow_stack(this.context);\n\t\tconsole.log(new ObjC.Object(args[2]))\n\t},\n\tonLeave: function (retval) {},\n});\n\n// -[EGDatabase setEncryptKey:](EGDatabase *self, SEL, id)\nvar EGDatabase = ObjC.classes.EGDatabase\nInterceptor.attach(EGDatabase[\"- setEncryptKey:\"].implementation, {\n\tonEnter:function(args){\n\t\tconsole.log('call setEncryptKey enter')\n\t\tconsole.log(new ObjC.Object(args[2]))\n\t}\n})\n\nfunction call_version(){\n\tvar clazz = ObjC.classes.EGDatabase.alloc()\n\tvar version = clazz['- cipherVersion'].call(clazz);\n\tconsole.log(\"version: \" + version.toString());\t\n}\n```\n\n```\nsqlcipher core.db\nSQLite version 3.37.2 2022-01-06 13:25:41 (SQLCipher 4.5.1 community)\nEnter \".help\" for usage hints.\nsqlite> PRAGMA cipher_plaintext_header_size = 0;\nsqlite> PRAGMA cipher_page_size = 4096;\nsqlite> PRAGMA kdf_iter = 64000;\nsqlite> PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\nsqlite> PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\nsqlite> PRAGMA cipher_plaintext_header_size = 32;\nsqlite> PRAGMA cipher_salt = \"x'10001001101010111100110111101111'\";\nsqlite> pragma locking_mode = normal;\nnormal\nsqlite> pragma synchronous = normal;\nsqlite> pragma journal_mode = wal;\nwal\nsqlite> .dbinfo\ndatabase page size:  4096\nwrite format:        2\nread format:         2\nreserved bytes:      0\nfile change counter: 1\ndatabase page count: 1\nfreelist page count: 0\nschema cookie:       0\nschema format:       0\ndefault cache size:  0\nautovacuum top root: 0\nincremental vacuum:  0\ntext encoding:       0\nuser version:        0\napplication id:      0\nsoftware version:    3037002\nnumber of tables:    0\nnumber of indexes:   0\nnumber of triggers:  0\nnumber of views:     0\nschema size:         0\ndata version         3\nsqlite> .dump\nPRAGMA foreign_keys=OFF;\nBEGIN TRANSACTION;\nCOMMIT;\nsqlite>\n```","tags":["reverse"],"categories":["reverse"]},{"title":"TX视频解析分析","url":"/2022/04/10/TX视频解析分析/"},{"title":"Xposed原理及源码分析","url":"/2022/03/08/Xposed原理及源码分析/","content":"\n### 概述\nXposed框架是一款可以在不修改APK的情况下影响程序运行（修改系统）的框架服务，通过替换/system/bin/app_process 程序控制 zygote 进程，使 app_process 在启动过程中加载XposedBridge.jar 这个jar包，从而完成对Zygote进程及其创建的虚拟机的劫持。\n### 源码分析\n\nXposed项目地址:https://github.com/rovo89\n\n主要包含五个项目,具体功能如下所示\n\n>Xposed:Xposed Native 层代码的实现，主要修改了系统 app_process 的实现（即 zygote 服务进程的实现），为将 Hook 代码注入每个应用进程提供了入口。\n>\n>XposedBridge:Xposed Java 层的代码，它将单独作为一个 jar 包的形式通过 zygote 的分裂（fork）注入到每一个应用进程中，内部会 Xposed 模块，并为 Xposed 模块中的 Hook 操作提供 API 支持。\n>\n>XposedInstaller:统一管理 Xposed 框架的 Android 应用，也是一个 Xposed 框架安装器，用于安装更新 Xposed 框架核心以及作为统一管理 Xposed 模块安装的模块管理器。\n>\n>android_art:Xposed 修改后的 Android ART 虚拟机的实现，将编译出 libart.so 和其依赖库，替换系统的 ART 虚拟机实现。包含方法 Hook 的核心实现。\n>\n>XposedTools:用于编译 Xposed 框架的脚本工具。\n\n\n1. 全局注入的实现\n    简单的来说，Xposed就是通过替换修改过的app_process来注入Zygote以实现的全局注入。那么想了解Xposed的注入时机，首先需要了解一下Android系统的启动流程，通过该流程可以清楚了解到Xposed的注入点，大致过程如下\n    \n    >Step 1. Boot Rom\n    >\t当长按开机键的时候，引导芯片开始从固化在ROM的预设代码开始执行。然后加载引导程序到RAM。\n    >\n    >Step 2. BootLoader\n    >\tBootLoader，又称为引导程序。它是在操作系统运行之前运行的一段程序，是运行的第一个程序。主要有检查RAM，初始化硬件参数等功能，当然它的最终目的是把操作系统给拉起来。\n    >\n    >Step 3. 初始化Kernel\n    >\n    >Step 4. init进程\n    >\t当初始化内核之后，就会启动一个相当重要的祖先进程，也就是init进程，在Linux中所有的进程都是由init进程直接或间接fork出来的。init进程负责创建系统中最关键的几个子进程，尤其是zygote。另外，它还提供了property service（属性服务），类似于windows系统的注册表服务。在Android系统中，会有个init.rc脚本。init进程一启动就会读取并解析这个脚本文件，把其中的元素整理成自己的数据结构（链表）。\n    >\n    >```\n    >service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server\n    >   class main\n    >   socket zygote stream 660 root system\n    >   onrestart write /sys/android_power/request_state wake\n    >   onrestart write /sys/power/state on\n    >   onrestart restart media\n    >   onrestart restart netd\n    >   writepid /dev/cpuset/foreground/tasks\n    >```\n    >\n    >Step 5. Zygote进程\n    >\t当init进程创建之后，会fork出一个Zygote进程，这个进程是所有Java进程的父进程。我们知道，Linux是基于C的，而Android是基于Java的（当然底层也是C）。所以这里就会fork出一个Zygote Java进程用来fork出其他的进程。在zygote开启的时候，会调用ZygoteInit.main()进行初始化。\n    >\n    >Step 6. SystemServer进程\n    >\n    >Step 7. Home Activity\n\n  接下来来看看Xposed是如何修改app_process进程的\n  根据Xposed的Android.mk文件可知在SDK版本大于21的手机上编译的是app_main2.cpp\n  ```\n  ifeq (1,$(strip $(shell expr $(PLATFORM_SDK_VERSION) \\>= 21)))\n    LOCAL_SRC_FILES := app_main2.cpp\n    LOCAL_MULTILIB := both\n    LOCAL_MODULE_STEM_32 := app_process32_xposed\n    LOCAL_MODULE_STEM_64 := app_process64_xposed\n  else\n    LOCAL_SRC_FILES := app_main.cpp\n    LOCAL_MODULE_STEM := app_process_xposed\n  endif\n  ```\n\n  直接定位到main函数\n\n  ```cpp\n  if (xposed::handleOptions(argc, argv)) {\n        return 0;\n    }\n  if (zygote) {\n        isXposedLoaded = xposed::initialize(true, startSystemServer, NULL, argc, argv);\n        runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : \"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        isXposedLoaded = xposed::initialize(false, false, className, argc, argv);\n        runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : \"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }  \n  ```\n\n  初始化xposed，判断SELinxu状态，将XposedBridge.jar包添加至Classpath中\n\n  ```cpp\n  /** Initialize Xposed (unless it is disabled). */\n  bool initialize(bool zygote, bool startSystemServer, const char* className, int argc, char* const argv[]) {\n  #if !defined(XPOSED_ENABLE_FOR_TOOLS)\n      if (!zygote)\n          return false;\n  #endif\n\n      if (isMinimalFramework()) {\n          ALOGI(\"Not loading Xposed for minimal framework (encrypted device)\");\n          return false;\n      }\n\n      xposed->zygote = zygote;\n      xposed->startSystemServer = startSystemServer;\n      xposed->startClassName = className;\n      xposed->xposedVersionInt = xposedVersionInt;\n\n  #if XPOSED_WITH_SELINUX\n      xposed->isSELinuxEnabled   = is_selinux_enabled() == 1;\n      xposed->isSELinuxEnforcing = xposed->isSELinuxEnabled && security_getenforce() == 1;\n  #else\n      xposed->isSELinuxEnabled   = false;\n      xposed->isSELinuxEnforcing = false;\n  #endif  // XPOSED_WITH_SELINUX\n\n      if (startSystemServer) {\n          xposed::logcat::printStartupMarker();\n      } else if (zygote) {\n          // TODO Find a better solution for this\n          // Give the primary Zygote process a little time to start first.\n          // This also makes the log easier to read, as logs for the two Zygotes are not mixed up.\n          sleep(10);\n      }\n    // 打印 Xposed 版本和 Device、ROM 等信息，开机时可以在 logcat 中看到\n      printRomInfo();\n\n      if (startSystemServer) {\n          if (!determineXposedInstallerUidGid() || !xposed::service::startAll()) {\n              return false;\n          }\n          xposed::logcat::start();\n  #if XPOSED_WITH_SELINUX\n      } else if (xposed->isSELinuxEnabled) {\n          if (!xposed::service::startMembased()) {\n              return false;\n          }\n  #endif  // XPOSED_WITH_SELINUX\n      }\n\n  #if XPOSED_WITH_SELINUX\n      // Don't let any further forks access the Zygote service\n      if (xposed->isSELinuxEnabled) {\n          xposed::service::membased::restrictMemoryInheritance();\n      }\n  #endif  // XPOSED_WITH_SELINUX\n\n      // FIXME Zygote has no access to input devices, this would need to be check in system_server context\n      if (zygote && !isSafemodeDisabled() && detectSafemodeTrigger(shouldSkipSafemodeDelay()))\n          disableXposed();\n\n      if (isDisabled() || (!zygote && shouldIgnoreCommand(argc, argv)))\n          return false;\n    // 将 XposedBridge.jar 加入系统 CLASSPATH 变量，使其代码中的类可被加载\n      return addJarToClasspath();\n  }\n  ```\n\n  初始化成功后调用runtimeStart函数，实际上是去调用了系统的runtime.start函数，尝试加载de.robv.android.xposed.XposedBridge\n  ```cpp\n  static void runtimeStart(AppRuntime& runtime, const char *classname, const Vector<String8>& options, bool zygote)\n  {\n  #if PLATFORM_SDK_VERSION >= 23\n    runtime.start(classname, options, zygote);\n  #else\n    // try newer variant (5.1.1_r19 and later) first\n    void (*ptr1)(AppRuntime&, const char*, const Vector<String8>&, bool);\n    *(void **) (&ptr1) = dlsym(RTLD_DEFAULT, \"_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEEb\");\n\n    if (ptr1 != NULL) {\n      ptr1(runtime, classname, options, zygote);\n      return;\n    }\n\n    // fall back to older variant\n    void (*ptr2)(AppRuntime&, const char*, const Vector<String8>&);\n    *(void **) (&ptr2) = dlsym(RTLD_DEFAULT, \"_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEE\");\n\n    if (ptr2 != NULL) {\n      ptr2(runtime, classname, options);\n      return;\n    }\n\n    // should not happen\n    LOG_ALWAYS_FATAL(\"app_process: could not locate AndroidRuntime::start() method.\");\n  #endif\n  }\n  ```\n\n  调用 AndroidRuntime::start函数后，内部会创建Java虚拟机，然后执行传入类的main 函数，Xposed就是通过替换这个className来达到加载自己的art虚拟机的效果。这样就成功注入了XposedBridge.jar文件，达到任意APP在加载时内存空间中总会有XposedBridge.jar\n\n  ```cpp\n  /*\n  * Start the Android runtime.  This involves starting the virtual machine\n  * and calling the \"static void main(String[] args)\" method in the class\n  * named by \"className\".\n  *\n  * Passes the main function two arguments, the class name and the specified\n  * options string.\n  */\n  void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)\n  {\n      ALOGD(\">>>>>> START %s uid %d <<<<<<\\n\",\n              className != NULL ? className : \"(unknown)\", getuid());\n\n      static const String8 startSystemServer(\"start-system-server\");\n\n      /*\n      * 'startSystemServer == true' means runtime is obsolete and not run from\n      * init.rc anymore, so we print out the boot start event here.\n      */\n      for (size_t i = 0; i < options.size(); ++i) {\n          if (options[i] == startSystemServer) {\n            /* track our progress through the boot sequence */\n            const int LOG_BOOT_PROGRESS_START = 3000;\n            LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));\n          }\n      }\n\n      const char* rootDir = getenv(\"ANDROID_ROOT\");\n      if (rootDir == NULL) {\n          rootDir = \"/system\";\n          if (!hasDir(\"/system\")) {\n              LOG_FATAL(\"No root directory specified, and /android does not exist.\");\n              return;\n          }\n          setenv(\"ANDROID_ROOT\", rootDir, 1);\n      }\n\n      //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");\n      //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);\n\n      /* start the virtual machine */\n      JniInvocation jni_invocation;\n      jni_invocation.Init(NULL);\n      JNIEnv* env;\n      if (startVm(&mJavaVM, &env, zygote) != 0) {\n          return;\n      }\n      onVmCreated(env);\n\n      /*\n      * Register android functions.\n      */\n      if (startReg(env) < 0) {\n          ALOGE(\"Unable to register all android natives\\n\");\n          return;\n      }\n\n      /*\n      * We want to call main() with a String array with arguments in it.\n      * At present we have two arguments, the class name and an option string.\n      * Create an array to hold them.\n      */\n      jclass stringClass;\n      jobjectArray strArray;\n      jstring classNameStr;\n\n      stringClass = env->FindClass(\"java/lang/String\");\n      assert(stringClass != NULL);\n      strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);\n      assert(strArray != NULL);\n      classNameStr = env->NewStringUTF(className);\n      assert(classNameStr != NULL);\n      env->SetObjectArrayElement(strArray, 0, classNameStr);\n\n      for (size_t i = 0; i < options.size(); ++i) {\n          jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());\n          assert(optionsStr != NULL);\n          env->SetObjectArrayElement(strArray, i + 1, optionsStr);\n      }\n\n      /*\n      * Start VM.  This thread becomes the main thread of the VM, and will\n      * not return until the VM exits.\n      */\n      char* slashClassName = toSlashClassName(className != NULL ? className : \"\");\n      jclass startClass = env->FindClass(slashClassName);\n      if (startClass == NULL) {\n          ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n          /* keep going */\n      } else {\n          jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\",\n              \"([Ljava/lang/String;)V\");\n          if (startMeth == NULL) {\n              ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n              /* keep going */\n          } else {\n              env->CallStaticVoidMethod(startClass, startMeth, strArray);\n\n  #if 0\n              if (env->ExceptionCheck())\n                  threadExitUncaughtException(env);\n  #endif\n          }\n      }\n      free(slashClassName);\n\n      ALOGD(\"Shutting down VM\\n\");\n      if (mJavaVM->DetachCurrentThread() != JNI_OK)\n          ALOGW(\"Warning: unable to detach main thread\\n\");\n      if (mJavaVM->DestroyJavaVM() != 0)\n          ALOGW(\"Warning: VM did not shut down cleanly\\n\");\n  }\n  ```\n  接下来进入Java层\n  ```java\n  protected static void main(String[] args) {\n      // Initialize the Xposed framework and modules\n      try {\n        if (!hadInitErrors()) {\n          initXResources();\n\n          SELinuxHelper.initOnce();\n          SELinuxHelper.initForProcess(null);\n\n          runtime = getRuntime();\n          XPOSED_BRIDGE_VERSION = getXposedVersion();\n\n          if (isZygote) {\n            XposedInit.hookResources();\n            XposedInit.initForZygote();\n          }\n\n          XposedInit.loadModules();\n        } else {\n          Log.e(TAG, \"Not initializing Xposed because of previous errors\");\n        }\n      } catch (Throwable t) {\n        Log.e(TAG, \"Errors during Xposed initialization\", t);\n        disableHooks = true;\n      }\n\n      // Call the original startup code\n      if (isZygote) {\n        ZygoteInit.main(args);\n      } else {\n        RuntimeInit.main(args);\n      }\n    }\n  ```\n  重点关注 XposedInit.initForZygote(); 和 XposedInit.loadModules();\n  \n```java\n\t\n\t/**\n\t * Hook some methods which we want to create an easier interface for developers.\n\t */\n\t/*package*/ static void initForZygote() throws Throwable {\n\t\tif (needsToCloseFilesForFork()) {\n\t\t\tXC_MethodHook callback = new XC_MethodHook() {\n\t\t\t\t@Override\n\t\t\t\tprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\tXposedBridge.closeFilesBeforeForkNative();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void afterHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\tXposedBridge.reopenFilesAfterForkNative();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tClass<?> zygote = findClass(\"com.android.internal.os.Zygote\", null);\n\t\t\thookAllMethods(zygote, \"nativeForkAndSpecialize\", callback);\n\t\t\thookAllMethods(zygote, \"nativeForkSystemServer\", callback);\n\t\t}\n\n\t\tfinal HashSet<String> loadedPackagesInProcess = new HashSet<>(1);\n\n\t\t// normal process initialization (for new Activity, Service, BroadcastReceiver etc.)\n\t\tfindAndHookMethod(ActivityThread.class, \"handleBindApplication\", \"android.app.ActivityThread.AppBindData\", new XC_MethodHook() {\n\t\t\t@Override\n\t\t\tprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\tActivityThread activityThread = (ActivityThread) param.thisObject;\n\t\t\t\tApplicationInfo appInfo = (ApplicationInfo) getObjectField(param.args[0], \"appInfo\");\n\t\t\t\tString reportedPackageName = appInfo.packageName.equals(\"android\") ? \"system\" : appInfo.packageName;\n\t\t\t\tSELinuxHelper.initForProcess(reportedPackageName);\n\t\t\t\tComponentName instrumentationName = (ComponentName) getObjectField(param.args[0], \"instrumentationName\");\n\t\t\t\tif (instrumentationName != null) {\n\t\t\t\t\tLog.w(TAG, \"Instrumentation detected, disabling framework for \" + reportedPackageName);\n\t\t\t\t\tXposedBridge.disableHooks = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tCompatibilityInfo compatInfo = (CompatibilityInfo) getObjectField(param.args[0], \"compatInfo\");\n\t\t\t\tif (appInfo.sourceDir == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tsetObjectField(activityThread, \"mBoundApplication\", param.args[0]);\n\t\t\t\tloadedPackagesInProcess.add(reportedPackageName);\n\t\t\t\tLoadedApk loadedApk = activityThread.getPackageInfoNoCheck(appInfo, compatInfo);\n\t\t\t\tXResources.setPackageNameForResDir(appInfo.packageName, loadedApk.getResDir());\n\n\t\t\t\tXC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);\n\t\t\t\tlpparam.packageName = reportedPackageName;\n\t\t\t\tlpparam.processName = (String) getObjectField(param.args[0], \"processName\");\n\t\t\t\tlpparam.classLoader = loadedApk.getClassLoader();\n\t\t\t\tlpparam.appInfo = appInfo;\n\t\t\t\tlpparam.isFirstApplication = true;\n\t\t\t\tXC_LoadPackage.callAll(lpparam);\n\n\t\t\t\tif (reportedPackageName.equals(INSTALLER_PACKAGE_NAME))\n\t\t\t\t\thookXposedInstaller(lpparam.classLoader);\n\t\t\t}\n\t\t});\n\n\t\t// system_server initialization\n\t\tif (Build.VERSION.SDK_INT < 21) {\n\t\t\tfindAndHookMethod(\"com.android.server.ServerThread\", null,\n\t\t\t\t\tBuild.VERSION.SDK_INT < 19 ? \"run\" : \"initAndLoop\", new XC_MethodHook() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\t\t\tSELinuxHelper.initForProcess(\"android\");\n\t\t\t\t\t\t\tloadedPackagesInProcess.add(\"android\");\n\n\t\t\t\t\t\t\tXC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);\n\t\t\t\t\t\t\tlpparam.packageName = \"android\";\n\t\t\t\t\t\t\tlpparam.processName = \"android\"; // it's actually system_server, but other functions return this as well\n\t\t\t\t\t\t\tlpparam.classLoader = XposedBridge.BOOTCLASSLOADER;\n\t\t\t\t\t\t\tlpparam.appInfo = null;\n\t\t\t\t\t\t\tlpparam.isFirstApplication = true;\n\t\t\t\t\t\t\tXC_LoadPackage.callAll(lpparam);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} else if (startsSystemServer) {\n\t\t\tfindAndHookMethod(ActivityThread.class, \"systemMain\", new XC_MethodHook() {\n\t\t\t\t@Override\n\t\t\t\tprotected void afterHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\tfinal ClassLoader cl = Thread.currentThread().getContextClassLoader();\n\t\t\t\t\tfindAndHookMethod(\"com.android.server.SystemServer\", cl, \"startBootstrapServices\", new XC_MethodHook() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\t\t\tSELinuxHelper.initForProcess(\"android\");\n\t\t\t\t\t\t\tloadedPackagesInProcess.add(\"android\");\n\n\t\t\t\t\t\t\tXC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);\n\t\t\t\t\t\t\tlpparam.packageName = \"android\";\n\t\t\t\t\t\t\tlpparam.processName = \"android\"; // it's actually system_server, but other functions return this as well\n\t\t\t\t\t\t\tlpparam.classLoader = cl;\n\t\t\t\t\t\t\tlpparam.appInfo = null;\n\t\t\t\t\t\t\tlpparam.isFirstApplication = true;\n\t\t\t\t\t\t\tXC_LoadPackage.callAll(lpparam);\n\n\t\t\t\t\t\t\t// Huawei\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfindAndHookMethod(\"com.android.server.pm.HwPackageManagerService\", cl, \"isOdexMode\", XC_MethodReplacement.returnConstant(false));\n\t\t\t\t\t\t\t} catch (XposedHelpers.ClassNotFoundError | NoSuchMethodError ignored) {}\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString className = \"com.android.server.pm.\" + (Build.VERSION.SDK_INT >= 23 ? \"PackageDexOptimizer\" : \"PackageManagerService\");\n\t\t\t\t\t\t\t\tfindAndHookMethod(className, cl, \"dexEntryExists\", String.class, XC_MethodReplacement.returnConstant(true));\n\t\t\t\t\t\t\t} catch (XposedHelpers.ClassNotFoundError | NoSuchMethodError ignored) {}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// when a package is loaded for an existing process, trigger the callbacks as well\n\t\thookAllConstructors(LoadedApk.class, new XC_MethodHook() {\n\t\t\t@Override\n\t\t\tprotected void afterHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\tLoadedApk loadedApk = (LoadedApk) param.thisObject;\n\n\t\t\t\tString packageName = loadedApk.getPackageName();\n\t\t\t\tXResources.setPackageNameForResDir(packageName, loadedApk.getResDir());\n\t\t\t\tif (packageName.equals(\"android\") || !loadedPackagesInProcess.add(packageName))\n\t\t\t\t\treturn;\n\n\t\t\t\tif (!getBooleanField(loadedApk, \"mIncludeCode\"))\n\t\t\t\t\treturn;\n\n\t\t\t\tXC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);\n\t\t\t\tlpparam.packageName = packageName;\n\t\t\t\tlpparam.processName = AndroidAppHelper.currentProcessName();\n\t\t\t\tlpparam.classLoader = loadedApk.getClassLoader();\n\t\t\t\tlpparam.appInfo = loadedApk.getApplicationInfo();\n\t\t\t\tlpparam.isFirstApplication = false;\n\t\t\t\tXC_LoadPackage.callAll(lpparam);\n\t\t\t}\n\t\t});\n\n\t\tfindAndHookMethod(\"android.app.ApplicationPackageManager\", null, \"getResourcesForApplication\",\n\t\t\t\tApplicationInfo.class, new XC_MethodHook() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n\t\t\t\t\t\tApplicationInfo app = (ApplicationInfo) param.args[0];\n\t\t\t\t\t\tXResources.setPackageNameForResDir(app.packageName,\n\t\t\t\t\t\t\t\tapp.uid == Process.myUid() ? app.sourceDir : app.publicSourceDir);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t// MIUI\n\t\tif (findFieldIfExists(ZygoteInit.class, \"BOOT_START_TIME\") != null) {\n\t\t\tsetStaticLongField(ZygoteInit.class, \"BOOT_START_TIME\", XposedBridge.BOOT_START_TIME);\n\t\t}\n\n\t\t// Samsung\n\t\tif (Build.VERSION.SDK_INT >= 24) {\n\t\t\tClass<?> zygote = findClass(\"com.android.internal.os.Zygote\", null);\n\t\t\ttry {\n\t\t\t\tsetStaticBooleanField(zygote, \"isEnhancedZygoteASLREnabled\", false);\n\t\t\t} catch (NoSuchFieldError ignored) {\n\t\t\t}\n\t\t}\n\t}\n  ```\n  到这里Xposed模块的启动的核心逻辑就分析完了，主要是通过Xposed定制版的zygote加载XposedBridge.jar，然后调用XposedBridge#main方法加载所有的Xposed模块，当一个进程通过zygote进程clone出来时，就会携带XposedBridge.jar的代码，同时在进程启动时回调所有的Xposed模块的入口，XposedBridge.jar中还包含Hook API，那么Xposed模块就可以通过这些API对应用程序进行Hook操作了。\n\n\n2. Java Hook的实现\n\n\t从XposedHelpers.findAndHookMethod方法开始，看Xposed是如何进行Hook的。\n  ```java\n  \t/**\n\t * Look up a method and hook it. See {@link #findAndHookMethod(String, ClassLoader, String, Object...)}\n\t * for details.\n\t */\n\tpublic static XC_MethodHook.Unhook findAndHookMethod(Class<?> clazz, String methodName, Object... parameterTypesAndCallback) {\n\t\tif (parameterTypesAndCallback.length == 0 || !(parameterTypesAndCallback[parameterTypesAndCallback.length-1] instanceof XC_MethodHook))\n\t\t\tthrow new IllegalArgumentException(\"no callback defined\");\n\n\t\tXC_MethodHook callback = (XC_MethodHook) parameterTypesAndCallback[parameterTypesAndCallback.length-1];\n\t\tMethod m = findMethodExact(clazz, methodName, getParameterClasses(clazz.getClassLoader(), parameterTypesAndCallback));\n\n\t\treturn XposedBridge.hookMethod(m, callback);\n\t}\n\n  ```\n  首先使用findMethodExact获取一个Java方法的反射表示对象m:\n  ```java\n  \t/**\n\t * Look up a method in a class and set it to accessible.\n\t * See {@link #findMethodExact(String, ClassLoader, String, Object...)} for details.\n\t *\n\t * <p>This variant requires that you already have reference to all the parameter types.\n\t */\n\tpublic static Method findMethodExact(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tString fullMethodName = clazz.getName() + '#' + methodName + getParametersString(parameterTypes) + \"#exact\";\n\n\t\tif (methodCache.containsKey(fullMethodName)) {\n\t\t\tMethod method = methodCache.get(fullMethodName);\n\t\t\tif (method == null)\n\t\t\t\tthrow new NoSuchMethodError(fullMethodName);\n\t\t\treturn method;\n\t\t}\n\n\t\ttry {\n\t\t\tMethod method = clazz.getDeclaredMethod(methodName, parameterTypes);\n\t\t\tmethod.setAccessible(true);\n\t\t\tmethodCache.put(fullMethodName, method);\n\t\t\treturn method;\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tmethodCache.put(fullMethodName, null);\n\t\t\tthrow new NoSuchMethodError(fullMethodName);\n\t\t}\n\t}\n  ```\n  这里也很简单，使用了缓存保存方法的反射对象，然后继续下一步，进入 XposedBridge#hookMethod 方法。\n  ```java\n  public static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) {\n    // 1\n\t\tif (!(hookMethod instanceof Method) && !(hookMethod instanceof Constructor<?>)) {\n\t\t\tthrow new IllegalArgumentException(\"Only methods and constructors can be hooked: \" + hookMethod.toString());\n\t\t} else if (hookMethod.getDeclaringClass().isInterface()) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot hook interfaces: \" + hookMethod.toString());\n\t\t} else if (Modifier.isAbstract(hookMethod.getModifiers())) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot hook abstract methods: \" + hookMethod.toString());\n\t\t}\n\n\t\tboolean newMethod = false;\n\t\tCopyOnWriteSortedSet<XC_MethodHook> callbacks;\n    // 2\n\t\tsynchronized (sHookedMethodCallbacks) {\n\t\t\tcallbacks = sHookedMethodCallbacks.get(hookMethod);\n\t\t\tif (callbacks == null) {\n\t\t\t\tcallbacks = new CopyOnWriteSortedSet<>();\n\t\t\t\tsHookedMethodCallbacks.put(hookMethod, callbacks);\n\t\t\t\tnewMethod = true;\n\t\t\t}\n\t\t}\n\t\tcallbacks.add(callback);\n\n\t\tif (newMethod) {\n      // 3\n\t\t\tClass<?> declaringClass = hookMethod.getDeclaringClass();\n\t\t\tint slot;\n\t\t\tClass<?>[] parameterTypes;\n\t\t\tClass<?> returnType;\n\t\t\tif (runtime == RUNTIME_ART) {\n\t\t\t\tslot = 0;\n\t\t\t\tparameterTypes = null;\n\t\t\t\treturnType = null;\n\t\t\t} else if (hookMethod instanceof Method) {\n\t\t\t\tslot = getIntField(hookMethod, \"slot\");\n\t\t\t\tparameterTypes = ((Method) hookMethod).getParameterTypes();\n\t\t\t\treturnType = ((Method) hookMethod).getReturnType();\n\t\t\t} else {\n\t\t\t\tslot = getIntField(hookMethod, \"slot\");\n\t\t\t\tparameterTypes = ((Constructor<?>) hookMethod).getParameterTypes();\n\t\t\t\treturnType = null;\n\t\t\t}\n\n\t\t\tAdditionalHookInfo additionalInfo = new AdditionalHookInfo(callbacks, parameterTypes, returnType);\n\t\t\thookMethodNative(hookMethod, declaringClass, slot, additionalInfo);\n\t\t}\n\n\t\treturn callback.new Unhook(hookMethod);\n\t}\n  ```\n  hookMethod主要功能分三个部分\n  1.检查要hook的函数是否合法，必须同时满足三个条件：第一，是普通函数或者构造函数；第二，所在类不是接口Interface；第三，函数不是abstract抽象函数。\n  2.从缓存中确认函数未被hook并将新函数加入缓存。\n  3.执行真实hook逻辑，具体代码如下。可以发现真实执行hook逻辑的函数交给了hookMethodNative函数，而这个函数实际上是一个native属性的函数。\n\n下面看hookMethodNative函数的实现\n  ```cpp\n  ////////////////////////////////////////////////////////////\n  // JNI methods\n  ////////////////////////////////////////////////////////////\n  void XposedBridge_hookMethodNative(JNIEnv* env, jclass, jobject javaReflectedMethod,\n              jobject, jint, jobject javaAdditionalInfo) {\n      // Detect usage errors.\n      ScopedObjectAccess soa(env);\n      if (javaReflectedMethod == nullptr) {\n  #if PLATFORM_SDK_VERSION >= 23\n          ThrowIllegalArgumentException(\"method must not be null\");\n  #else\n          ThrowIllegalArgumentException(nullptr, \"method must not be null\");\n  #endif\n          return;\n      }\n\n      // Get the ArtMethod of the method to be hooked.\n      ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaReflectedMethod);\n\n      // Hook the method\n      artMethod->EnableXposedHook(soa, javaAdditionalInfo);\n  }\n  ```\n\n  ```cpp\n    void ArtMethod::EnableXposedHook(ScopedObjectAccess& soa, jobject additional_info) {\n    if (UNLIKELY(IsXposedHookedMethod())) {\n      // Already hooked\n      return;\n    } else if (UNLIKELY(IsXposedOriginalMethod())) {\n      // This should never happen\n      ThrowIllegalArgumentException(StringPrintf(\"Cannot hook the method backup: %s\", PrettyMethod(this).c_str()).c_str());\n      return;\n    }\n\n    // 1.Create a backup of the ArtMethod object\n    auto* cl = Runtime::Current()->GetClassLinker();\n    auto* linear_alloc = cl->GetAllocatorForClassLoader(GetClassLoader());\n    ArtMethod* backup_method = cl->CreateRuntimeMethod(linear_alloc);\n    backup_method->CopyFrom(this, cl->GetImagePointerSize());\n    backup_method->SetAccessFlags(backup_method->GetAccessFlags() | kAccXposedOriginalMethod);\n\n    // 2.Create a Method/Constructor object for the backup ArtMethod object\n    mirror::AbstractMethod* reflected_method;\n    if (IsConstructor()) {\n      reflected_method = mirror::Constructor::CreateFromArtMethod(soa.Self(), backup_method);\n    } else {\n      reflected_method = mirror::Method::CreateFromArtMethod(soa.Self(), backup_method);\n    }\n    reflected_method->SetAccessible<false>(true);\n\n    // 3.Save extra information in a separate structure, stored instead of the native method\n    XposedHookInfo* hook_info = reinterpret_cast<XposedHookInfo*>(linear_alloc->Alloc(soa.Self(), sizeof(XposedHookInfo)));\n    hook_info->reflected_method = soa.Vm()->AddGlobalRef(soa.Self(), reflected_method);\n    hook_info->additional_info = soa.Env()->NewGlobalRef(additional_info);\n    hook_info->original_method = backup_method;\n\n    // 4\n    ScopedThreadSuspension sts(soa.Self(), kSuspended);\n    jit::ScopedJitSuspend sjs;\n    gc::ScopedGCCriticalSection gcs(soa.Self(),\n                                    gc::kGcCauseXposed,\n                                    gc::kCollectorTypeXposed);\n    ScopedSuspendAll ssa(__FUNCTION__);\n\n    cl->InvalidateCallersForMethod(soa.Self(), this);\n\n    jit::Jit* jit = art::Runtime::Current()->GetJit();\n    if (jit != nullptr) {\n      jit->GetCodeCache()->MoveObsoleteMethod(this, backup_method);\n    }\n\n    // 5\n    SetEntryPointFromJniPtrSize(reinterpret_cast<uint8_t*>(hook_info), sizeof(void*));\n    SetEntryPointFromQuickCompiledCode(GetQuickProxyInvokeHandler());\n    SetCodeItemOffset(0);\n\n    // Adjust access flags.\n    const uint32_t kRemoveFlags = kAccNative | kAccSynchronized | kAccAbstract | kAccDefault | kAccDefaultConflict;\n    SetAccessFlags((GetAccessFlags() & ~kRemoveFlags) | kAccXposedHookedMethod);\n\n    // 6\n    MutexLock mu(soa.Self(), *Locks::thread_list_lock_);\n    Runtime::Current()->GetThreadList()->ForEach(StackReplaceMethodAndInstallInstrumentation, this);\n  }\n  ```\n  具体实现分为六个部分\n  1.备份原先的Method并添加标记kAccXposedOriginalMethod\n  2.创建一个备份方法对应的反射对象\n  3.将所有相关内容保存为一个结构体存储\n  4.准备工作，处理函数的JIT即时编译以及其他\n  5.设置被hook函数的入口点（关键的hook逻辑）\n  6.恢复环境\n  这样就执行完成了函数的hook，当这个 Java 方法被调用时，会跳转到上面设置的汇编代码地址处，Xposed 将会对这个 Java 方法的参数进行转发等处理，修改方法返回值，实现最终 Hook。\n  不过没有看到最终的处理，并不知道是怎么做的，下面继续分析\n  首先看 GetQuickProxyInvokeHandler() 的返回值：\n  ```cpp\n  extern \"C\" void art_quick_proxy_invoke_handler();\n  static inline const void* GetQuickProxyInvokeHandler() {\n    return reinterpret_cast<const void*>(art_quick_proxy_invoke_handler);\n  }\n  ```\n  它是一个 art_quick_proxy_invoke_handler 函数的地址，这个函数是在其他地方实现的（有 extern 声明），经过了解，发现它是由汇编代码实现的，有 arm、arm64、mips、mips64、x86、x86_64 这几个指令集的实现，这里看一下 arm 上的实现：\n  ```cpp\n  // quick_entrypoints_arm.S\n\n.extern artQuickProxyInvokeHandler\nENTRY art_quick_proxy_invoke_handler\n    SETUP_REFS_AND_ARGS_CALLEE_SAVE_FRAME_WITH_METHOD_IN_R0\n    // 传递相关参数\n    mov     r2, r9                 @ pass Thread::Current\n    mov     r3, sp                 @ pass SP\n    // 跳转至 artQuickProxyInvokeHandler 函数\n    blx     artQuickProxyInvokeHandler  @ (Method* proxy method, receiver, Thread*, SP)\n    ldr     r2, [r9, #THREAD_EXCEPTION_OFFSET]  @ load Thread::Current()->exception_\n    add     sp, #(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)\n    .cfi_adjust_cfa_offset -(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)\n    RESTORE_REFS_ONLY_CALLEE_SAVE_FRAME\n    cbnz    r2, 1f                 @ success if no exception is pending\n    vmov    d0, r0, r1             @ store into fpr, for when it's a fpr return...\n    bx      lr                     @ return on success\n1:\n    DELIVER_PENDING_EXCEPTION\nEND art_quick_proxy_invoke_handler\n  ```\n  art_quick_proxy_invoke_handler 跳转至了 artQuickProxyInvokeHandler 函数中，那么继续跟进。\n  ```cpp\n  // qucik_trampoline_entrypoints.cc\n\n  extern \"C\" uint64_t artQuickProxyInvokeHandler(\n      ArtMethod* proxy_method, mirror::Object* receiver, Thread* self, ArtMethod** sp)\n      SHARED_REQUIRES(Locks::mutator_lock_) {\n    // bool IsXposedHookedMethod() {\n    //   return (GetAccessFlags() & kAccXposedHookedMethod) != 0;\n    // }\n    const bool is_xposed = proxy_method->IsXposedHookedMethod();\n    if (!is_xposed) {\n      DCHECK(proxy_method->IsRealProxyMethod()) << PrettyMethod(proxy_method);\n      DCHECK(receiver->GetClass()->IsProxyClass()) << PrettyMethod(proxy_method);\n    }\n    const char* old_cause = self->StartAssertNoThreadSuspension(\"Adding to IRT proxy object arguments\");\n    DCHECK_EQ((*sp), proxy_method) << PrettyMethod(proxy_method);\n    self->VerifyStack();\n    JNIEnvExt* env = self->GetJniEnv();\n    ScopedObjectAccessUnchecked soa(env);\n    ScopedJniEnvLocalRefState env_state(env);\n    const bool is_static = proxy_method->IsStatic();\n    jobject rcvr_jobj = is_static ? nullptr : soa.AddLocalReference<jobject>(receiver);\n\n    ArtMethod* non_proxy_method = proxy_method->GetInterfaceMethodIfProxy(sizeof(void*));\n    CHECK(is_xposed || !non_proxy_method->IsStatic()) << PrettyMethod(proxy_method) << \" \"\n                                                      << PrettyMethod(non_proxy_method);\n    std::vector<jvalue> args;\n    uint32_t shorty_len = 0;\n    const char* shorty = non_proxy_method->GetShorty(&shorty_len);\n    BuildQuickArgumentVisitor local_ref_visitor(sp, is_static, shorty, shorty_len, &soa, &args);\n\n    local_ref_visitor.VisitArguments();\n    if (!is_static) {\n      DCHECK_GT(args.size(), 0U) << PrettyMethod(proxy_method);\n      args.erase(args.begin());\n    }\n\n    if (is_xposed) {\n      jmethodID proxy_methodid = soa.EncodeMethod(proxy_method);\n      self->EndAssertNoThreadSuspension(old_cause);\n      // 处理 Hook 方法\n      JValue result = InvokeXposedHandleHookedMethod(soa, shorty, rcvr_jobj, proxy_methodid, args);\n      local_ref_visitor.FixupReferences();\n      // 返回 Java 方法的返回值\n      return result.GetJ();\n    }\n    // ...\n  }\n  ```\n  可以大概看出来 artQuickProxyInvokeHandler 函数是用于处理动态代理方法的，不过 Xposed 对这个方法进行了修改，使其能够处理被 Hook 的方法，重点关注下面判断语句中的代码，如果是被 Xposed Hook 的方法，那么进入 InvokeXposedHandleHookedMethod 进行处理：\n  ```cpp\n  // entrypoint_utils.cc\n\nJValue InvokeXposedHandleHookedMethod(ScopedObjectAccessAlreadyRunnable& soa, const char* shorty,\n                                      jobject rcvr_jobj, jmethodID method,\n                                      std::vector<jvalue>& args) {\n  soa.Self()->AssertThreadSuspensionIsAllowable();\n  jobjectArray args_jobj = nullptr;\n  const JValue zero;\n  int32_t target_sdk_version = Runtime::Current()->GetTargetSdkVersion();\n  // ...\n\n  // 取出 hook_info\n  const XposedHookInfo* hook_info = soa.DecodeMethod(method)->GetXposedHookInfo();\n  // 调用 Java 层的 XposedBridge.handleHookedMethod 方法\n  jvalue invocation_args[5];\n  invocation_args[0].l = hook_info->reflected_method;\n  invocation_args[1].i = 1;\n  invocation_args[2].l = hook_info->additional_info;\n  // 方法的目标作用对象 this\n  invocation_args[3].l = rcvr_jobj;\n  // 参数保存传给方法的参数\n  invocation_args[4].l = args_jobj;\n  jobject result =\n      soa.Env()->CallStaticObjectMethodA(ArtMethod::xposed_callback_class,\n                                         ArtMethod::xposed_callback_method,\n                                         invocation_args);\n\n  if (UNLIKELY(soa.Self()->IsExceptionPending())) {\n    return zero;\n  } else {\n    if (shorty[0] == 'V' || (shorty[0] == 'L' && result == nullptr)) {\n      return zero;\n    }\n    size_t pointer_size = Runtime::Current()->GetClassLinker()->GetImagePointerSize();\n    mirror::Class* result_type = soa.DecodeMethod(method)->GetReturnType(true /* resolve */, pointer_size);\n    mirror::Object* result_ref = soa.Decode<mirror::Object*>(result);\n    JValue result_unboxed;\n    if (!UnboxPrimitiveForResult(result_ref, result_type, &result_unboxed)) {\n      DCHECK(soa.Self()->IsExceptionPending());\n      return zero;\n    }\n    return result_unboxed;\n  }\n}\n  ```\n  这里就调用到了 Java 层 XposedBridge 的 handleHookedMethod 方法中。\n  ```java\n    / XposedBridge.java\n\n  private static Object handleHookedMethod(Member method, int originalMethodId, Object additionalInfoObj,\n      Object thisObject, Object[] args) throws Throwable {\n    // 取出 Hook 处理回调等信息\n    AdditionalHookInfo additionalInfo = (AdditionalHookInfo) additionalInfoObj;\n\n    if (disableHooks) {\n      try {\n        // 如果关闭 Hook，那么调用原始方法\n        return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,\n            additionalInfo.returnType, thisObject, args);\n      } catch (InvocationTargetException e) {\n        throw e.getCause();\n      }\n    }\n\n    Object[] callbacksSnapshot = additionalInfo.callbacks.getSnapshot();\n    final int callbacksLength = callbacksSnapshot.length;\n    if (callbacksLength == 0) {\n      try {\n        // 没有处理 Hook 的回调，则调用原始方法\n        return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,\n            additionalInfo.returnType, thisObject, args);\n      } catch (InvocationTargetException e) {\n        throw e.getCause();\n      }\n    }\n\n    MethodHookParam param = new MethodHookParam();\n    param.method = method;\n    param.thisObject = thisObject;\n    param.args = args;\n\n    int beforeIdx = 0;\n    do {\n      try {\n        // 回调 beforeHookedMethod 方法，表示在 Hook 之前\n        ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);\n      } catch (Throwable t) {\n        XposedBridge.log(t);\n\n        param.setResult(null);\n        param.returnEarly = false;\n        continue;\n      }\n\n      if (param.returnEarly) {\n        beforeIdx++;\n        break;\n      }\n    } while (++beforeIdx < callbacksLength);\n\n    // Hook 回调没有处理，则调用原始方法\n    if (!param.returnEarly) {\n      try {\n        param.setResult(invokeOriginalMethodNative(method, originalMethodId,\n            additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args));\n      } catch (InvocationTargetException e) {\n        param.setThrowable(e.getCause());\n      }\n    }\n\n    int afterIdx = beforeIdx - 1;\n    do {\n      Object lastResult =  param.getResult();\n      Throwable lastThrowable = param.getThrowable();\n\n      try {\n        // 调用 afterHookedMethod 方法，表示 Hook 之后\n        ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);\n      } catch (Throwable t) {\n        XposedBridge.log(t);\n\n        if (lastThrowable == null)\n          param.setResult(lastResult);\n        else\n          param.setThrowable(lastThrowable);\n      }\n    } while (--afterIdx >= 0);\n\n    // 如果有异常，则抛出异常，否则返回处理后的结果\n    if (param.hasThrowable())\n      throw param.getThrowable();\n    else\n      return param.getResult();\n  }\n  ```\n\n  这里就能清晰的看到 Hook 最终处理了，至此就完成了 Hook。其中 invokeOriginalMethodNative 的实现如下：\n  ```cpp\n  // libxposed_art.cpp\n\n  jobject XposedBridge_invokeOriginalMethodNative(JNIEnv* env, jclass, jobject javaMethod,\n              jint isResolved, jobjectArray, jclass, jobject javaReceiver, jobjectArray javaArgs) {\n      ScopedFastNativeObjectAccess soa(env);\n      if (UNLIKELY(!isResolved)) {\n          // 从备份的方法中取得原始方法\n          ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaMethod);\n          if (LIKELY(artMethod->IsXposedHookedMethod())) {\n              javaMethod = artMethod->GetXposedHookInfo()->reflected_method;\n          }\n      }\n  #if PLATFORM_SDK_VERSION >= 23\n      // 调用虚拟机的执行方法调用原始方法逻辑\n      return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs);\n  #else\n      return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs, true);\n  #endif\n  }\n  ```\n  还有最后一个问题，就是一个被 Hook 的方法的调用过程，上面只分析了处理过程，而没有正向的调用，下面开始分析。\n\n  分析一个 Java 方法的调用，可以从 AndroidRuntime.start 中开始，Java 虚拟机执行的第一个类是 ZygoteInit 从此就进入了 Java 层，它使用的是 JNIEnv 提供的 CallStaticVoidMethod 方法，看一下它的实现。\n  ```cpp\n  // jni_internal.cc\n  static void CallStaticVoidMethod(JNIEnv* env, jclass, jmethodID mid, ...) {\n    va_list ap;\n    va_start(ap, mid);\n    CHECK_NON_NULL_ARGUMENT_RETURN_VOID(mid);\n    ScopedObjectAccess soa(env);\n    InvokeWithVarArgs(soa, nullptr, mid, ap);\n    va_end(ap);\n  }\n  ```\n  调用了 InvokeWithVarArgs 函数\n  继续看 InvokeWithArgArray函数\n  最终是调用到了 ArtMethod 的 Invoke 函数：\n  ```cpp\n  // reflection.cc\n  void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,\n                        const char* shorty) {\n    // ...\n\n    ManagedStack fragment;\n    self->PushManagedStackFragment(&fragment);\n\n    Runtime* runtime = Runtime::Current();\n    if (UNLIKELY(!runtime->IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, this))) {\n      // ...\n    } else {\n      DCHECK_EQ(runtime->GetClassLinker()->GetImagePointerSize(), sizeof(void*));\n\n      constexpr bool kLogInvocationStartAndReturn = false;\n      bool have_quick_code = GetEntryPointFromQuickCompiledCode() != nullptr;\n      if (LIKELY(have_quick_code)) {\n        // ...\n\n        if (!IsStatic()) {\n          (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty);\n        } else {\n          (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty);\n        }\n        \n        // ...\n      } else {\n        // ...\n      }\n    }\n\n    self->PopManagedStackFragment(fragment);\n  }\n  ```\n  根据 Java 方法类型是非静态还是静态，跳入 art_quick_invoke_stub 或 art_quick_invoke_static_stub，看一下 art_quick_invoke_stub：\n  ```cpp\n  // reflection.cc\n  extern \"C\" void art_quick_invoke_stub(ArtMethod* method, uint32_t* args, uint32_t args_size,\n                                        Thread* self, JValue* result, const char* shorty) {\n    quick_invoke_reg_setup<false>(method, args, args_size, self, result, shorty);\n  }\n  ```\n  ```cpp\n  // reflection.cc\n\n  template <bool kIsStatic>\n  static void quick_invoke_reg_setup(ArtMethod* method, uint32_t* args, uint32_t args_size,\n                                    Thread* self, JValue* result, const char* shorty) {\n    uint32_t core_reg_args[4];\n    uint32_t fp_reg_args[16];\n    uint32_t gpr_index = 1;\n    uint32_t fpr_index = 0;\n    uint32_t fpr_double_index = 0;\n    uint32_t arg_index = 0;\n    const uint32_t result_in_float = kArm32QuickCodeUseSoftFloat ? 0 :\n        (shorty[0] == 'F' || shorty[0] == 'D') ? 1 : 0;\n\n    if (!kIsStatic) {\n      core_reg_args[gpr_index++] = args[arg_index++];\n    }\n\n    for (uint32_t shorty_index = 1; shorty[shorty_index] != '\\0'; ++shorty_index, ++arg_index) {\n      char arg_type = shorty[shorty_index];\n      if (kArm32QuickCodeUseSoftFloat) {\n        arg_type = (arg_type == 'D') ? 'J' : arg_type;\n        arg_type = (arg_type == 'F') ? 'I' : arg_type;\n      }\n      switch (arg_type) {\n        case 'D': {\n          fpr_double_index = std::max(fpr_double_index, RoundUp(fpr_index, 2));\n          if (fpr_double_index < arraysize(fp_reg_args)) {\n            fp_reg_args[fpr_double_index++] = args[arg_index];\n            fp_reg_args[fpr_double_index++] = args[arg_index + 1];\n          }\n          ++arg_index;\n          break;\n        }\n        case 'F':\n          if (fpr_index % 2 == 0) {\n            fpr_index = std::max(fpr_double_index, fpr_index);\n          }\n          if (fpr_index < arraysize(fp_reg_args)) {\n            fp_reg_args[fpr_index++] = args[arg_index];\n          }\n          break;\n        // ...\n      }\n    }\n\n    // 进入下一步\n    art_quick_invoke_stub_internal(method, args, args_size, self, result, result_in_float,\n        core_reg_args, fp_reg_args);\n  }\n  ```\n  最后是调用了 art_quick_invoke_stub_internal，它是汇编代码实现的：\n  ```\n  // quick_entrypoints_arm.S\n\n  ENTRY art_quick_invoke_stub_internal\n      SPILL_ALL_CALLEE_SAVE_GPRS             @ spill regs (9)\n      mov    r11, sp                         @ save the stack pointer\n      .cfi_def_cfa_register r11\n\n      mov    r9, r3                          @ move managed thread pointer into r9\n\n      add    r4, r2, #4                      @ create space for method pointer in frame\n      sub    r4, sp, r4                      @ reserve & align *stack* to 16 bytes: native calling\n      and    r4, #0xFFFFFFF0                 @ convention only aligns to 8B, so we have to ensure ART\n      mov    sp, r4                          @ 16B alignment ourselves.\n\n      mov    r4, r0                          @ save method*\n      add    r0, sp, #4                      @ pass stack pointer + method ptr as dest for memcpy\n      bl     memcpy                          @ memcpy (dest, src, bytes)\n      mov    ip, #0                          @ set ip to 0\n      str    ip, [sp]                        @ store null for method* at bottom of frame\n\n      ldr    ip, [r11, #48]                  @ load fp register argument array pointer\n      vldm   ip, {s0-s15}                    @ copy s0 - s15\n\n      ldr    ip, [r11, #44]                  @ load core register argument array pointer\n      mov    r0, r4                          @ restore method*\n      add    ip, ip, #4                      @ skip r0\n      ldm    ip, {r1-r3}                     @ copy r1 - r3\n\n  #ifdef ARM_R4_SUSPEND_FLAG\n      mov    r4, #SUSPEND_CHECK_INTERVAL     @ reset r4 to suspend check interval\n  #endif\n\n      ldr    ip, [r0, #ART_METHOD_QUICK_CODE_OFFSET_32]  @ get pointer to the code\n      blx    ip                              @ call the method\n\n      mov    sp, r11                         @ restore the stack pointer\n      .cfi_def_cfa_register sp\n\n      ldr    r4, [sp, #40]                   @ load result_is_float\n      ldr    r9, [sp, #36]                   @ load the result pointer\n      cmp    r4, #0\n      ite    eq\n      strdeq r0, [r9]                        @ store r0/r1 into result pointer\n      vstrne d0, [r9]                        @ store s0-s1/d0 into result pointer\n\n      pop    {r4, r5, r6, r7, r8, r9, r10, r11, pc}               @ restore spill regs\n  END art_quick_invoke_stub_internal\n\n  ```\n  其中中间部分一行代码使用 ldr 指令设置 ip 寄存器的位置来指示指令地址，使用到了 ART_METHOD_QUICK_CODE_OFFSET_32 这个宏，它是 32，表示 EntryPointFromQuickCompiledCodeOffset 这个函数返回的成员的偏移，也就是 entry_point_from_quick_compiled_code_。\n  ```\n  // asm_support.h\n\n  #define ART_METHOD_QUICK_CODE_OFFSET_32 32\n  ADD_TEST_EQ(ART_METHOD_QUICK_CODE_OFFSET_32,\n              art::ArtMethod::EntryPointFromQuickCompiledCodeOffset(4).Int32Value())\n  ```\n  \n  ```cpp\n  // art_method.h\n  static MemberOffset EntryPointFromQuickCompiledCodeOffset(size_t pointer_size) {\n    return MemberOffset(PtrSizedFieldsOffset(pointer_size) + OFFSETOF_MEMBER(\n        PtrSizedFields, entry_point_from_quick_compiled_code_) / sizeof(void*) * pointer_size);\n  }\n  ```\n\n  回到前面 Hook 时，使用了 SetEntryPointFromQuickCompiledCode，其实就是设置这个变量。\n  ```cpp\n  // art_method.h\n\n  void SetEntryPointFromQuickCompiledCode(const void* entry_point_from_quick_compiled_code) {\n      SetEntryPointFromQuickCompiledCodePtrSize(entry_point_from_quick_compiled_code,\n                                                sizeof(void*));\n    }\n    ALWAYS_INLINE void SetEntryPointFromQuickCompiledCodePtrSize(\n        const void* entry_point_from_quick_compiled_code, size_t pointer_size) {\n      DCHECK(Runtime::Current()->IsAotCompiler() || !IsXposedHookedMethod());\n      SetNativePointer(EntryPointFromQuickCompiledCodeOffset(pointer_size),\n                      entry_point_from_quick_compiled_code, pointer_size);\n    }\n  ```\n  那么下一步使用了 blx 跳转指令，代码就会跳转到这个地址上执行，进入 GetQuickProxyInvokeHandler 返回的地址 art_quick_proxy_invoke_handler 中， 最后执行 artQuickProxyInvokeHandler 函数，Xposed 在这个函数里面处理了 Hook，完成 Hook。\n\n### References\nhttps://blog.csdn.net/weixin_47883636/article/details/109018440\nhttps://bbs.pediy.com/thread-267048.htm\n深入理解Android","tags":["reverse"],"categories":["reverse"]},{"title":"Frida原理及源码分析","url":"/2022/03/06/Frida原理及源码分析/","content":"\n\n### 源码编译\n\nTODO","tags":["reverse"],"categories":["reverse"]},{"title":"P**t**Mail分析","url":"/2021/10/21/P-t-Mail分析/","content":"\n### 0x1 流程分析\n通过MessageDataService+Decrypt文件中的'decryptBodyIfNeeded'方法进行定位，最终定位到的解密函数为'*CryptoKeyRing decrypt:verifyKey:verifyTime:error:*'，返回结果为解密后明文数据。\n```javascript\n//CryptoKeyRing decrypt:verifyKey:verifyTime:error:\nvar className = \"CryptoKeyRing\";\nvar funcName = \"- decrypt:verifyKey:verifyTime:error:\";\nvar hook = eval('ObjC.classes.' + className + '[\"' + funcName + '\"]');\n\tInterceptor.attach(hook.implementation, {\n\t\tonEnter: function (args) {\n\t\t\tconsole.log('decrypt:verifyKey:verifyTime:error: called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n') + '\\n')\n\t\t\tconsole.log('arg2:', new ObjC.Object(args[2]), new ObjC.Object(args[2]).getBinary())\n\t\t\tconsole.log('arg3:', args[3])\n\t},\n\tonLeave: function (retval) {\n\t\tconsole.log('CryptoKeyRing ret:', new ObjC.Object(retval).getString())\n\t}\n})\n```\n通过函数调用堆栈定位decryptBodyIfNeeded方法，对应的偏移地址为0x2337B0，通过源码分析得知函数参数为Message对象，Message在内存中的数据如下所示。\n其中包含了重要的信息，如加密后的邮件内容，私钥，私钥加密密钥\n```\n<ProtonMail.Message: 0x283afde60> (entity: Message; id: 0xcf2b0d86941c9374 <x-coredata://******31-2273-41A4-84A2-A54FEBCEE2AF/Message/p1>; data: {\n    action = 0;\n    addressID = \"******************tWo-uplvkkdNzymweyX7eWEDpJG8X7XXr4x8USTPKHFDxLFmXfhRv1Q==\";\n    attachments =     (\n        \"0xcf2b0d8694309378 <x-coredata://******31-2273-41A4-84A2-A54FEBCEE2AF/Attachment/p10>\",\n        \"0xcf2b0d86943c9378 <x-coredata://******31-2273-41A4-84A2-A54FEBCEE2AF/Attachment/p9>\"\n    );\n    bccList = \"[]\";\n    body = \"-----BEGIN PGP MESSAGE-----\\nVersion: ProtonMail\\n\\nwcBLA8MiuHhNXi7vA\"******************qHf0pZXN\\nOgkfHM+Sbf8HyS3bEUYNT9LCxnd6a5ou3zSfTRWgL1kse6Npt7xsolHg5vtR\\ni9sI4LOwAhQhV8jp96HqNsWVTWprY\";\n    cachedAddressRaw = \"{length = 50, bytes = 0x62706c69 73743030 d4010203 04050607 ... 246f626a 65637473 }\";\n    cachedAuthCredentialRaw = \"{length = 50, bytes = 0x62706c69 73743030 d4010203 04050607 ... 246f626a 65637473 }\";\n    cachedPassphraseRaw = \"{length = 31, bytes = 0x586f794f 544a6f4f 4c73516b 54313065 ... 61697338 54663043 }\";\n    cachedPrivateKeysRaw = \"{length = 50, bytes = 0x62706c69 73743030 d4010203 04050607 ... 246f626a 65637473 }\";\n    ccList = \"[]\";\n    expirationOffset = 0;\n    expirationTime = nil;\n    flags = 9229;\n    header = \"In-Reply-To: <x2jmDa\"******************lvHAr3Z9Yq7Pov8GLFkxe\"******************95Eothn8oHAJ9E_Z3agujm0GRAI=@pr\\n\";livered-To: \"******************@protonmail.commil.protonmail.ch; Wed, 22 Sep 2021 09:23:49 +0000G\"******************5TZe3y4CXx1O2CZX_JA=@protonmail.com>\n    isDetailDownloaded = 1;\n    isEncrypted = 1;\n    isSending = 0;\n    labels =     (\n        \"0xcf2b0d8694349376 <x-coredata://\"**********31-2273-41A4-84A2-A54FEBCEE2AF/Label/p11>\",\n        \"0xcf2b0d8694089376 <x-coredata://\"******************-2273-41A4-84A2-A54FEBCEE2AF/Label/p4>\"\n    );\n    lastModified = nil;\n    messageID = \"LRsxrhOnfAJ-sLuXdnYs3vBYRhLQ4dIg4ZgMct_0Q6u7wrm9M3yOlr7Pgnc3QWpxsbnjWrDzd65HSsjneGPj1Q==\";\n    messageStatus = 1;\n    messageType = 0;\n    mimeType = \"text/html\";\n    numAttachments = 2;\n    orginalMessageID = \"\";\n    orginalTime = nil;\n    password = \"\";\n    passwordEncryptedBody = \"\";\n    passwordHint = \"\";\n    replyTos = \"[{\\\"Address\\\":\\\"******@protonmail.com\\\",\\\"Name\\\":\\\"\\\"}]\";\n    sender = \"{\\\"Name\\\":\\\"\\\",\\\"Address\\\":\\******@protonmail.com\\\"}\";\n    size = 9069596;\n    spamScore = 0;\n    time = \"2021-09-22 09:23:42 +0000\";\n    title = \"******\";\n    toList = \"[{\\\"Address\\\":******x001@protonmail.com\\\",\\\"Name\\\":\\\"\\\",\\\"Group\\\":\\\"\\\"}]\";\n    unRead = 0;\n    userID = \"******yO32t6GomKW******xvYnH9AYBAQ==\";\n})\n```\n\n## 0x2 数据存储\n当设备离线时，ProtonMail还可以对本地有缓存的数据进行解密，所以接下来需要找到这些数据的存储位置。根据文档中的说明可知，数据保存在 Keychain ，CoreData 数据库，应用程序目录中的 UserDefaults 字典中。\n\n除了Keychain 数据外，其他数据保存在两个路径中，分别为\n```\n/private/var/mobile/Containers/Data/Application/\n/private/var/mobile/Containers/Shared/AppGroup/\n```\n使用keychain-dumper进行对keychain进行dump操作，发现了感兴趣的数据，一个32字节长度的字符串，也就是mainKey\n```\nGeneric Password\n----------------\nService: ch.protonmail\nAccount: NoneProtection\nEntitlement Group: 2SB5Z68H26.ch.protonmail.protonmail\nLabel: (null)\n[34mAccessible Attribute: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, protection level 4\n[37mDescription: (null)\nComment: (null)\nSynchronizable: 0\nGeneric Field: (null)\nKeychain Data (Hex): 0x1e******91352b0b953d56eb922b0c5d6d\n```\n\n将group.ch.protonmail.protonmail.plist从手机中导出，发现了\nauthKeychainStoreKeyProtectedWithMainKey，usersInfoKeyProtectedWithMainKey两个字段\n\n对authKeychainStoreKeyProtectedWithMainKey，usersInfoKeyProtectedWithMainKey进行解密，明文数据如下所示\n","tags":["reverse"],"categories":["reverse"]},{"title":"DexClassLoader流程分析","url":"/2021/10/12/DexClassLoader流程分析-1/","content":"\nAndroid8.0 DexClassLoader流程分析\n\n源码路径\n```\n/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java\n```\n```java\n21  /**\n22   * A class loader that loads classes from {@code .jar} and {@code .apk} files\n23   * containing a {@code classes.dex} entry. This can be used to execute code not\n24   * installed as part of an application.\n25   *\n26   * <p>This class loader requires an application-private, writable directory to\n27   * cache optimized classes. Use {@code Context.getCodeCacheDir()} to create\n28   * such a directory: <pre>   {@code\n29   *   File dexOutputDir = context.getCodeCacheDir();\n30   * }</pre>\n31   *\n32   * <p><strong>Do not cache optimized classes on external storage.</strong>\n33   * External storage does not provide access controls necessary to protect your\n34   * application from code injection attacks.\n35   */\n36  public class DexClassLoader extends BaseDexClassLoader {\n37      /**\n38       * Creates a {@code DexClassLoader} that finds interpreted and native\n39       * code.  Interpreted classes are found in a set of DEX files contained\n40       * in Jar or APK files.\n41       *\n42       * <p>The path lists are separated using the character specified by the\n43       * {@code path.separator} system property, which defaults to {@code :}.\n44       *\n45       * @param dexPath the list of jar/apk files containing classes and\n46       *     resources, delimited by {@code File.pathSeparator}, which\n47       *     defaults to {@code \":\"} on Android\n48       * @param optimizedDirectory directory where optimized dex files\n49       *     should be written; must not be {@code null}\n50       * @param librarySearchPath the list of directories containing native\n51       *     libraries, delimited by {@code File.pathSeparator}; may be\n52       *     {@code null}\n53       * @param parent the parent class loader\n54       */\n55      public DexClassLoader(String dexPath, String optimizedDirectory,\n56              String librarySearchPath, ClassLoader parent) {\n57          super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);\n58      }\n59  }\n60  \n```\n\nDexClassLoader继承BaseDexClassLoader，调用BaseDexClassLoader的构造函数\n\n```java\npublic BaseDexClassLoader(String dexPath, File optimizedDirectory,\n63              String librarySearchPath, ClassLoader parent) {\n64          super(parent);\n65          this.pathList = new DexPathList(this, dexPath, librarySearchPath, null);\n66  \n67          if (reporter != null) {\n68              reporter.report(this.pathList.getDexPaths());\n69          }\n70      }\n```\n\nBaseDexClassLoader构造函数中又调用了DexPathList\nDexPathList构造函数中主要代码为makeDexElements\n```java\n155          ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();\n156          // save dexPath for BaseDexClassLoader\n157          this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,\n158                                             suppressedExceptions, definingContext);\n```\n\n```java\n    /**\n305       * Makes an array of dex/resource path elements, one per element of\n306       * the given array.\n307       */\n308      private static Element[] makeDexElements(List<File> files, File optimizedDirectory,\n309              List<IOException> suppressedExceptions, ClassLoader loader) {\n310        Element[] elements = new Element[files.size()];\n311        int elementsPos = 0;\n312        /*\n313         * Open all files and load the (direct or contained) dex files up front.\n314         */\n315        for (File file : files) {\n316            if (file.isDirectory()) {\n317                // We support directories for looking up resources. Looking up resources in\n318                // directories is useful for running libcore tests.\n319                elements[elementsPos++] = new Element(file);\n320            } else if (file.isFile()) {\n321                String name = file.getName();\n322  \n323                if (name.endsWith(DEX_SUFFIX)) {\n324                    // Raw dex file (not inside a zip/jar).\n325                    try {\n326                        DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements);\n327                        if (dex != null) {\n328                            elements[elementsPos++] = new Element(dex, null);\n329                        }\n330                    } catch (IOException suppressed) {\n331                        System.logE(\"Unable to load dex file: \" + file, suppressed);\n332                        suppressedExceptions.add(suppressed);\n333                    }\n334                } else {\n335                    DexFile dex = null;\n336                    try {\n337                        dex = loadDexFile(file, optimizedDirectory, loader, elements);\n338                    } catch (IOException suppressed) {\n339                        /*\n340                         * IOException might get thrown \"legitimately\" by the DexFile constructor if\n341                         * the zip file turns out to be resource-only (that is, no classes.dex file\n342                         * in it).\n343                         * Let dex == null and hang on to the exception to add to the tea-leaves for\n344                         * when findClass returns null.\n345                         */\n346                        suppressedExceptions.add(suppressed);\n347                    }\n348  \n349                    if (dex == null) {\n350                        elements[elementsPos++] = new Element(file);\n351                    } else {\n352                        elements[elementsPos++] = new Element(dex, file);\n353                    }\n354                }\n355            } else {\n356                System.logW(\"ClassLoader referenced unknown path: \" + file);\n357            }\n358        }\n359        if (elementsPos != elements.length) {\n360            elements = Arrays.copyOf(elements, elementsPos);\n361        }\n362        return elements;\n363      }\n364  \n```\n\n```java\n   /**\n366       * Constructs a {@code DexFile} instance, as appropriate depending on whether\n367       * {@code optimizedDirectory} is {@code null}. An application image file may be associated with\n368       * the {@code loader} if it is not null.\n369       */\n370      private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,\n371                                         Element[] elements)\n372              throws IOException {\n373          if (optimizedDirectory == null) {\n374              return new DexFile(file, loader, elements);\n375          } else {\n376              String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n377              return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);\n378          }\n379      }\n```\n\n调用DexFile类的loadDex方法，loadDex初始化DexFile类\n```java\n365      /**\n366       * Constructs a {@code DexFile} instance, as appropriate depending on whether\n367       * {@code optimizedDirectory} is {@code null}. An application image file may be associated with\n368       * the {@code loader} if it is not null.\n369       */\n370      private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,\n371                                         Element[] elements)\n372              throws IOException {\n373          if (optimizedDirectory == null) {\n374              return new DexFile(file, loader, elements);\n375          } else {\n376              String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n377              return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);\n378          }\n379      }\n```\n\n在DexFile构造函数中打开Dex文件\n```java\n89      /*\n90       * Private version with class loader argument.\n91       *\n92       * @param fileName\n93       *            the filename of the DEX file\n94       * @param loader\n95       *            the class loader creating the DEX file object\n96       * @param elements\n97       *            the temporary dex path list elements from DexPathList.makeElements\n98       */\n99      DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException {\n100          mCookie = openDexFile(fileName, null, 0, loader, elements);\n101          mInternalCookie = mCookie;\n102          mFileName = fileName;\n103          //System.out.println(\"DEX FILE cookie is \" + mCookie + \" fileName=\" + fileName);\n104      }\n```\n\n继续跟进，这里的openDexFileNative方法通过名称可知是一个Native方法\n```java\n346      /*\n347       * Open a DEX file.  The value returned is a magic VM cookie.  On\n348       * failure, an IOException is thrown.\n349       */\n350      private static Object openDexFile(String sourceName, String outputName, int flags,\n351              ClassLoader loader, DexPathList.Element[] elements) throws IOException {\n352          // Use absolute paths to enable the use of relative paths when testing on host.\n353          return openDexFileNative(new File(sourceName).getAbsolutePath(),\n354                                   (outputName == null)\n355                                       ? null\n356                                       : new File(outputName).getAbsolutePath(),\n357                                   flags,\n358                                   loader,\n359                                   elements);\n360      }\n361  \n```\n\n源码路径\n```\n/art/runtime/native/dalvik_system_DexFile.cc\n```\n关键函数为OpenDexFilesFromOat\n```cpp\n// TODO(calin): clean up the unused parameters (here and in libcore).\n258  static jobject DexFile_openDexFileNative(JNIEnv* env,\n259                                           jclass,\n260                                           jstring javaSourceName,\n261                                           jstring javaOutputName ATTRIBUTE_UNUSED,\n262                                           jint flags ATTRIBUTE_UNUSED,\n263                                           jobject class_loader,\n264                                           jobjectArray dex_elements) {\n265    ScopedUtfChars sourceName(env, javaSourceName);\n266    if (sourceName.c_str() == nullptr) {\n267      return 0;\n268    }\n269  \n270    Runtime* const runtime = Runtime::Current();\n271    ClassLinker* linker = runtime->GetClassLinker();\n272    std::vector<std::unique_ptr<const DexFile>> dex_files;\n273    std::vector<std::string> error_msgs;\n274    const OatFile* oat_file = nullptr;\n275  \n276    dex_files = runtime->GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),\n277                                                                 class_loader,\n278                                                                 dex_elements,\n279                                                                 /*out*/ &oat_file,\n280                                                                 /*out*/ &error_msgs);\n281  \n282    if (!dex_files.empty()) {\n283      jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files);\n284      if (array == nullptr) {\n285        ScopedObjectAccess soa(env);\n286        for (auto& dex_file : dex_files) {\n287          if (linker->IsDexFileRegistered(soa.Self(), *dex_file)) {\n288            dex_file.release();\n289          }\n290        }\n291      }\n292      return array;\n293    } else {\n294      ScopedObjectAccess soa(env);\n295      CHECK(!error_msgs.empty());\n296      // The most important message is at the end. So set up nesting by going forward, which will\n297      // wrap the existing exception as a cause for the following one.\n298      auto it = error_msgs.begin();\n299      auto itEnd = error_msgs.end();\n300      for ( ; it != itEnd; ++it) {\n301        ThrowWrappedIOException(\"%s\", it->c_str());\n302      }\n303  \n304      return nullptr;\n305    }\n306  }\n```\n\n生成oat文件\n```cpp\nif (!oat_file_assistant.IsUpToDate()) {\n634      // Update the oat file on disk if we can, based on the --compiler-filter\n635      // option derived from the current runtime options.\n636      // This may fail, but that's okay. Best effort is all that matters here.\n637      switch (oat_file_assistant.MakeUpToDate(/*profile_changed*/false, /*out*/ &error_msg)) {\n638        case OatFileAssistant::kUpdateFailed:\n639          LOG(WARNING) << error_msg;\n640          break;\n641  \n642        case OatFileAssistant::kUpdateNotAttempted:\n643          // Avoid spamming the logs if we decided not to attempt making the oat\n644          // file up to date.\n645          VLOG(oat) << error_msg;\n646          break;\n647  \n648        case OatFileAssistant::kUpdateSucceeded:\n649          // Nothing to do.\n650          break;\n651      }\n652    }\n```\n\n```cpp\n224  OatFileAssistant::MakeUpToDate(bool profile_changed, std::string* error_msg) {\n225    CompilerFilter::Filter target;\n226    if (!GetRuntimeCompilerFilterOption(&target, error_msg)) {\n227      return kUpdateNotAttempted;\n228    }\n229  \n230    OatFileInfo& info = GetBestInfo();\n231    switch (info.GetDexOptNeeded(target, profile_changed)) {\n232      case kNoDexOptNeeded:\n233        return kUpdateSucceeded;\n234  \n235      // TODO: For now, don't bother with all the different ways we can call\n236      // dex2oat to generate the oat file. Always generate the oat file as if it\n237      // were kDex2OatFromScratch.\n238      case kDex2OatFromScratch:\n239      case kDex2OatForBootImage:\n240      case kDex2OatForRelocation:\n241      case kDex2OatForFilter:\n242        return GenerateOatFileNoChecks(info, target, error_msg);\n243    }\n244    UNREACHABLE();\n245  }\n```\n```cpp\n616  OatFileAssistant::ResultOfAttemptToUpdate OatFileAssistant::GenerateOatFileNoChecks(\n617        OatFileAssistant::OatFileInfo& info, CompilerFilter::Filter filter, std::string* error_msg) {\n\t\t······\n694    if (!Dex2Oat(args, error_msg)) {\n695      // Manually delete the oat and vdex files. This ensures there is no garbage\n696      // left over if the process unexpectedly died.\n697      vdex_file->Erase();\n698      unlink(vdex_file_name.c_str());\n699      oat_file->Erase();\n700      unlink(oat_file_name.c_str());\n701      return kUpdateFailed;\n702    }\n    ······\n}\n```\n\n构造命令行参数，准备调用dex2oat\n```cpp\n721  bool OatFileAssistant::Dex2Oat(const std::vector<std::string>& args,\n722                                 std::string* error_msg) {\n723    Runtime* runtime = Runtime::Current();\n724    std::string image_location = ImageLocation();\n725    if (image_location.empty()) {\n726      *error_msg = \"No image location found for Dex2Oat.\";\n727      return false;\n728    }\n729  \n730    std::vector<std::string> argv;\n731    argv.push_back(runtime->GetCompilerExecutable());\n732    argv.push_back(\"--runtime-arg\");\n733    argv.push_back(\"-classpath\");\n734    argv.push_back(\"--runtime-arg\");\n735    std::string class_path = runtime->GetClassPathString();\n736    if (class_path == \"\") {\n737      class_path = OatFile::kSpecialSharedLibrary;\n738    }\n739    argv.push_back(class_path);\n740    if (runtime->IsJavaDebuggable()) {\n741      argv.push_back(\"--debuggable\");\n742    }\n743    runtime->AddCurrentRuntimeFeaturesAsDex2OatArguments(&argv);\n744  \n745    if (!runtime->IsVerificationEnabled()) {\n746      argv.push_back(\"--compiler-filter=verify-none\");\n747    }\n748  \n749    if (runtime->MustRelocateIfPossible()) {\n750      argv.push_back(\"--runtime-arg\");\n751      argv.push_back(\"-Xrelocate\");\n752    } else {\n753      argv.push_back(\"--runtime-arg\");\n754      argv.push_back(\"-Xnorelocate\");\n755    }\n756  \n757    if (!kIsTargetBuild) {\n758      argv.push_back(\"--host\");\n759    }\n760  \n761    argv.push_back(\"--boot-image=\" + image_location);\n762  \n763    std::vector<std::string> compiler_options = runtime->GetCompilerOptions();\n764    argv.insert(argv.end(), compiler_options.begin(), compiler_options.end());\n765  \n766    argv.insert(argv.end(), args.begin(), args.end());\n767  \n768    std::string command_line(android::base::Join(argv, ' '));\n769    return Exec(argv, error_msg);\n770  }\n```\n\n执行函数\n```cpp\nint ExecAndReturnCode(std::vector<std::string>& arg_vector, std::string* error_msg) {\n35    const std::string command_line(android::base::Join(arg_vector, ' '));\n36    CHECK_GE(arg_vector.size(), 1U) << command_line;\n37  \n38    // Convert the args to char pointers.\n39    const char* program = arg_vector[0].c_str();\n40    std::vector<char*> args;\n41    for (size_t i = 0; i < arg_vector.size(); ++i) {\n42      const std::string& arg = arg_vector[i];\n43      char* arg_str = const_cast<char*>(arg.c_str());\n44      CHECK(arg_str != nullptr) << i;\n45      args.push_back(arg_str);\n46    }\n47    args.push_back(nullptr);\n48  \n49    // fork and exec\n50    pid_t pid = fork();\n51    if (pid == 0) {\n52      // no allocation allowed between fork and exec\n53  \n54      // change process groups, so we don't get reaped by ProcessManager\n55      setpgid(0, 0);\n56  \n57      // (b/30160149): protect subprocesses from modifications to LD_LIBRARY_PATH, etc.\n58      // Use the snapshot of the environment from the time the runtime was created.\n59      char** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()->GetEnvSnapshot();\n60      if (envp == nullptr) {\n61        execv(program, &args[0]);\n62      } else {\n63        execve(program, &args[0], envp);\n64      }\n65      PLOG(ERROR) << \"Failed to execve(\" << command_line << \")\";\n66      // _exit to avoid atexit handlers in child.\n67      _exit(1);\n68    } else {\n69      if (pid == -1) {\n70        *error_msg = StringPrintf(\"Failed to execv(%s) because fork failed: %s\",\n71                                  command_line.c_str(), strerror(errno));\n72        return -1;\n73      }\n74  \n75      // wait for subprocess to finish\n76      int status = -1;\n77      pid_t got_pid = TEMP_FAILURE_RETRY(waitpid(pid, &status, 0));\n78      if (got_pid != pid) {\n79        *error_msg = StringPrintf(\"Failed after fork for execv(%s) because waitpid failed: \"\n80                                  \"wanted %d, got %d: %s\",\n81                                  command_line.c_str(), pid, got_pid, strerror(errno));\n82        return -1;\n83      }\n84      if (WIFEXITED(status)) {\n85        return WEXITSTATUS(status);\n86      }\n87      return -1;\n88    }\n89  }\n```\n至此dex2oat过程完成\n\n这里有两套加载流程，成功生成oat文件则加载优化后的文件，否则加载原始dex文件\n```cpp\n756      if (!added_image_space) {\n757        DCHECK(dex_files.empty());\n758        dex_files = oat_file_assistant.LoadDexFiles(*source_oat_file, dex_location);\n759      }\n```\n```cpp\n298  std::vector<std::unique_ptr<const DexFile>> OatFileAssistant::LoadDexFiles(\n299      const OatFile& oat_file, const char* dex_location) {\n311    std::unique_ptr<const DexFile> dex_file = oat_dex_file->OpenDexFile(&error_msg);\n312    if (dex_file.get() == nullptr) {\n313      LOG(WARNING) << \"Failed to open dex file from oat dex file: \" << error_msg;\n314      return std::vector<std::unique_ptr<const DexFile>>();\n315    }\n}\n```\n```cpp\n  std::unique_ptr<const DexFile> OatFile::OatDexFile::OpenDexFile(std::string* error_msg) const {\n1319    ScopedTrace trace(__PRETTY_FUNCTION__);\n1320    static constexpr bool kVerify = false;\n1321    static constexpr bool kVerifyChecksum = false;\n1322    return DexFile::Open(dex_file_pointer_,\n1323                         FileSize(),\n1324                         dex_file_location_,\n1325                         dex_file_location_checksum_,\n1326                         this,\n1327                         kVerify,\n1328                         kVerifyChecksum,\n1329                         error_msg);\n1330  }\n```\n\n加载原始dex\n```cpp\n765    // Fall back to running out of the original dex file if we couldn't load any\n766    // dex_files from the oat file.\n767    if (dex_files.empty()) {\n768      if (oat_file_assistant.HasOriginalDexFiles()) {\n769        if (Runtime::Current()->IsDexFileFallbackEnabled()) {\n770          static constexpr bool kVerifyChecksum = true;\n771          if (!DexFile::Open(\n772              dex_location, dex_location, kVerifyChecksum, /*out*/ &error_msg, &dex_files)) {\n773            LOG(WARNING) << error_msg;\n774            error_msgs->push_back(\"Failed to open dex files from \" + std::string(dex_location)\n775                                  + \" because: \" + error_msg);\n776          }\n777        } else {\n778          error_msgs->push_back(\"Fallback mode disabled, skipping dex files.\");\n779        }\n780      } else {\n781        error_msgs->push_back(\"No original dex files found for dex location \"\n782            + std::string(dex_location));\n783      }\n784    }\n```\n```cpp\n212  bool DexFile::Open(const char* filename,\n213                     const std::string& location,\n214                     bool verify_checksum,\n215                     std::string* error_msg,\n216                     std::vector<std::unique_ptr<const DexFile>>* dex_files) {\n217    ScopedTrace trace(std::string(\"Open dex file \") + std::string(location));\n218    DCHECK(dex_files != nullptr) << \"DexFile::Open: out-param is nullptr\";\n219    uint32_t magic;\n220    File fd = OpenAndReadMagic(filename, &magic, error_msg);\n221    if (fd.Fd() == -1) {\n222      DCHECK(!error_msg->empty());\n223      return false;\n224    }\n225    if (IsZipMagic(magic)) {\n226      return DexFile::OpenZip(fd.Release(), location, verify_checksum, error_msg, dex_files);\n227    }\n228    if (IsDexMagic(magic)) {\n229      std::unique_ptr<const DexFile> dex_file(DexFile::OpenFile(fd.Release(),\n230                                                                location,\n231                                                                /* verify */ true,\n232                                                                verify_checksum,\n233                                                                error_msg));\n234      if (dex_file.get() != nullptr) {\n235        dex_files->push_back(std::move(dex_file));\n236        return true;\n237      } else {\n238        return false;\n239      }\n240    }\n241    *error_msg = StringPrintf(\"Expected valid zip or dex file: '%s'\", filename);\n242    return false;\n243  }\n```\n\n```cpp\n272  std::unique_ptr<const DexFile> DexFile::OpenFile(int fd,\n273                                                   const std::string& location,\n274                                                   bool verify,\n275                                                   bool verify_checksum,\n276                                                   std::string* error_msg) {\n277    ScopedTrace trace(std::string(\"Open dex file \") + std::string(location));\n278    CHECK(!location.empty());\n279    std::unique_ptr<MemMap> map;\n280    {\n281      File delayed_close(fd, /* check_usage */ false);\n282      struct stat sbuf;\n283      memset(&sbuf, 0, sizeof(sbuf));\n284      if (fstat(fd, &sbuf) == -1) {\n285        *error_msg = StringPrintf(\"DexFile: fstat '%s' failed: %s\", location.c_str(),\n286                                  strerror(errno));\n287        return nullptr;\n288      }\n289      if (S_ISDIR(sbuf.st_mode)) {\n290        *error_msg = StringPrintf(\"Attempt to mmap directory '%s'\", location.c_str());\n291        return nullptr;\n292      }\n293      size_t length = sbuf.st_size;\n294      map.reset(MemMap::MapFile(length,\n295                                PROT_READ,\n296                                MAP_PRIVATE,\n297                                fd,\n298                                0,\n299                                /*low_4gb*/false,\n300                                location.c_str(),\n301                                error_msg));\n302      if (map == nullptr) {\n303        DCHECK(!error_msg->empty());\n304        return nullptr;\n305      }\n306    }\n307  \n308    if (map->Size() < sizeof(DexFile::Header)) {\n309      *error_msg = StringPrintf(\n310          \"DexFile: failed to open dex file '%s' that is too short to have a header\",\n311          location.c_str());\n312      return nullptr;\n313    }\n314  \n315    const Header* dex_header = reinterpret_cast<const Header*>(map->Begin());\n316  \n317    std::unique_ptr<DexFile> dex_file = OpenCommon(map->Begin(),\n318                                                   map->Size(),\n319                                                   location,\n320                                                   dex_header->checksum_,\n321                                                   kNoOatDexFile,\n322                                                   verify,\n323                                                   verify_checksum,\n324                                                   error_msg);\n325    if (dex_file != nullptr) {\n326      dex_file->mem_map_.reset(map.release());\n327    }\n328  \n329    return dex_file;\n330  }\n```\n\n```cpp\n480  std::unique_ptr<DexFile> DexFile::OpenCommon(const uint8_t* base,\n481                                               size_t size,\n482                                               const std::string& location,\n483                                               uint32_t location_checksum,\n484                                               const OatDexFile* oat_dex_file,\n485                                               bool verify,\n486                                               bool verify_checksum,\n487                                               std::string* error_msg,\n488                                               VerifyResult* verify_result) {\n489    if (verify_result != nullptr) {\n490      *verify_result = VerifyResult::kVerifyNotAttempted;\n491    }\n492    std::unique_ptr<DexFile> dex_file(new DexFile(base,\n493                                                  size,\n494                                                  location,\n495                                                  location_checksum,\n496                                                  oat_dex_file));\n497    if (dex_file == nullptr) {\n498      *error_msg = StringPrintf(\"Failed to open dex file '%s' from memory: %s\", location.c_str(),\n499                                error_msg->c_str());\n500      return nullptr;\n501    }\n502    if (!dex_file->Init(error_msg)) {\n503      dex_file.reset();\n504      return nullptr;\n505    }\n506    if (verify && !DexFileVerifier::Verify(dex_file.get(),\n507                                           dex_file->Begin(),\n508                                           dex_file->Size(),\n509                                           location.c_str(),\n510                                           verify_checksum,\n511                                           error_msg)) {\n512      if (verify_result != nullptr) {\n513        *verify_result = VerifyResult::kVerifyFailed;\n514      }\n515      return nullptr;\n516    }\n517    if (verify_result != nullptr) {\n518      *verify_result = VerifyResult::kVerifySucceeded;\n519    }\n520    return dex_file;\n521  }\n```\n```cpp\n523  DexFile::DexFile(const uint8_t* base,\n524                   size_t size,\n525                   const std::string& location,\n526                   uint32_t location_checksum,\n527                   const OatDexFile* oat_dex_file)\n528      : begin_(base),\n529        size_(size),\n530        location_(location),\n531        location_checksum_(location_checksum),\n532        header_(reinterpret_cast<const Header*>(base)),\n533        string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),\n534        type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),\n535        field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),\n536        method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),\n537        proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),\n538        class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),\n539        method_handles_(nullptr),\n540        num_method_handles_(0),\n541        call_site_ids_(nullptr),\n542        num_call_site_ids_(0),\n543        oat_dex_file_(oat_dex_file) {\n544    CHECK(begin_ != nullptr) << GetLocation();\n545    CHECK_GT(size_, 0U) << GetLocation();\n546    // Check base (=header) alignment.\n547    // Must be 4-byte aligned to avoid undefined behavior when accessing\n548    // any of the sections via a pointer.\n549    CHECK_ALIGNED(begin_, alignof(Header));\n550  \n551    InitializeSectionsFromMapList();\n552  }\n```\n至此加载完成返回mCookie","tags":["reverse"],"categories":["reverse"]},{"title":"某IM SDK分析","url":"/2021/09/18/某IM-SDK分析/","content":"## XX\n通过文档得知聊天功能使用tcp协议，对native层的sendto,recvfrom进行hook未得到结果，由于可以把socket当作文件描述符来使用，对read,write进行hook也未得到结果，进一步分析发现应用使用多进程，对指定进程进行hook得到结果及调用堆栈。\n\nManifest中的定义\n```\n<service android:name=\"com.netease.nimlib.service.NimService\" android:process=\":core\"/>\n```\n\n调用堆栈\n```\n0x6f87f39e58 libopenjdk.so!FileDispatcherImpl_write0+0x30\n0x6f87f39e58 libopenjdk.so!FileDispatcherImpl_write0+0x30\n0x71a6eec0 boot.oat!0x11dec0\n0x71a6eec0 boot.oat!0x11dec0\nwrite:remote ip: ::ffff:59.111.232.144 write:remote port: 8080\n           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF\n7551de70  99 f8 22 98 a1 bf 6b 40 c2 eb 75 5f 4e d1 2e c0  ..\"...k@..u_N...\n7551de80  a7 86 4b b3 ea 6c 6b f3 dd 99 25 cd 5c 49 9c 5f  ..K..lk...%.\\I._\n7551de90  39 2a f3 9b 51 2f fb d7 e2 15                    9*..Q/....\n```\n\n通过调用堆栈可以直接定位到java层的实现位置，同时对java层的函数进行hook并打印堆栈即可得到发送消息的完整函数调用流程\n```java\nsocket send调用堆栈\n\tat sun.nio.ch.FileDispatcherImpl.write0(Native Method)\n\tat sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:55)\n\tat sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93)\n\tat sun.nio.ch.IOUtil.write(IOUtil.java:65)\n\tat sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:512)\n    at com.netease.nimlib.net.b.d.a.b(JavaSocket.java:130)\n\tat com.netease.nimlib.net.b.d.a.d(JavaSocket.java:100)\n\tat com.netease.nimlib.net.b.d.a.a(JavaSocket.java:88)\n\tat com.netease.nimlib.net.b.a.j.a(HeadContext.java:40)\n\tat com.netease.nimlib.net.b.c.b.a(BaseOutboundHandler.java:45)\n\tat com.netease.nimlib.net.b.b.d.a(MessageToByteEncoder.java:68)\n\tat com.netease.nimlib.net.b.c.b.a(BaseOutboundHandler.java:45)\n    at com.netease.nimlib.push.net.d$1.a(LinkClient.java:150)\n\tat com.netease.nimlib.net.b.a.g$a.a(ChannelPipeline.java:277)\n\tat com.netease.nimlib.net.b.a.g$a.run(ChannelPipeline.java:260)\n\tat com.netease.nimlib.net.b.c.h.f(SingleThreadEventExecutor.java:182)\n\tat com.netease.nimlib.net.b.c.f.b(NioEventLoop.java:203)\n\tat com.netease.nimlib.net.b.c.h$1.run(SingleThreadEventExecutor.java:59)\n\tat java.lang.Thread.run(Thread.java:764)\nsocket recv调用堆栈\n    at sun.nio.ch.FileDispatcherImpl.read0(Native Method)\n\tat sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)\n\tat sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)\n\tat sun.nio.ch.IOUtil.read(IOUtil.java:197)\n\tat sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:421)\n\tat com.netease.nimlib.net.b.d.a.a(JavaSocket.java:69)\n\tat com.netease.nimlib.net.b.a.k.g(NioSocketChannel.java:67)\n\tat com.netease.nimlib.net.b.c.f.a(NioEventLoop.java:284)\n\tat com.netease.nimlib.net.b.c.f.a(NioEventLoop.java:252)\n\tat com.netease.nimlib.net.b.c.f.q(NioEventLoop.java:226)\n\tat com.netease.nimlib.net.b.c.f.b(NioEventLoop.java:202)\n\tat com.netease.nimlib.net.b.c.h$1.run(SingleThreadEventExecutor.java:59)\n\tat java.lang.Thread.run(Thread.java:764)\n```\n这里花费了一些时间，由上可知java层的调用并没有使用Socket这个类，故在源码跟踪过程中走了弯路\n源码路径(Android 9.0)\n\n```\n/libcore/ojluni/src/main/java/sun/nio/ch/FileDispatcherImpl.java\n/libcore/luni/src/main/java/android/system/Os.java\n/libcore/luni/src/main/java/libcore/io/IoBridge.java\n/libcore/ojluni/src/main/java/java/io/FileOutputStream.java\n/libcore/ojluni/src/main/java/java/net/SocketOutputStream.java\n```\n\n顺带总结Android 9.0 Socket调用流程\n```\n/libcore/ojluni/src/main/java/java/net/Socket.java\n/libcore/ojluni/src/main/java/java/net/SocksSocketImpl.java\n/libcore/ojluni/src/main/java/java/net/PlainSocketImpl.java\n/libcore/ojluni/src/main/java/java/net/AbstractPlainSocketImpl.java\n```\n\n```java\nSocket初始化流程\n类:java.net.Socket\npublic Socket(InetAddress address, int port) ->\nSocket(InetAddress[] addresses, int port, SocketAddress localAddr,boolean stream) ->\nvoid setImpl() ->\nvoid createImpl()\n\n数据发送\n类:java.net.Socket\npublic OutputStream getOutputStream() ->\n类:java.net.SocksSocketImpl SocksSocketImpl继承了PlainSocketImpl,SocksConsts\n在SocksSocketImpl类中为找到getOutputStream的实现，去父类找\nimpl.getOutputStream() ->\n类:java.net.PlainSocketImpl PlainSocketImpl继承了AbstractPlainSocketImpl\n同时PlainSocketImpl类中也未找到getOutputStream的实现，再去父类找\n类:java.net.AbstractPlainSocketImpl\nprotected synchronized OutputStream getOutputStream()\nnew SocketOutputStream(this) ->\nprivate void socketWrite(byte b[], int off, int len) ->\n调用到native层的socketWrite0方法\nprivate native void socketWrite0(FileDescriptor fd, byte[] b, int off,int len) throws IOException;\n\n数据接收\nprivate int socketRead(FileDescriptor fd,byte b[], int off, int len,int timeout)\nprivate native int socketRead0(FileDescriptor fd,byte b[], int off, int len,int timeout)\n```\n\n官方文档函数声明\n```\n/**\n文档中函数声明\n * 发送消息。\n * @param msg    待发送的消息体，由{@link MessageBuilder}构造\n * @param resend 如果是发送失败后重发，标记为true，否则填false\n * @return InvocationFuture 可以设置回调函数。消息发送完成后才会调用，如果出错，会有具体的错误代码。\n */\npublic InvocationFuture<Void> sendMessage(IMMessage msg, boolean resend);\n```\n\n根据文档从sendMessage方法进行跟踪，定位到接口类\n```java\n类名:com.netease.nimlib.sdk.msg.MsgService\n方法名:public InvocationFuture<Void> sendMessage(IMMessage iMMessage, boolean z);\n```\n\n寻找接口实现类\n```java\n类名:com.netease.nimlib.c.e.f\n方法名:public InvocationFuture<Void> sendMessage(IMMessage iMMessage, boolean z)\n```\n\n定位到关键代码，跟踪关键函数调用流程，以下过程为函数调用链\n```java\ncom.netease.nimlib.session.i\nvoid a(c cVar, boolean z, k kVar) ->\n\ncom.netease.nimlib.session.i\nstatic void a(c cVar, boolean z, k kVar, o oVar) ->\n\ncom.netease.nimlib.session.i\nvoid b(c cVar, long j, boolean z, k kVar, o oVar) ->\n\ncom.netease.nimlib.session.i\nprivate static com.netease.nimlib.push.packet.b.c a(c cVar, long j, boolean z) -> // 组包\n\ncom.netease.nimlib.session.i\nvoid a(o oVar) ->\n\ncom.netease.nimlib.c.f\nboolean a(com.netease.nimlib.c.f.d dVar) -> // 准备消息发送\n\ncom.netease.nimlib.ipc.a\nstatic Message a(int i, Object obj) -> // 准备进程间传递的数据\n\ncom.netease.nimlib.ipc.b\npublic void a(d dVar) -> // 向另一个进程发送数据\n\ncom.netease.nimlib.ipc.b\nprivate void d() -> // 启动NimService服务并连接\n\n原理:Binder\n以上为消息构造发送到另一个进程的函数调用流程\n-------------------------------------------------\n定位到消息处理函数，case 13为消息发送\ncom.netease.nimlib.ipc.d\nprivate class b extends Handler\n\ncom.netease.nimlib.net.b.a.k\npublic c a(Object arg2) ->\n\ncom.netease.nimlib.net.b.e.a\npublic static void a(f arg0, Runnable arg1) -> // 开始干活\n\ncom.netease.nimlib.net.b.a.k // 接口实现类\npublic c a(Object obj) ->\n\ncom.netease.nimlib.net.b.a.g\npublic final void run() -> // 线程函数\n\ncom.netease.nimlib.push.net.d // 接口实现类\npublic void a(Object arg1, c arg2) ->\n\ncom.netease.nimlib.net.b.a.j\npublic void a(Object obj, c cVar) ->\n\ncom.netease.nimlib.net.b.d.a\npublic void a(ByteBuffer byteBuffer, c cVar) ->\n\ncom.netease.nimlib.net.b.d.a\nprivate boolean b(ByteBuffer byteBuffer, c cVar) -> // socket发送数据\n\n至此包发送流程跟踪完成，dump发送数据发现数据包加密，直接打印堆栈，找到加密函数\n-------------------------------------------------\nencoder 调用堆栈\n\tat com.netease.nimlib.push.net.b.b.b(Native Method)\n\tat com.netease.nimlib.net.b.b.d.a(MessageToByteEncoder.java:67)\n\tat com.netease.nimlib.net.b.c.b.a(BaseOutboundHandler.java:45)\n\tat com.netease.nimlib.push.net.d$1.a(LinkClient.java:150)\n\tat com.netease.nimlib.net.b.a.g$a.a(ChannelPipeline.java:277)\n\tat com.netease.nimlib.net.b.a.g$a.run(ChannelPipeline.java:260)\n\tat com.netease.nimlib.net.b.c.h.f(SingleThreadEventExecutor.java:182)\n\tat com.netease.nimlib.net.b.c.f.b(NioEventLoop.java:203)\n\tat com.netease.nimlib.net.b.c.h$1.run(SingleThreadEventExecutor.java:59)\n\tat java.lang.Thread.run(Thread.java:764)\n\t加密模式有三种，分别为RC4，AES，SM4，分析的样本使用RC4加密\n```\n\n## References\nnio参考\nhttps://www.cnblogs.com/duanxz/p/6759689.html\nhttps://www.cnblogs.com/duanxz/p/6759823.html\nandroid多进程\nhttps://blog.csdn.net/fanleiym/article/details/83894399\nbinder参考\nhttps://www.jianshu.com/p/a55305447954\nhttps://www.jianshu.com/p/1f66bc0c9f97","tags":["reverse"],"categories":["reverse"]},{"title":"某岩阅读App分析","url":"/2021/08/11/某岩阅读App分析/","content":"\n```javascript\nfunction hook_java() {\n    Java.perform(function() {\n\n        var RealCall = Java.use('okhttp3.RealCall')\n\n        var AddCookiesInterceptor = Java.use('com.heiyan.reader.activity.common.AddCookiesInterceptor')\n        console.log(AddCookiesInterceptor)\n        AddCookiesInterceptor.intercept.implementation = function(chain) {\n            console.log('call AddCookiesInterceptor')\n            console.log(Java.use('android.util.Log').getStackTraceString(Java.use('java.lang.Exception').$new()))\n            console.log(chain)\n            var Response = this.intercept(chain)\n            console.log(Response)\n            return Response\n        }\n\n        var BaseNetModel = Java.use('com.heiyan.reader.mvp.base.BaseNetModel')\n        BaseNetModel.doPost.overload('java.lang.String', 'java.util.Map', 'io.reactivex.Observer').implementation = function(str,map,observer) {\n            console.log(Java.use('android.util.Log').getStackTraceString(Java.use('java.lang.Exception').$new()))\n            console.log(str,map)\n            return this.doPost(str,map,observer) \n        }\n\n        BaseNetModel.doPost.overload('java.lang.String', 'java.util.Map', 'com.heiyan.reader.mvp.callback.INetCallBack').implementation = function(str,map,net_callback) {\n            console.log(Java.use('android.util.Log').getStackTraceString(Java.use('java.lang.Exception').$new()))\n            console.log(str,map)\n            return this.doPost(str,map,net_callback)\n        }\n\n        var ChapterDao = Java.use('com.heiyan.reader.model.dao.ChapterDao')\n        ChapterDao.decryptContent.implementation = function(str1,str2) {\n            console.log(str1,str2)\n            var content = this.decryptContent(str1,str2)\n            console.log(content)\n            return content\n        }\n    })\n}\nfunction hook_native() {\n    var InvCipherStr = Module.findExportByName('libHyReader.so','_ZN8CBm53AES12InvCipherStrEPcS0_')\n\n    Interceptor.attach(InvCipherStr,{\n        onEnter: function(args) {\n            this.arg0 = args[0]\n            this.in = args[1]\n            this.out = args[2]\n            console.log('call onEnter:',hexdump(this.in,{length:18244}))\n            console.log('call onEnter:',hexdump(this.out,{length:18244}))\n        },\n        onLeave: function(retval) {\n            console.log('call onLeave:',hexdump(this.out,{length:18244}))\n        }\n    })\n}\n\n\nfunction call_decrypt() {\n    var JNIUtil = Java.use('com.heiyan.reader.util.JNIUtil')\n    var id = '11659599'\n    var path = '/storage/emulated/0/heiyan/books/142275/11659599.hy'\n    var result = JNIUtil.decryptContent(id,path)\n    console.log(result)\n}\n\nfunction main() {\n    hook_java()\n    hook_native()\n}\n```","tags":["reverse"],"categories":["reverse"]},{"title":"某茄阅读App分析","url":"/2021/07/15/某茄阅读App分析/","content":"\n使用python完成的下载器\n```python\nimport frida\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import MD5\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Util.Padding import unpad\nimport base64\nimport binascii\nimport requests\nimport json\nimport time\nimport gzip\n\nclass FridaRpc:\n    \n    def __init__(self):\n        self.package_name = 'com.dragon.read'\n        self.script = None\n        self.device = None\n        self.session = None\n        self.flag = False\n        self.pid = None\n\n    def on_message(message, data):\n        if message['type'] == 'send':\n            print(\"[*] {0}\".format(message['payload']))\n        else:\n            print(message)\n\n\n    def load_script(self):\n        if self.flag == False:\n            self.device = frida.get_usb_device()\n            self.pid = self.device.spawn(self.package_name)\n            self.session = self.device.attach(self.pid)\n            with open('call_xg.js','r') as f:\n                buffer = f.read() \n            self.script = self.session.create_script(buffer)\n            self.script.on('message',self.on_message)\n            self.script.load()\n            self.device.resume(self.pid)\n            self.flag = True\n            time.sleep(3)\n        else:\n            print('脚本已加载成功...')\n\n    def get_sign(self,sign_url):\n        result = self.script.exports.callxg(sign_url)\n        print('[*] python result:',result)\n        return result\n\nclass Downloader:\n    def __init__(self):\n        self.fridaRpc = FridaRpc()\n        self.flag = False\n        self.all_items = []\n        self.decrypt_content_key = None\n        self.key_flag = False\n\n    def calcKey(self,instr):\n        keyArray = [0 for x in range(0,16)]\n        lowerCase = instr.lower()\n        length = int(len(lowerCase) / 2)\n\n        for i in range(length):\n            i2 = i * 2\n            keyArray[i] = int(lowerCase[i2:i2 + 2],16)\n            \n        return keyArray\n\n    def get_decrypt_key(self,encode_key):\n        key = 'ac25c67ddd8f38c1b37a2348828e222e'\n        base64dec = base64.b64decode(encode_key)\n        cipher = AES.new(bytes(self.calcKey(key)),AES.MODE_CBC,base64dec[0:16])\n        aesdec = cipher.decrypt(base64dec[16:])\n        return binascii.b2a_hex(unpad(aesdec,16,'pkcs7'))\n    \n    def decrypt_content(self,key,data):\n        base64dec = base64.b64decode(data)\n        iv = base64dec[0:16]\n        cipher = AES.new(bytes(self.calcKey(key)),AES.MODE_CBC,iv)\n        result = cipher.decrypt(base64.b64decode(data)[16:])\n        # print(result.decode())\n        return result.decode()\n\n    def get_xssstub(self,data):\n        # 压缩后的数据头部有些不一样\n        buffer = gzip.compress(data.encode())\n        buffer = bytearray(buffer)\n        buffer[4] = 0\n        buffer[5] = 0\n        buffer[6] = 0\n        buffer[7] = 0\n        buffer[8] = 0\n        buffer[9] = 0\n        h = MD5.new()\n        h.update(bytearray(buffer))\n        print(h.hexdigest())\n        return h.hexdigest()\n\n    def long2byte(self,data):\n        # 没登录userid为 0 直接分配16字节长度\n        bArr = bytearray(16)\n        i = 0\n        while i < 8:\n            i2 = i + 1\n            bArr[7 - i] = (data >> (64 - (i2 * 8))) & 255\n            i = i2\n        print(bArr)\n        return bArr\n\n    def encrypt_post(self,data):\n        # aes\n        # 第一个参数为 deviceid + userid\n        # 第二个参数定植 ac25c67ddd8f38c1b37a2348828e222e key\n        # 第三个参数 uuid iv\n        uuid = '7d0497b1-bb72-44'\n        cipher = AES.new(bytes(self.calcKey('ac25c67ddd8f38c1b37a2348828e222e')),AES.MODE_CBC,uuid.encode())\n        aes_enc = cipher.encrypt(pad(bytes(data),16,'pkcs7'))\n\n        # base64\n        # uuid + 加密内容\n        print(bytearray(uuid.encode())+(aes_enc))\n        base64_enc = base64.b64encode(bytearray(uuid.encode())+(aes_enc))\n        return base64_enc.decode('utf-8')\n\n        # test_data = 'N2QwNDk3YjEtYmI3Mi00NEMdsrHnL8k77UKsRo6NJ5tJ6bSSzeIZXJ9WDe9GS3MJ'\n        # cipher = AES.new(bytes(calcKey('ac25c67ddd8f38c1b37a2348828e222e')),AES.MODE_CBC,uuid.encode())\n        # res = cipher.decrypt(base64.decodebytes(test_data.encode()))\n        # print(unpad(res,16,'pkcs7'))\n\n\n    def download_file(self,book_id):\n        \n        proxies = {'http': 'http://localhost:8888', 'https': 'http://localhost:8888'}\n\n        temp_time = str(int(time.time() * 1000))\n        all_items_url = 'https://reading-hl.snssdk.com/reading/bookapi/directory/all_items/v/?need_version=true&book_id={}&iid=4468891917225655&device_id=1143968740147293&ac=wifi&uuid=358240059463018&channel=xiaomi&aid=1967&app_name=novelapp&version_code=460&version_name=4.6.0.32&device_platform=android&ssmix=a&device_type=Nexus+5&device_brand=google&language=zh&os_api=23&os_version=6.0.1&openudid=cfc4ac2063030dc&manifest_version_code=460&resolution=1080*1776&dpi=480&update_version_code=46032&_rticket={}&vip_state=0&gender=2&rom_version=M4B30Z&pv_player=370320&ab_sdk_version=2752336%2C2722396%2C2767394%2C2379407&imei=358240059463018&oaid=00000000-0000-0000-0000-000000000000&cdid=e3ff92ea-f71c-432c-b282-8903646ede5a'.format(book_id,temp_time)\n        if self.flag == False:\n             self.fridaRpc.load_script()\n        result = self.fridaRpc.get_sign(all_items_url)\n        obj = json.loads(result)\n\n        # cookies = dict(cookie = 'install_id=4468891917225655')\n        # cookies['cookie'] = 'ttreq=1$5407c2bcb2a6bd94e37551a10f239df3bf0586e5'\n        # cookies['cookie'] = 'odin_tt=36f6632442e843ea6ae741fb679cf52a86cc0d0a86f35306d15124f3139bfd2dbdb85f88a608a4c4e85fe580437e71d751f25940ae6b7dac82180c419f86d506'\n        # cookies['cookie'] = 'MONITOR_WEB_ID=adf4b9a4-93a5-47ea-bffe-b565c5eebe27'\n        # cookies['cookie'] = 'passport_csrf_token_default=61bb56dbd46cb2e6342ec3a7616ec874'\n        # cookies['cookie'] = 'passport_csrf_token=61bb56dbd46cb2e6342ec3a7616ec874'\n        # print(cookies)\n        \n        header_all_items = {\n            'cookie':'install_id=4468891917225655',\n            'cookie': 'ttreq=1$5407c2bcb2a6bd94e37551a10f239df3bf0586e5',\n            'cookie':'odin_tt=36f6632442e843ea6ae741fb679cf52a86cc0d0a86f35306d15124f3139bfd2dbdb85f88a608a4c4e85fe580437e71d751f25940ae6b7dac82180c419f86d506',\n            'cookie': 'MONITOR_WEB_ID=adf4b9a4-93a5-47ea-bffe-b565c5eebe27',\n            'cookie': 'passport_csrf_token_default=61bb56dbd46cb2e6342ec3a7616ec874',\n            'cookie': 'passport_csrf_token=61bb56dbd46cb2e6342ec3a7616ec874',\n            'accept': 'application/json; charset=utf-8',\n            'x-xs-from-web': '0',\n            'x-ss-req-ticket': str(int(time.time() * 1000)), #时间戳\n            'x-reading-request': str(int(time.time() * 1000)) + '-107420281', # String n = (System.currentTimeMillis() + Constants.ACCEPT_TIME_SEPARATOR_SERVER + Math.abs(new Random().nextInt()));\n            'gender': '2',\n            'passport-sdk-version': '21',\n            'sdk-version': '2',\n            'x-vc-bdturing-sdk-version': '2.0.0',\n            'x-ss-dp': '1967',\n            'x-tt-trace-id': '00-0a947b500d4106efa64005d3b6cc07af-0a947b500d4106ef-01',\n            'user-agent': 'com.dragon.read/460 (Linux; U; Android 6.0.1; zh_CN; Nexus 5; Build/M4B30Z; Cronet/TTNetVersion:e84d0e61 2020-09-15 QuicVersion:7aee791b 2020-06-05)',\n            'accept-encoding': 'gzip, deflate',\n            'x-ladon': obj[7],\n            'x-khronos': obj[5],\n            'x-gorgon': obj[3],\n            'x-argus': obj[1]\n            \n        }\n\n        # 获取章节列表\n        req = requests.get(all_items_url,headers = header_all_items)\n\n        print(type(req.json()))\n        print(req.json())\n        for i in req.json()['data']['item_data_list']:\n            self.all_items.append(i['item_id'])\n    \n        # print(self.all_items)\n\n        # 添加下载权限\n        # 计算x-ss-stub\n        data = '{\"amount\":1,\"book_id\":\"%s\",\"privilege_id\":6766572795204735752,\"from\":1}' % book_id\n        stub = self.get_xssstub(data)\n        temp_time = str(int(time.time() * 1000))\n        privilege_url = 'https://reading-hl.snssdk.com/reading/user/privilege/add/v:version/?iid=4468891917225655&device_id=1143968740147293&ac=wifi&uuid=358240059463018&channel=xiaomi&aid=1967&app_name=novelapp&version_code=460&version_name=4.6.0.32&device_platform=android&ssmix=a&device_type=Nexus+5&device_brand=google&language=zh&os_api=23&os_version=6.0.1&openudid=cfc4ac2063030dc&manifest_version_code=460&resolution=1080*1776&dpi=480&update_version_code=46032&_rticket={}&vip_state=0&gender=2&rom_version=M4B30Z&pv_player=370320&ab_sdk_version=2594088%2C90000563%2C2379404%2C2559153&imei=358240059463018&oaid=00000000-0000-0000-0000-000000000000&cdid=e3ff92ea-f71c-432c-b282-8903646ede5a'.format(temp_time)\n        result = self.fridaRpc.get_sign(privilege_url)\n        obj = json.loads(result)\n\n        header_privilege = {\n            'cookie':'install_id=4468891917225655',\n            'cookie': 'ttreq=1$5407c2bcb2a6bd94e37551a10f239df3bf0586e5',\n            'cookie':'odin_tt=36f6632442e843ea6ae741fb679cf52a86cc0d0a86f35306d15124f3139bfd2dbdb85f88a608a4c4e85fe580437e71d751f25940ae6b7dac82180c419f86d506',\n            'cookie': 'MONITOR_WEB_ID=adf4b9a4-93a5-47ea-bffe-b565c5eebe27',\n            'cookie': 'passport_csrf_token_default=61bb56dbd46cb2e6342ec3a7616ec874',\n            'cookie': 'passport_csrf_token=61bb56dbd46cb2e6342ec3a7616ec874',\n            'accept': 'application/json; charset=utf-8',\n            'x-xs-from-web': '0',\n            'content-encoding': 'gzip',\n            'x-ss-req-ticket': str(int(time.time() * 1000)), #时间戳\n            'x-reading-request': str(int(time.time() * 1000)) + '-107420281', # String n = (System.currentTimeMillis() + Constants.ACCEPT_TIME_SEPARATOR_SERVER + Math.abs(new Random().nextInt()));\n            'gender': '2',\n            'passport-sdk-version': '21',\n            'sdk-version': '2',\n            'x-vc-bdturing-sdk-version': '2.0.0',\n            'content-type': 'application/json; charset=utf-8',\n            'x-ss-stub': stub,\n            'x-ss-dp': '1967',\n            'x-tt-trace-id': '00-0a947b500d4106efa64005d3b6cc07af-0a947b500d4106ef-01',\n            'user-agent': 'com.dragon.read/460 (Linux; U; Android 6.0.1; zh_CN; Nexus 5; Build/M4B30Z; Cronet/TTNetVersion:e84d0e61 2020-09-15 QuicVersion:7aee791b 2020-06-05)',\n            'accept-encoding': 'gzip, deflate',\n            'x-ladon': obj[7],\n            'x-khronos': obj[5],\n            'x-gorgon': obj[3],\n            'x-argus': obj[1]   \n        }\n        req = requests.post(privilege_url,data = data,headers = header_privilege)\n        print(req.json())\n\n        i = 0\n        \n        while i < len(self.all_items):\n            # print(self.all_items[i:i + 30])\n            items = self.all_items[i:i + 30]\n            print(items)\n            # 构造下载请求连接\n            str_items = '%2C'.join(items)\n            temp_time = str(int(time.time() * 1000))\n            download_url = 'https://reading-hl.snssdk.com/reading/reader/batch_full/v/?item_ids={}&book_id={}&iid=4468891917225655&device_id=1143968740147293&ac=wifi&uuid=358240059463018&channel=xiaomi&aid=1967&app_name=novelapp&version_code=460&version_name=4.6.0.32&device_platform=android&ssmix=a&device_type=Nexus+5&device_brand=google&language=zh&os_api=23&os_version=6.0.1&openudid=cfc4ac2063030dc&manifest_version_code=460&resolution=1080*1776&dpi=480&update_version_code=46032&_rticket={}&vip_state=0&gender=2&rom_version=M4B30Z&pv_player=370320&ab_sdk_version=2594088%2C2379404%2C90000563%2C2559153&imei=358240059463018&oaid=00000000-0000-0000-0000-000000000000&cdid=e3ff92ea-f71c-432c-b282-8903646ede5a'.format(str_items,book_id,temp_time)\n            result = self.fridaRpc.get_sign(download_url)\n            obj = json.loads(result)\n            \n            # 开始下载\n            header_download = {\n                'cookie':'install_id=4468891917225655',\n                'cookie': 'ttreq=1$5407c2bcb2a6bd94e37551a10f239df3bf0586e5',\n                'cookie':'odin_tt=36f6632442e843ea6ae741fb679cf52a86cc0d0a86f35306d15124f3139bfd2dbdb85f88a608a4c4e85fe580437e71d751f25940ae6b7dac82180c419f86d506',\n                'cookie': 'MONITOR_WEB_ID=adf4b9a4-93a5-47ea-bffe-b565c5eebe27',\n                'cookie': 'passport_csrf_token_default=61bb56dbd46cb2e6342ec3a7616ec874',\n                'cookie': 'passport_csrf_token=61bb56dbd46cb2e6342ec3a7616ec874',\n                'accept': 'application/json; charset=utf-8',\n                'x-xs-from-web': '0',\n                'x-ss-req-ticket': str(int(time.time() * 1000)), #时间戳\n                'x-reading-request': str(int(time.time() * 1000)) + '-107420281', # String n = (System.currentTimeMillis() + Constants.ACCEPT_TIME_SEPARATOR_SERVER + Math.abs(new Random().nextInt()));\n                'gender': '2',\n                'passport-sdk-version': '21',\n                'sdk-version': '2',\n                'x-vc-bdturing-sdk-version': '2.0.0',\n                'x-ss-dp': '1967',\n                'x-tt-trace-id': '00-0a947f8b0d4106efa64005db03e707af-0a947f8b0d4106ef-01',\n                'user-agent': 'com.dragon.read/460 (Linux; U; Android 6.0.1; zh_CN; Nexus 5; Build/M4B30Z; Cronet/TTNetVersion:e84d0e61 2020-09-15 QuicVersion:7aee791b 2020-06-05)',\n                'accept-encoding': 'gzip, deflate',\n                'x-ladon': obj[7],\n                'x-khronos': obj[5],\n                'x-gorgon': obj[3],\n                'x-argus': obj[1]\n                \n            }\n\n            req = requests.get(download_url,headers = header_download)\n            # print(req.json())\n            json_obj = req.json()\n\n            if self.key_flag == False:\n                # 请求解密key\n                temp_time = str(int(time.time() * 1000))\n                registerkey_url = 'https://reading-hl.snssdk.com/reading/crypt/registerkey?iid=4468891917225655&device_id=1143968740147293&ac=wifi&uuid=358240059463018&channel=xiaomi&aid=1967&app_name=novelapp&version_code=460&version_name=4.6.0.32&device_platform=android&ssmix=a&device_type=Nexus+5&device_brand=google&language=zh&os_api=23&os_version=6.0.1&openudid=cfc4ac2063030dc&manifest_version_code=460&resolution=1080*1776&dpi=480&update_version_code=46032&_rticket={}&vip_state=0&gender=2&rom_version=M4B30Z&pv_player=370320&ab_sdk_version=2594088%2C2379404&imei=358240059463018&oaid=00000000-0000-0000-0000-000000000000&cdid=fade575d-ac63-436d-9018-86b6af65c863'.format(temp_time)\n                result = self.fridaRpc.get_sign(registerkey_url)\n                obj = json.loads(result)\n                data = '{\"content\":\"%s\",\"keyver\":1}' % self.encrypt_post(self.long2byte(1143968740147293))\n                print('header:',data)\n                stub = self.get_xssstub(data)\n            \n                header_registerkey = {\n                    'cookie':'install_id=4468891917225655',\n                    'cookie': 'ttreq=1$5407c2bcb2a6bd94e37551a10f239df3bf0586e5',\n                    'cookie':'odin_tt=8d110eaa29aaeb4647ba8d8782513b6e9064999b9d0505cd298b90f4ffa6ddc735d4aba5d62ffafd08dd0956535492d0187474e6fbc4dfdf5459d11de771ff7c',\n                    'accept': 'application/json; charset=utf-8',\n                    'x-xs-from-web': '0',\n                    'content-encoding': 'gzip',\n                    'x-ss-req-ticket': str(int(time.time() * 1000)), #时间戳\n                    'x-reading-request': str(int(time.time() * 1000)) + '-107420281', # String n = (System.currentTimeMillis() + Constants.ACCEPT_TIME_SEPARATOR_SERVER + Math.abs(new Random().nextInt()));\n                    'gender': '2',\n                    'passport-sdk-version': '21',\n                    'sdk-version': '2',\n                    'x-vc-bdturing-sdk-version': '2.0.0',\n                    'content-type': 'application/json; charset=utf-8',\n                    'x-ss-stub': stub,\n                    'x-ss-dp': '1967',\n                    'x-tt-trace-id': '00-1018bb0d0d4106efa64005d3b7b507af-1018bb0d0d4106ef-01',\n                    'user-agent': 'com.dragon.read/460 (Linux; U; Android 6.0.1; zh_CN; Nexus 5; Build/M4B30Z; Cronet/TTNetVersion:e84d0e61 2020-09-15 QuicVersion:7aee791b 2020-06-05)',\n                    'accept-encoding': 'gzip, deflate',\n                    'x-ladon': obj[7],\n                    'x-khronos': obj[5],\n                    'x-gorgon': obj[3],\n                    'x-argus': obj[1]   \n                }\n                req_registerkey = requests.post(registerkey_url,data = data,headers = header_registerkey)\n                print(req_registerkey.json())\n                self.key_flag = True\n                self.decrypt_content_key = self.get_decrypt_key(req_registerkey.json()['data']['key'])\n                print(self.decrypt_content_key)\n            \n            for j in json_obj['data']:\n                buffer = self.decrypt_content(self.decrypt_content_key,json_obj['data'][j]['content'])\n                title = json_obj['data'][j]['title']\n                title += '\\r\\n' + buffer + '\\r\\n'\n                print(title)\n                with open(book_id + '.txt','a+') as f:\n                    f.write(title) \n            i += 30\n        print('下载完成' + ' 文件名:' + book_id + '.txt')\n\n\nif __name__ == '__main__':\n    book_id = '6970996738412776455'\n    downloader = Downloader()\n    downloader.download_file(book_id)\n```","tags":["reverse"],"categories":["reverse"]},{"title":"某猫阅读App分析","url":"/2021/07/01/某猫阅读App分析/","content":"\n\n```javascript\nfunction hook_NativeEncryption() {\n\n    //_ZN15MD5KeyGenerator14getKeyDataSizeEv\n    Interceptor.attach(Module.getExportByName('libcommon-encryption.so','_ZN15MD5KeyGenerator14getKeyDataSizeEv'),{\n        onEnter: function(args) {\n            console.log('getKeyDataSize this:',hexdump(args[0]))\n        },\n        onLeave: function(retval) {\n            console.log('getKeyDataSize retval',retval)\n        }\n    })\n\n    //_ZN22MessageDigestAlgorithm5toStrEv\n    Interceptor.attach(Module.getExportByName('libcommon-encryption.so','_ZN22MessageDigestAlgorithm5toStrEv'),{\n        onEnter: function(args) {\n            //console.log('this:',hexdump(args[0]))\n        },\n        onLeave: function(retval) {\n            console.log('toStr retval',hexdump(retval))\n            console.log('toStr retval str',hexdump(retval.add(Process.pointerSize * 2).readPointer()))\n        }\n    })\n}\n```","tags":["reverse"],"categories":["reverse"]},{"title":"xhs shield字段分析","url":"/2021/05/04/xhs-shield字段分析/","content":"\n通过字符串\"/api/sns/v4/user/login/code\"定位到接口类\n{% asset_img xhs_1.png %}\n\n通过交叉引用找到调用处，通过一些字符串及代码特征可得知使用了retrofit网络库，retrofit本质上是对okhttp的封装，因此hook okhttp的相关函数可定位到发包位置，也可通过代码特征进行定位。\n{% asset_img xhs_2.png %}\n{% asset_img xhs_3.png %}\n\n通过搜索\"\"Base URL required.\"\"字符串定位到retrofit的build函数，交叉引用查找在哪里初始化\n{% asset_img xhs_4.png %}\n\n数量不多，hook打印堆栈查找对应功能是哪个函数调用\n```java\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at m.x.z0.g.i.a(<Xposed>:-1)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at m.x.o1.d0.x.a(XhsNetworkModule.kt:108)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at m.x.o1.d0.x.h(XhsNetworkModule.kt:2)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at m.x.o1.d0.x.i(XhsNetworkModule.kt:23)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at com.xingin.xhs.app.SkynetApplication.onCreate(SkynetApplication.kt:2)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at com.xingin.xhs.app.MainApplication.onCreate(MainApplication.kt:4)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at com.xingin.xhs.app.XhsApplication.initApplication(XhsApplication.kt:17)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at com.xingin.xhs.app.XhsApplication.beforeInitApplication(XhsApplication.kt:16)\n2021-04-16 22:51:08.032 26418-26418/? E/xhs:     at com.xingin.xhs.app.XhsApplication.onCreate(XhsApplication.kt:6)\n```\n\nIda 调试so\n```\n设置debuggable\nmagisk resetprop ro.debuggable 1\nstop;start;\n\nadb forward tcp:8700 jwdp:10539\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n```\n\n看看初始化的操作，反调试应该没处理干净，以debug模式启动会退出，没法，用frida主动调用\n```javascript\nfunction call_init() {\n\tJava.perform(() => {\n\t\t//var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication();\n\t\t//var context = currentApplication.getApplicationContext();\n\t\tvar XhsHttpInterceptor = Java.use('com.xingin.shield.http.XhsHttpInterceptor')\n\t\tvar cls = Java.use('m.x.y0.a.a')\n\t\tvar cls1 = Java.use('m.x.o1.d0.x$c')\n\t\tXhsHttpInterceptor.$new(\"main\",cls1.$new())\n\t})\n}\n```\n成功断下，如下图所示\n{% asset_img xhs_5.png %}\n\n简单说一下这个过程，在加解密过程中，加密用Tbox1-4，解密用Tbox5-8，前9轮用T，最后一轮用Sbox\n\n初始化\n{% asset_img xhs_6.png %}\n{% asset_img xhs_7.png %}\n解密函数\n{% asset_img xhs_8.png %}\n加密函数\n{% asset_img xhs_9.png %}\n\n至此initialize函数分析完成，边调试边还原代码，通过一些特征可以知道使用了AES算法，尝试标准AES算法进行解密失败，应是对算法进行了魔改\n\n解密后的结果如下\n```\n02 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n51 F9 44 08 66 D7 46 3C  F9 67 7D 54 A1 47 0D 8B\n66 A1 D1 3B 1E CD 91 38  0C 53 AC 80 66 BC BB 8E\n9D E2 0A B6 80 19 13 70  61 AD 31 86 03 67 7F 42\nBD FD 81 B7 E0 A7 49 4B  8E 0C 15 AE EE 1D D7 EA\n10 10 10 10 10 10 10 10  10 10 10 10 10 10 10 10\n```\n\n接下来看看intercept函数\n\n经过调试得知程序走这个分支\n{% asset_img xhs_10.png %}\n首先看105B0这个函数，该函数主要对请求数据进行MD5运算。\n{% asset_img xhs_11.png %}\n对AES解密的数据分别异或0x36和0x5C计算MD5。\n{% asset_img xhs_12.png %}\n{% asset_img xhs_13.png %}\nMD5 Init函数\n{% asset_img xhs_14.png %}\nMD5 Update函数\n{% asset_img xhs_15.png %}\nMD5 Trans函数\n{% asset_img xhs_16.png %}\n以上操作执行完以后，通过反射调用读取请求数据\n{% asset_img xhs_17.png %}\n读取成功后对请求数据进行MD5计算，这里使用的ctx为AES解密结果xor 0x36结果的MD5 ctx\n计算成功后对计算的结果再一次进行MD5，这里使用的ctx为AES解密结果xor 0x5C结果的MD5 ctx\n至此105B0函数执行完成。\n读取build，deviceid\n{% asset_img xhs_18.png %}\n进入sub_404E8函数，初始化一个结构\n{% asset_img xhs_19.png %}\n{% asset_img xhs_20.png %}\n```\n    内存结构如下所示:\n    //C0 0D 8F 97\n    //            app_id\n    //01 00 00 00 01 AF FA EC  02 00 00 00 07 00 00 00\n    //                         build       deviceId\n    //24 00 00 00 10 00 00 00  38 51 B0 95 20 5F 78 8A\n    //md5结果\n    //60 10 1E 83 29 00 00 00  00 00 00 00 00 00 00 00\n```\n初始化完成后继续对数据进行处理\n{% asset_img xhs_21.png %}\n```\n//  处理后结果\n//    00 00 00 01 EC FA AF 01  00 00 00 02 00 00 00 07\n//    00 00 00 24 00 00 00 10  36 38 37 30 32 31 33 37\n//    30 63 35 39 32 35 39 2D  37 65 39 31 2D 33 65 38\n//    62 2D 62 38 66 32 2D 33  35 38 35 35 61 38 35 36\n//    35 62 36 BF C9 92 0E BC  ED 07 2E C7 8D FE 2E DF\n//    E1 54 1C\n```\n对处理后的结果进行加密\n加密算法过程分三步进行\n初始化加密表\n{% asset_img xhs_22.png %}\n```\n表结构如下所示:\n7C 00 00 00\n2E 00 00 00 0E 00 00 00  3D 00 00 00 09 00 00 00\n32 00 00 00 E3 00 00 00  1C 00 00 00 87 00 00 00\nC9 00 00 00 B3 00 00 00  2D 00 00 00 B1 00 00 00\n2B 00 00 00 DD 00 00 00  20 00 00 00 0B 00 00 00\nC3 00 00 00 28 00 00 00  5C 00 00 00 0F 00 00 00\n7B 00 00 00 12 00 00 00  53 00 00 00 0C 00 00 00\n2F 00 00 00 92 00 00 00  23 00 00 00 30 00 00 00\nCE 00 00 00 50 00 00 00  D0 00 00 00 40 00 00 00\n1F 00 00 00 45 00 00 00  33 00 00 00 3B 00 00 00\n95 00 00 00 B2 00 00 00  15 00 00 00 BC 00 00 00\n34 00 00 00 89 00 00 00  E6 00 00 00 D5 00 00 00\n39 00 00 00 68 00 00 00  78 00 00 00 F1 00 00 00\n80 00 00 00 7F 00 00 00  C1 00 00 00 CA 00 00 00\n3E 00 00 00 71 00 00 00  52 00 00 00 7A 00 00 00\n5E 00 00 00 E7 00 00 00  A4 00 00 00 37 00 00 00\nA5 00 00 00 69 00 00 00  D1 00 00 00 4C 00 00 00\n73 00 00 00 B6 00 00 00  5B 00 00 00 FE 00 00 00\n16 00 00 00 CF 00 00 00  55 00 00 00 CB 00 00 00\nC0 00 00 00 F9 00 00 00  24 00 00 00 10 00 00 00\nA8 00 00 00 6B 00 00 00  E0 00 00 00 62 00 00 00\n8C 00 00 00 63 00 00 00  D9 00 00 00 BD 00 00 00\nDA 00 00 00 31 00 00 00  F3 00 00 00 96 00 00 00\nE4 00 00 00 75 00 00 00  5D 00 00 00 F7 00 00 00\n79 00 00 00 22 00 00 00  57 00 00 00 DE 00 00 00\nBF 00 00 00 91 00 00 00  86 00 00 00 EA 00 00 00\n85 00 00 00 97 00 00 00  4D 00 00 00 83 00 00 00\n00 00 00 00 A9 00 00 00  84 00 00 00 14 00 00 00\n27 00 00 00 1A 00 00 00  17 00 00 00 ED 00 00 00\nE1 00 00 00 1B 00 00 00  6F 00 00 00 41 00 00 00\n59 00 00 00 A2 00 00 00  99 00 00 00 FC 00 00 00\n4B 00 00 00 1E 00 00 00  A7 00 00 00 74 00 00 00\nAB 00 00 00 7D 00 00 00  88 00 00 00 5A 00 00 00\n51 00 00 00 E2 00 00 00  BE 00 00 00 A6 00 00 00\n77 00 00 00 67 00 00 00  58 00 00 00 11 00 00 00\n0D 00 00 00 A0 00 00 00  8F 00 00 00 08 00 00 00\n2A 00 00 00 72 00 00 00  D2 00 00 00 C2 00 00 00\n9B 00 00 00 36 00 00 00  D7 00 00 00 F2 00 00 00\n70 00 00 00 35 00 00 00  8E 00 00 00 D3 00 00 00\n03 00 00 00 B7 00 00 00  B9 00 00 00 C8 00 00 00\n2C 00 00 00 93 00 00 00  B0 00 00 00 EE 00 00 00\n8D 00 00 00 07 00 00 00  F8 00 00 00 47 00 00 00\n8B 00 00 00 E9 00 00 00  90 00 00 00 04 00 00 00\n46 00 00 00 94 00 00 00  D4 00 00 00 49 00 00 00\n4E 00 00 00 B5 00 00 00  D6 00 00 00 A1 00 00 00\nAC 00 00 00 4F 00 00 00  BB 00 00 00 DC 00 00 00\nFF 00 00 00 18 00 00 00  BA 00 00 00 AF 00 00 00\nC4 00 00 00 26 00 00 00  6E 00 00 00 9E 00 00 00\n6D 00 00 00 3A 00 00 00  5F 00 00 00 C7 00 00 00\n82 00 00 00 44 00 00 00  AE 00 00 00 CD 00 00 00\n8A 00 00 00 AD 00 00 00  3C 00 00 00 38 00 00 00\n01 00 00 00 A3 00 00 00  DF 00 00 00 C5 00 00 00\n05 00 00 00 02 00 00 00  F4 00 00 00 F0 00 00 00\n06 00 00 00 13 00 00 00  3F 00 00 00 EF 00 00 00\n29 00 00 00 64 00 00 00  FD 00 00 00 66 00 00 00\n25 00 00 00 60 00 00 00  EB 00 00 00 E8 00 00 00\n61 00 00 00 7E 00 00 00  FA 00 00 00 54 00 00 00\n9A 00 00 00 FB 00 00 00  D8 00 00 00 F5 00 00 00\nB4 00 00 00 48 00 00 00  76 00 00 00 43 00 00 00\n65 00 00 00 6A 00 00 00  EC 00 00 00 9C 00 00 00\n1D 00 00 00 F6 00 00 00  0A 00 00 00 E5 00 00 00\n9F 00 00 00 42 00 00 00  6C 00 00 00 C6 00 00 00\nB8 00 00 00 CC 00 00 00  9D 00 00 00 AA 00 00 00\nDB 00 00 00 98 00 00 00  21 00 00 00 81 00 00 00\n56 00 00 00 4A 00 00 00  19 00 00 00 \n```\n加密数据\n{% asset_img xhs_23.png %}\n加密完成后做最后一次处理\n{% asset_img xhs_24.png %}\n```\n处理后的结果:\n//    00 00 00 01\n//    00 00 00 01 00 00 00 53  00 00 00 53 35 16 11 ED\n//    31 1B 52 1B 0F DF DC FA  A0 8B 3A 52 86 99 3B 45\n//    6B E9 46 E3 70 06 7B E1  54 45 AE 45 C5 D7 B5 97\n//    B4 62 45 9D FF AA E9 5E  CF C3 7F D4 9F 7E 83 AA\n//    64 12 0C 4D 14 6D 8D 61  EA FC D9 2D 65 D4 E2 2A\n//    18 EE D1 1E 56 96 C7 53  F6 C5 66 89 C2 A3 A7 00\n//    68 8C CF B4 27 00 00 00  B0 EF CC B4 70 00 00 00\n```\n最后进行base64编码，拼接上XY即可得到shield的值\n{% asset_img xhs_25.png %}\n","tags":["reverse"],"categories":["reverse"]},{"title":"LLDB动态调试","url":"/2019/11/08/LLDB动态调试/","content":"\n### 0x1\n拷贝debugserver到本地计算机中，这里使用了iproxy进行了端口映射，所以直接从本地2222端口进行复制\n```\nscp -P 2222 root@127.0.0.1:/Developer/usr/bin/debugserver ./\n```\n\n### 0x2\n签名权限，新建entitlements.plist，写入如下内容\n```\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>com.apple.springboard.debugapplications</key>\n        <true/>\n        <key>get-task-allow</key>\n        <true/>\n        <key>task_for_pid-allow</key>\n        <true/>\n        <key>run-unsigned-code</key>\n        <true/>\n</dict>\n</plist>\n```\n\n使用codesign进行签名，并将签名后的程序复制会手机bin目录下\n```\ncodesign -s - --entitlements entitlements.plist -f debugserver\nscp -P 2222 ./debugserver root@127.0.0.1:/usr/bin/debugserver\n```\n\n### 0x3\n开始调试，首先进行端口转发\n```\niproxy 1234 1234\n```\n\n通过进程ID\n```\ndebugserver *:1234 -a 2333\n```\n\n通过进程名\n```\ndebugserver *:1234 -a fuck\n```\n\n直接启动进程\n```\ndebugserver -x backboard *:1234 excutable path\n```\n\n### 0x4\n本地连接debugserver\n```\nprocess connect connect://127.0.0.1:1234\n```\n成功后输入“c”恢复程序继续运行\n"},{"title":"Android壳简单实现","url":"/2018/12/30/Android壳简单实现/","content":"\n又一年要过完了，没有什么提高，总结一下学习过程的中的笔记。\n\n过时的技术，各位大佬请轻喷。\n\n## Dex加固\n\n加壳程序工作流程：加密源程序APK文件，把加密后数据写入壳APK的Dex文件尾部并添加数据长度，修改Dex文件头部的checksum，signature，file_size字段，使用源程序AndroidMainfest.xml替换壳程序的AndroidMainfest.xml文件内容。\n\n脱壳程序工作流程：读取Dex文件末尾数据以及长度信息，解密数据保存文件，动态加载源APK。\n\n加壳程序：\n\nDEX文件头部结构如下：\n<!-- ![](Android壳简单实现/1.png) -->\n{% asset_img 1.png %}\n\n\n修复CheckSum，CheckSum使用alder32算法校验除去magic，checksum以外的部分。\n\n```c\nint FixCheckSum(unsigned char *buffer, size_t nLen)\n{\n \n    long  uCheckSum = adler32(buffer + 12,nLen - 12);\n \n    printf(\"new CheckSum is %02x\\r\\n\",uCheckSum);\n \n    memcpy(buffer + 8,&uCheckSum,4);\n \n    return 0; \n}\n```\n\n修复Signature，Signature使用sha1计算除去 magic ,checksum 和 signature以外的部分。\n\n```java\n@Override\n \n    protected void attachBaseContext(Context base) {\n \n        super.attachBaseContext(base);\n \n        File odex = this.getDir(\"test_odex\", MODE_PRIVATE);\n \n        File libs = this.getDir(\"test_lib\", MODE_PRIVATE);\n \n        odexPath = odex.getAbsolutePath();\n \n        libPath = libs.getAbsolutePath();\n \n        apkPath = odexPath + \"/test.apk\";\n \n        Log.i(\"smallsun\", \"odexPath\" + odexPath + \"\\r\\n\");\n \n        Log.i(\"smallsun\", \"libPath\" + libPath + \"\\r\\n\");\n \n        Log.i(\"smallsun\", \"apkPath\" + apkPath + \"\\r\\n\");\n \n        File apkFile = new File(apkPath);\n \n        if (apkFile.exists()) {\n \n            Log.i(\"smallsun\", \"file is exists\");\n \n            return;\n \n        }\n \n        try {\n \n            //创建APK\n \n            apkFile.createNewFile();\n \n            byte[] dexData = readDexFromAPK();\n \n            Log.i(\"smallsun\", \"decryptDexFile\");\n \n            decryptDexFile(dexData);\n \n            //配置动态加载环境，获取主线程对象\n \n            Object currentActivityThread = RefInvoke.invokeStaticMethod(\"android.app.ActivityThread\",\"currentActivityThread\",new Class[]{},new Object[]{});\n \n            String packageName = this.getPackageName();\n \n            ArrayMap mPackage = (ArrayMap) RefInvoke.getFieldOjbect(\"android.app.ActivityThread\",currentActivityThread,\"mPackages\");\n \n            WeakReference wr = (WeakReference) mPackage.get(packageName);\n \n            //创建被加壳APK的DexClassLoader对象  加载apk内的类和本地代码（c/c++代码）\n \n            DexClassLoader dexClassLoader = new DexClassLoader(apkPath,odexPath,libPath, (ClassLoader) RefInvoke.getFieldOjbect(\"android.app.LoadedApk\", wr.get(), \"mClassLoader\"));\n \n            //把当前进程的DexClassLoader 设置成了被加壳apk的DexClassLoader\n \n            RefInvoke.setFieldOjbect(\"android.app.LoadedApk\",\"mClassLoader\",wr.get(),dexClassLoader);\n \n            Log.i(\"smallsun\",\"ClassLoader:\" + dexClassLoader);\n \n            try {\n \n                Object object = dexClassLoader.loadClass(\"com.apktest.MainActivity\");\n \n                Log.i(\"smallsun\", \"object : \" + object);\n \n            }catch (Exception e) {\n \n                Log.i(\"smallsun\", \"activity:\" + Log.getStackTraceString(e));\n \n            }\n \n        } catch (IOException e) {\n \n            throw new RuntimeException(e);\n \n        }\n \n    }\n```\n\n到这里为止已经实现了一个简单的壳了，但是一些APP会有Application类，这时还需要替换源程序的Application，代码如下。\n\n```java\nsuper.onCreate();\n \n        Log.i(\"smallsun\", \"onCreate\");\n \n        String appClassName = null;\n \n        try {\n \n            ApplicationInfo ai = this.getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);\n \n            Bundle bundle = ai.metaData;\n \n            if (bundle != null && bundle.containsKey(\"APPLICATION_CLASS_NAME\")) {\n \n                appClassName = bundle.getString(\"APPLICATION_CLASS_NAME\");\n \n            } else {\n \n                return;\n \n            }\n \n        } catch (PackageManager.NameNotFoundException e) {\n \n            e.printStackTrace();\n \n        }\n \n//有值的话调用该Applicaiton\n \n        Object currentActivityThread = RefInvoke.invokeStaticMethod(\"android.app.ActivityThread\", \"currentActivityThread\", new Class[]{}, new Object[]{});\n \n        Object mBoundApplication = RefInvoke.getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mBoundApplication\");\n \n        Object loadedApkInfo = RefInvoke.getFieldOjbect(\"android.app.ActivityThread$AppBindData\", mBoundApplication, \"info\");\n \n        RefInvoke.setFieldOjbect(\"android.app.LoadedApk\", \"mApplication\", loadedApkInfo, null);\n \n        Object oldApplication = RefInvoke.getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mInitialApplication\");\n \n        ArrayList<Application> mAllApplications = (ArrayList<Application>) RefInvoke.getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mAllApplications\");\n \n        mAllApplications.remove(oldApplication);\n \n        ApplicationInfo appinfo_In_LoadedApk = (ApplicationInfo) RefInvoke.getFieldOjbect(\"android.app.LoadedApk\", loadedApkInfo, \"mApplicationInfo\");\n \n        ApplicationInfo appinfo_In_AppBindData = (ApplicationInfo) RefInvoke.getFieldOjbect(\"android.app.ActivityThread$AppBindData\", mBoundApplication, \"appInfo\");\n \n        appinfo_In_LoadedApk.className = appClassName;\n \n        appinfo_In_AppBindData.className = appClassName;\n \n        Application app = (Application) RefInvoke.invokeMethod(\"android.app.LoadedApk\", \"makeApplication\", loadedApkInfo, new Class[]{boolean.class, Instrumentation.class}, new Object[]{false, null});\n \n        RefInvoke.setFieldOjbect(\"android.app.ActivityThread\", \"mInitialApplication\", currentActivityThread, app);\n \n        ArrayMap mProviderMap = (ArrayMap) RefInvoke.getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mProviderMap\");\n \n        Iterator it = mProviderMap.values().iterator();\n \n        while (it.hasNext()) {\n \n            Object providerClientRecord = it.next();\n \n            Object localProvider = RefInvoke.getFieldOjbect(\"android.app.ActivityThread$ProviderClientRecord\", providerClientRecord, \"mLocalProvider\");\n \n            RefInvoke.setFieldOjbect(\"android.content.ContentProvider\", \"mContext\", localProvider, app);\n \n        }\n \n        app.onCreate();\n \n}\n```\n\n至此实现了一个壳的雏形，测试一下效果。\n\n加密源APK生成新dex文件\n\n<!-- ![](Android壳简单实现/2.png) -->\n{% asset_img 2.png %}\n\n把新dex文件放入壳Apk中，重新签名，安装程序,启动程序，通过log可以看见执行了源APK中的代码。\n<!-- ![](Android壳简单实现/3.png) -->\n{% asset_img 3.png %}\n\n再说一下实现过程中发现的一些问题，在java层进行解密及动态加载过程很容易被反编译，反编译后的伪代码与源码几乎没差，可以清楚的看出壳的运行逻辑，同时还会释放出源apk文件存放在本地。这时需要把关键代码移植到Native层，同时在内存中加载文件，这里就不多说了可以看代码，为了偷懒部分代码还是在java实现，完全可以把attachBaseContext和onCreate用native实现。\n\n## So加固\n\n一）通过加密节的方式加密\n\n解密程序流程：通过__attribute__((section(\".mytext\")))属性将要加密的函数定义在.mytext节中，实现解密函数，添加__attribute__((constructor))属性，将代码定义在.init_array段。\n\n　解密函数的实现很简单，这里首先在getLibAddr函数中通过/proc/<pid>/maps文件获得加载的so文件路径和基址，通过ehdr->e_entry这个变量获取到被加密节的大小，ehdr->e_shoff获得加密节的地址偏移解密数据。\n\n代码如下：\n\n```cpp\nextern \"C\" JNIEXPORT\n \n//替换成自定义section的名字\n \njint JNICALL Java_home_com_sotest_MainActivity_Add(JNIEnv *env, jobject obj)  __attribute__((section(\".mytext\")));\n \njint JNICALL Java_home_com_sotest_MainActivity_Add(JNIEnv *env, jobject obj)\n{\n \n    printf(\"Call Add Func!\\r\\n\");\n \n    return (jint)(1 + 1);\n \n}\n \n    unsigned int GetLibAddr()\n \n{\n \n    char *szName = \"libnative-lib.so\";\n \n    int nPid = getpid();\n \n    unsigned int nBase = 0;\n \n    char buffer[1024] = {0};\n \n    sprintf(buffer,\"/proc/%d/maps\",nPid);\n \n    FILE *fp = fopen(buffer,\"r\");\n \n    if (fp != nullptr)\n \n    {\n \n        while(fgets(buffer,sizeof(buffer),fp))\n \n        {\n \n            if(strstr(buffer,szName))\n \n            {\n \n                //分割字符串 返回-之前内容\n \n                char *temp;\n \n                temp = strtok(buffer,\"-\");\n \n                nBase = strtoul(temp,nullptr,16);\n \n                LOGD(\"BASE IS 0x%x\\r\\n\",nBase);\n \n                break;\n \n            }\n \n        }\n \n    }\n \n    fclose(fp);\n \n    return nBase;\n \n}\n```\n\n```cpp\nvoid Init() __attribute__((constructor)); //使用”attribute((constructor))”将函数放到”.init_array”段\n \nvoid Init()\n \n{\n \n     LOGD(\"Call Init\");\n \n     unsigned int nBase = GetLibAddr();\n \n     Elf32_Ehdr *pEhdr = (Elf32_Ehdr *)nBase;\n \n     //获取加密节地址\n \n     unsigned int mytextBase = pEhdr->e_shoff + nBase;\n \n     unsigned int nBlock = (pEhdr->e_entry) >> 16;//加密节的大小\n \n     unsigned int nSize = (pEhdr->e_entry) & 0xffff;//加密节的大小\n \n     LOGD(\"nBlock = %d,nSize = %d\", nBlock,nSize);\n \n     LOGD(\"mytextBase = 0x%x\", mytextBase);\n \n     //修改内存属性\n \n     if(mprotect((void*)(mytextBase / PAGE_SIZE * PAGE_SIZE),4096 * nSize,PROT_READ | PROT_EXEC | PROT_WRITE) != 0)\n \n     {\n \n        LOGD(\"mem privilege change failed\");\n \n     }\n \n     //解密\n \n     for(int i = 0;i < nBlock; i++)\n \n     {\n \n        unsigned char *addr = (unsigned char*)(mytextBase + i);\n \n        *addr = ~(*addr);\n \n     }\n \n      if(mprotect((void *) (mytextBase / PAGE_SIZE * PAGE_SIZE), 4096 * nSize, PROT_READ | PROT_EXEC) != 0)\n \n      {\n \n         LOGD(\"mem privilege change failed\");\n \n      }\n \n      LOGD(\"Decrypt success!!!\");\n \n}\n```\n\n加密程序流程：解析elf结构，从文件头读取section偏移shoff，shnum和shstrtab，读取shstrtab中的字符串，从shoff读取section header，通过pShdr->sh_name读取节表名比较是否自定义节表名，通过pShdr->sh_offset pShdr->sh_size读取节表大小以及内容进行加密，修改section字段中的e_shoff为pShdr->sh_addr，修改e_entry为pShdr->sh_size，写入文件。\n\n关于修改文件头的说明：作为动态链接库，e_entry入口地址是无意义的，因为程序被加载时，设定的跳转地址是动态连接器的地址，这个字段是可以被作为数据填充的。so装载时，与链接视图没有关系，即e_shoff、e_shentsize、e_shnum和e_shstrndx这些字段是可以任意修改。\n代码如下：\n\n```c\nint FormatElf(unsigned char *buffer)\n \n{\n \n    //自定义节名\n \n    char *szSection = \".mytext\";\n \n    //ELF头地址\n \n    Elf32_Ehdr *pEhdr = (Elf32_Ehdr*)buffer;\n \n    if (!((pEhdr->e_ident[0] == 0x7F) &&\n \n          (pEhdr->e_ident[1] == 'E') &&\n \n          (pEhdr->e_ident[2] == 'L') &&\n \n          (pEhdr->e_ident[3] == 'F')))\n \n    {\n \n        printf(\"无效的文件\\r\\n\");\n \n        return 0;\n \n    }\n \n    //定位到节表\n \n    Elf32_Shdr *pShdr = (Elf32_Shdr*)(buffer + pEhdr->e_shoff);\n \n    //定位字符串表\n \n    char *str = nullptr;\n \n    Elf32_Shdr *pShdrstr = (Elf32_Shdr *)(buffer + pEhdr->e_shoff + sizeof(Elf32_Shdr) * pEhdr->e_shstrndx);\n \n    str = (char*)(pShdrstr->sh_offset + buffer);\n \n    int nOffset = 0;\n \n    int nSize = 0;\n \n    for (int i = 0; i < pEhdr->e_shnum; i++)\n \n    {\n \n        if (strcmp(str + pShdr->sh_name,szSection) == 0)\n \n        {\n \n            //获取偏移和大小\n \n            nOffset = pShdr->sh_offset;\n \n            nSize   = pShdr->sh_size;\n \n            printf(\"find section %s offset is 0x%x size is 0x%x\\n\",szSection,nOffset,nSize);\n \n            break;\n \n        }\n \n        pShdr++;\n \n    }\n \n    unsigned char *sectionBuf = (unsigned char *)(buffer + nOffset);\n \n    //计算section占用内存几页，一个页大小4096\n \n    int nPage = nSize / 4096 + (nSize % 4096 == 0 ? 0 :1);\n \n    printf(\"nOffset = 0x%x, nSize = 0x%x\\n\", nOffset, nSize);\n \n    printf(\"nPage = %d\\n\",nPage);\n \n    pEhdr->e_entry = (nSize << 16) + nPage;\n \n    pEhdr->e_shoff = nOffset;\n \n    //加密\n \n    printf(\"sectionBuf is %x\",sectionBuf);\n \n    for (int j = 0; j < nSize; j++)\n \n    {\n \n        sectionBuf[j] = ~sectionBuf[j];\n \n    }\n \n    return 1;\n \n}\n```\n\n加密后Add函数如下\n<!-- ![](Android壳简单实现/4.png) -->\n{% asset_img 4.png %}\n\n二）加密SO中指定函数\n加密程序流程：解析elf文件，读取文件头，获取e_phoff、e_phentsize和e_phnum信息，通过Elf32_Phdr中的p_type字段，找到DYNAMIC，遍历.dynamic，找到.dynsym、.dynstr、.hash section文件中的偏移和.dynstr的大小，根据函数名称，计算hash，根据hash值，找到下标hash % nbuckets的bucket；根据bucket中的值，读取.dynsym中的对应索引的Elf32_Sym符号；从符号的st_name所以找到在.dynstr中对应的字符串与函数名进行比较。若不等，则根据chain[hash % nbuckets]找下一个Elf32_Sym符号，直到找到或者chain终止为止，找到函数对应的Elf32_Sym符号后，即可根据st_value和st_size字段找到函数的位置和大小，加密数据写入文件。\n\n代码如下：\n\n```c\nstatic unsigned elfhash(const char *_name)\n{\n \n    const unsigned char *name = (const unsigned char *) _name;\n \n    unsigned h = 0, g;\n \n    while(*name) {\n \n        h = (h << 4) + *name++;\n \n        g = h & 0xf0000000;\n \n        h ^= g;\n \n        h ^= g >> 24;\n \n    }\n \n    return h; \n}\n```\n\n ```c\nvoid GetTargetFuncInfo(unsigned char* buffer,char *funcName,funcInfo *info) \n{\n \n    Elf32_Ehdr *pEhdr = (Elf32_Ehdr *) buffer;\n \n    Elf32_Phdr *pHdr = (Elf32_Phdr *) (buffer + pEhdr->e_phoff);\n \n    Elf32_Word DynSize = 0;\n \n    Elf32_Word DynStrsz = 0;\n \n    Elf32_Off DynOffset = 0;\n \n    Elf32_Addr DynSymtab, DynStrtab, DynHash;\n \n    for (int i = 0; i < pEhdr->e_phnum; i++)\n \n    {\n \n        if (pHdr->p_type == PT_DYNAMIC)\n \n        {\n \n            DynSize = pHdr->p_filesz;\n \n            DynOffset = pHdr->p_offset;\n \n            printf(\"Find Section %s size = %d offser = %02x\\n\", \"PT_DYNAMIC\", DynSize, DynOffset);\n \n        }\n \n        pHdr++;\n \n    }\n \n    Elf32_Dyn *pDyn = (Elf32_Dyn *) (buffer + DynOffset);\n \n    for (int j = 0; j < DynSize / sizeof(Elf32_Dyn); j++)\n \n    {\n \n        //符号表位置\n \n        if (pDyn->d_tag == DT_SYMTAB)\n \n        {\n \n            DynSymtab = pDyn->d_un.d_ptr;\n \n            printf(\"Find .dynsym, addr = 0x%x, val = 0x%x\\n\", DynSymtab, pDyn->d_un.d_val);\n \n        }\n \n        //hash位置\n \n        if (pDyn->d_tag == DT_HASH)\n \n        {\n \n            DynHash = pDyn->d_un.d_ptr;\n \n            printf(\"Find .hash, addr = 0x%x\\n\", DynHash);\n \n        }\n \n        //字符串位置\n \n        if (pDyn->d_tag == DT_STRTAB)\n \n        {\n \n            DynStrtab = pDyn->d_un.d_ptr;\n \n            printf(\"Find .dynstr, addr = 0x%x\\n\", DynStrtab);\n \n        }\n \n        //字符串大小\n \n        if (pDyn->d_tag == DT_STRSZ)\n \n        {\n \n            DynStrsz = pDyn->d_un.d_val;\n \n            printf(\"Find .dynstr size, size = 0x%x\\n\", DynStrsz);\n \n        }\n \n        pDyn++;\n \n    }\n \n    //定位字符串表\n \n    char *dynStr = (char *) malloc(DynStrsz);\n \n    memcpy(dynStr, buffer + DynStrtab, DynStrsz);\n \n    /*     nbucket\n \n     *-----------------\n \n     *       nchain\n \n     *------------------\n \n     *      bucket[0]\n \n     *       ...\n \n     *   bucket[nbucket-1]\n \n     * ------------------\n \n     *     chain[0]\n \n     *       ...\n \n     *   chain[nchain-1]\n \n     */\n \n    //计算函数名称经过hash运行后的值\n \n    unsigned funHash = elfhash(funcName);\n \n    printf(\"Function %s hashVal = 0x%x\\n\", funcName, funHash);\n \n    //获取nbucket的值\n \n     int nNbucket = *(int *) (buffer + DynHash);\n \n    printf(\"nbucket = %d\\n\", nNbucket);\n \n    //获取nchain\n \n    int nNchain = *(int *) (buffer + DynHash + 4);\n \n    printf(\"nchain = %d\\n\", nNchain);\n \n    funHash = funHash % nNbucket;        //bucket[X%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表\n \n    printf(\"funHash mod nbucket = %d \\n\", funHash);\n \n    int nFunIndex = *(int *) (buffer + DynHash + 8 + funHash * 4);//y = bucket[X%nbucket]返回的索引y\n \n    printf(\"funcIndex:%d\\n\", nFunIndex);\n \n    Elf32_Sym *pSym = (Elf32_Sym *) (buffer + DynSymtab + nFunIndex * sizeof(Elf32_Sym));//该索引对应的符号表\n \n    //如果索引y对应的符号表不是所需要的,那么chain[y]则给出了具有相同哈希值的下一个符号表项\n \n    if (strcmp(dynStr + pSym->st_name, funcName) != 0)\n \n    {\n \n        while (1)\n \n        {\n \n            printf(\"hash:%x,nbucket:%d,funIndex:%d\\n\", DynHash, nNbucket, nFunIndex);\n \n            nFunIndex = *(int *) (buffer + DynHash + 4 * (2 + nNbucket + nFunIndex));  //搜索chain链\n \n            printf(\"funcIndex:%d\\n\", nFunIndex);\n \n            if (nFunIndex == 0) {\n \n                puts(\"Cannot find funtion!\\n\");\n \n                return;\n \n            }\n \n            pSym = (Elf32_Sym *) (buffer + DynSymtab + nFunIndex * sizeof(Elf32_Sym)); //chain[]中对应的符号表\n \n            if (strcmp(dynStr + pSym->st_name, funcName) == 0)\n \n            {\n \n                break;\n \n            }\n \n        }\n \n    }\n \n    printf(\"Find: %s, offset = 0x%x, size = 0x%x\\n\", funcName, pSym->st_value, pSym->st_size);\n \n    info->st_value = pSym->st_value;\n \n    info->st_size = pSym->st_size;\n \n    free(dynStr);\n \n    return;\n \n}\n ```\n\n解密程序流程：解密流程为加密逆过程，区别是找到PT_DYNAMIC后需取p_vaddr和p_filesz字段而不是 p_offset字段。\n\n代码如下：\n\n```c\nvoid GetTargetFuncInfo(unsigned int nBase,const char *funcName,funcInfo *info)\n{\n \n    Elf32_Ehdr *pEhdr = (Elf32_Ehdr *) nBase;\n \n    Elf32_Phdr *pHdr = (Elf32_Phdr *) (nBase + pEhdr->e_phoff);\n \n    LOGD(\"phdr =  0x%p, size = 0x%x\\n\", pEhdr, pEhdr->e_phnum);\n \n    for (int i = 0; i < pEhdr->e_phnum; ++i)\n \n    {\n \n        LOGD(\"phdr =  0x%p\\n\", pHdr);\n \n       //获得动态链接节\n \n        if(pHdr->p_type ==  PT_DYNAMIC)\n \n        {\n \n            LOGD(\"Find .dynamic segment\");\n \n            break;\n \n        }\n \n       pHdr ++;\n \n    }\n \n    Elf32_Off dyn_vaddr = pHdr->p_vaddr + nBase;\n \n    Elf32_Word dyn_size = pHdr->p_filesz;\n \n    Elf32_Dyn *dyn;\n \n    Elf32_Addr dyn_symtab, dyn_strtab, dyn_hash;\n \n    Elf32_Word dyn_strsz;\n \n    for (int i = 0; i < dyn_size / sizeof(Elf32_Dyn); i++)\n \n    {\n \n        dyn = (Elf32_Dyn *)(dyn_vaddr + i * sizeof(Elf32_Dyn));\n \n        //符号表位置\n \n        if(dyn->d_tag == DT_SYMTAB)\n \n        {\n \n            dyn_symtab = (dyn->d_un).d_ptr;\n \n            LOGD(\"Find .dynsym section, addr = 0x%x\\n\", dyn_symtab);\n \n        }\n \n        //获得hash段\n \n        if(dyn->d_tag == DT_HASH)\n \n        {\n \n            dyn_hash = (dyn->d_un).d_ptr;\n \n            LOGD(\"Find .hash section, addr = 0x%x\\n\", dyn_hash);\n \n        }\n \n        //保存函数字符串的位置\n \n        if(dyn->d_tag == DT_STRTAB)\n \n        {\n \n            dyn_strtab = (dyn->d_un).d_ptr;\n \n            LOGD(\"Find .dynstr section, addr = 0x%x\\n\", dyn_strtab);\n \n        }\n \n        //字符串长度\n \n        if(dyn->d_tag == DT_STRSZ)\n \n        {\n \n            dyn_strsz = (dyn->d_un).d_val;\n \n            LOGD(\"Find strsz size = 0x%x\\n\", dyn_strsz);\n \n        }\n \n    }\n \n    dyn_symtab += nBase;\n \n    dyn_hash += nBase;\n \n    dyn_strtab += nBase;\n \n    dyn_strsz += nBase;\n \n /*     nbucket\n \n *-----------------\n \n *     nchain\n \n *------------------\n \n *    bucket[0]\n \n *       ...\n \n *   bucket[nbucket-1]\n \n * ------------------\n \n *     chain[0]\n \n *       ...\n \n *   chain[nchain-1]\n \n */\n \n    unsigned funHash =  elfhash(funcName);//获得函数名称经过hash运行后的值\n \n    Elf32_Sym *funSym = (Elf32_Sym *) dyn_symtab;\n \n    char *dynstr = (char*) dyn_strtab;\n \n    unsigned nbucket = *((int *) dyn_hash);//获得nbucket的值\n \n    int *bucket = (int *)(dyn_hash + 8);//bucket链\n \n    unsigned int *chain = (unsigned int *)(dyn_hash + 4 * (2 + nbucket));//越过bucket链，到达chain链\n \n    LOGD(\"hash = 0x%x, nbucket = 0x%x\\n\", funHash, nbucket);\n \n    //bucket[X%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表\n \n    int mod = (funHash % nbucket);\n \n    LOGD(\"mod = %d\\n\", mod);\n \n    LOGD(\"i = 0x%d\\n\", bucket[mod]);\n \n    //i = mod = bucket[funHash%nbucket]，通过遍历i = chain[i]表，找到funSym对应的符号表\n \n    int i;\n \n    for(i = bucket[funHash % nbucket]; i != 0; i = chain[i])\n \n    {\n \n        if(strcmp(dynstr + (funSym + i)->st_name, funcName) == 0)\n \n        {\n \n            LOGD(\"Find %s\\n\", funcName);\n \n            break;\n \n        }\n \n    }\n \n    info->st_value = (funSym + i)->st_value;//函数对应符号表中保存函数的地址\n \n    info->st_size = (funSym + i)->st_size;//函数符号表中保存函数的大小\n \n    LOGD(\"st_value = %d,st_size = %d\",info->st_value,info->st_size);\n \n}\n```\n\n```cpp\nvoid Init() __attribute__((constructor)); //使用”attribute((constructor))”将函数放到”.init_array”段\n \nvoid Init()\n{\n \n     LOGD(\"Call Init\");\n \n     unsigned int nBase = GetLibAddr();\n \n     Elf32_Ehdr *pEhdr = (Elf32_Ehdr *)nBase;\n \n     funcInfo info;\n \n     const char funcName[] = \"Java_home_com_sotest_MainActivity_Add\";\n \n     GetTargetFuncInfo(nBase,funcName,&info);\n \n     unsigned int nPage = info.st_size / PAGE_SIZE + ((info.st_size % PAGE_SIZE == 0) ? 0 : 1);\n \n     LOGD(\"nPage =  %02x\", nPage);\n \n     LOGD(\"nPage =  %02x\", PAGE_SIZE);\n \n     if(mprotect((void *) ((nBase + info.st_value) / PAGE_SIZE * PAGE_SIZE), 4096 * nPage, PROT_READ | PROT_EXEC | PROT_WRITE) != 0)\n \n     {\n \n        LOGD(\"mem privilege change failed\");\n \n     }\n \n      for(int i = 0;i < info.st_size - 1; i++)\n \n      {\n \n        char *addr = (char*)(nBase + info.st_value - 1 + i);\n \n        *addr = ~(*addr);\n \n      }\n \n      if(mprotect((void *) ((nBase + info.st_value) / PAGE_SIZE * PAGE_SIZE), 4096 * nPage, PROT_READ | PROT_EXEC) != 0)\n \n      {\n \n        LOGD(\"mem privilege change failed\");\n \n      }\n \n}\n```\n\n参考各位大佬帖子地址\n\nhttps://bbs.pediy.com/thread-191649.htm\n\nhttps://bbs.pediy.com/thread-191649.htm\n\nhttps://bbs.pediy.com/thread-216119.htm\n\nhttps://bbs.pediy.com/thread-225303.htm\n\ndex和so动态加载部分可以看看大佬写的文章，这篇文章属于拿来主义吧，参考了许多大佬写的东西，但实践过程中也学到了不少姿势，再次熟悉了dex和elf文件格式等等。","tags":["reverse"],"categories":["reverse"]},{"title":"反调试及反反调试","url":"/2018/05/17/反调试及反反调试/","content":"\n\n1. 调试端口检测（IDA 23946 读取/proc/net/tcp |grep :5D8A）\n\n2. 进程名（ps 遍历进程android_server gdbserver gdb等）\n\n3. 安卓自带的调试检测函数android.os.Debug.isDebuggerConnected(); dalvik模式下，调用libdvm.so中的dvmDbglsDebuggerConnected()函数，dlopen(/system/lib/libdvm.so)，dlsym(dvmDbglsDebuggerConnected);art模式下，结果存放在libart.so中的全局变量gDebuggerActive中，内存中搜索该模块，寻找该符号\n\n4. ptrace检测，每个进程同时刻只能被一个进程ptrace，再次p自己会失败，主动ptrace自己，根据返回值判断是否被调试（-1），或者多进程ptrace\n\n5. 函数hash值检测，so文件被下断点则指令发生改变，断点地址被改为bkpt，故可以根据hash值来进行校验\n\n6. 读取关键文件.读取进程的status和stat来检测tracepid。\n  1)/proc/pid/status;/proc/pid/task/pid/status，如果为调试状态，linux内核会在status文件的tracerpid字段写入调试进程的pid在该文件的state字段写入t。\n\t2)/proc/pid/stat;/proc/pid/task/pid/stat，如果为调试状态，文件的第二个字段为t。\n\t3)/proc/pid/wchan /proc/pid/task/pid/wchan 进程被调试，写入ptrace_stop \n  修改fs/proc/array.c\n\n7. 双进程ptrace反调试，修改/bionic/libc/bionic/fork.c，或者将子线程挂起","tags":["reverse"],"categories":["reverse"]},{"title":"DexClassLoader流程分析","url":"/2018/03/12/DexClassLoader流程分析/","content":"\nAndroid4.4 DexClassLoader流程分析\n\n```java\n36  public class DexClassLoader extends BaseDexClassLoader {\n37    /**\n38     * Creates a {@code DexClassLoader} that finds interpreted and native\n39     * code.  Interpreted classes are found in a set of DEX files contained\n40     * in Jar or APK files.\n41     *\n42     * <p>The path lists are separated using the character specified by the\n43     * {@code path.separator} system property, which defaults to {@code :}.\n44     *\n45     * @param dexPath the list of jar/apk files containing classes and\n46     *     resources, delimited by {@code File.pathSeparator}, which\n47     *     defaults to {@code \":\"} on Android\n48     * @param optimizedDirectory directory where optimized dex files\n49     *     should be written; must not be {@code null}\n50     * @param libraryPath the list of directories containing native\n51     *     libraries, delimited by {@code File.pathSeparator}; may be\n52     *     {@code null}\n53     * @param parent the parent class loader\n54     */\n55    public DexClassLoader(String dexPath, String optimizedDirectory,\n56            String libraryPath, ClassLoader parent) {\n57        super(dexPath, new File(optimizedDirectory), libraryPath, parent);\n58    }\n```\n\n```java\n45    public BaseDexClassLoader(String dexPath, File optimizedDirectory,\n46            String libraryPath, ClassLoader parent) {\n47        super(parent);\n48        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);\n49    }\n```\n\n```java\n72    /**\n73     * Constructs an instance.\n74     *\n75     * @param definingContext the context in which any as-yet unresolved\n76     * classes should be defined\n77     * @param dexPath list of dex/resource path elements, separated by\n78     * {@code File.pathSeparator}\n79     * @param libraryPath list of native library directory path elements,\n80     * separated by {@code File.pathSeparator}\n81     * @param optimizedDirectory directory where optimized {@code .dex} files\n82     * should be found and written to, or {@code null} to use the default\n83     * system directory for same\n84     */\n85    public DexPathList(ClassLoader definingContext, String dexPath,\n86            String libraryPath, File optimizedDirectory) {\n87        if (definingContext == null) {\n88            throw new NullPointerException(\"definingContext == null\");\n89        }\n90\n91        if (dexPath == null) {\n92            throw new NullPointerException(\"dexPath == null\");\n93        }\n94\n95        if (optimizedDirectory != null) {\n96            if (!optimizedDirectory.exists())  {\n97                throw new IllegalArgumentException(\n98                        \"optimizedDirectory doesn't exist: \"\n99                        + optimizedDirectory);\n100            }\n101\n102            if (!(optimizedDirectory.canRead()\n103                            && optimizedDirectory.canWrite())) {\n104                throw new IllegalArgumentException(\n105                        \"optimizedDirectory not readable/writable: \"\n106                        + optimizedDirectory);\n107            }\n108        }\n109\n110        this.definingContext = definingContext;\n111        ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();\n112        this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,\n113                                           suppressedExceptions);\n114        if (suppressedExceptions.size() > 0) {\n115            this.dexElementsSuppressedExceptions =\n116                suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);\n117        } else {\n118            dexElementsSuppressedExceptions = null;\n119        }\n120        this.nativeLibraryDirectories = splitLibraryPath(libraryPath);\n121    }\n```\n\n```java\n219                // Raw dex file (not inside a zip/jar).\n220                try {\n221                    dex = loadDexFile(file, optimizedDirectory);\n222                } catch (IOException ex) {\n223                    System.logE(\"Unable to load dex file: \" + file, ex);\n224                }\n```\n\n```java\n256    /**\n257     * Constructs a {@code DexFile} instance, as appropriate depending\n258     * on whether {@code optimizedDirectory} is {@code null}.\n259     */\n260    private static DexFile loadDexFile(File file, File optimizedDirectory)\n261            throws IOException {\n262        if (optimizedDirectory == null) {\n263            return new DexFile(file);\n264        } else {\n265            String optimizedPath = optimizedPathFor(file, optimizedDirectory);\n266            return DexFile.loadDex(file.getPath(), optimizedPath, 0);\n267        }\n268    }\n```\n\n```java\n117    /**\n118     * Open a DEX file, specifying the file in which the optimized DEX\n119     * data should be written.  If the optimized form exists and appears\n120     * to be current, it will be used; if not, the VM will attempt to\n121     * regenerate it.\n122     *\n123     * This is intended for use by applications that wish to download\n124     * and execute DEX files outside the usual application installation\n125     * mechanism.  This function should not be called directly by an\n126     * application; instead, use a class loader such as\n127     * dalvik.system.DexClassLoader.\n128     *\n129     * @param sourcePathName\n130     *  Jar or APK file with \"classes.dex\".  (May expand this to include\n131     *  \"raw DEX\" in the future.)\n132     * @param outputPathName\n133     *  File that will hold the optimized form of the DEX data.\n134     * @param flags\n135     *  Enable optional features.  (Currently none defined.)\n136     * @return\n137     *  A new or previously-opened DexFile.\n138     * @throws IOException\n139     *  If unable to open the source or output file.\n140     */\n141    static public DexFile loadDex(String sourcePathName, String outputPathName,\n142        int flags) throws IOException {\n143\n144        /*\n145         * TODO: we may want to cache previously-opened DexFile objects.\n146         * The cache would be synchronized with close().  This would help\n147         * us avoid mapping the same DEX more than once when an app\n148         * decided to open it multiple times.  In practice this may not\n149         * be a real issue.\n150         */\n151        return new DexFile(sourcePathName, outputPathName, flags);\n152    }\n```\n\n```java\n86    /**\n87     * Opens a DEX file from a given filename, using a specified file\n88     * to hold the optimized data.\n89     *\n90     * @param sourceName\n91     *  Jar or APK file with \"classes.dex\".\n92     * @param outputName\n93     *  File that will hold the optimized form of the DEX data.\n94     * @param flags\n95     *  Enable optional features.\n96     */\n97    private DexFile(String sourceName, String outputName, int flags) throws IOException {\n98        if (outputName != null) {\n99            try {\n100                String parent = new File(outputName).getParent();\n101                if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) {\n102                    throw new IllegalArgumentException(\"Optimized data directory \" + parent\n103                            + \" is not owned by the current user. Shared storage cannot protect\"\n104                            + \" your application from code injection attacks.\");\n105                }\n106            } catch (ErrnoException ignored) {\n107                // assume we'll fail with a more contextual error later\n108            }\n109        }\n110\n111        mCookie = openDexFile(sourceName, outputName, flags);\n112        mFileName = sourceName;\n113        guard.open(\"close\");\n114        //System.out.println(\"DEX FILE cookie is \" + mCookie);\n115    }\n```\n\n```java\n291     * Open a DEX file.  The value returned is a magic VM cookie.  On\n292     * failure, an IOException is thrown.\n293     */\n294    private static int openDexFile(String sourceName, String outputName,\n295        int flags) throws IOException {\n296        return openDexFileNative(new File(sourceName).getCanonicalPath(),\n297                                 (outputName == null) ? null : new File(outputName).getCanonicalPath(),\n298                                 flags);\n299    }\n```\n\n```cpp\n87 static jint DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) {\n88  ScopedUtfChars sourceName(env, javaSourceName);\n89  if (sourceName.c_str() == NULL) {\n90    return 0;\n91  }\n92  std::string dex_location(sourceName.c_str());\n93  NullableScopedUtfChars outputName(env, javaOutputName);\n94  if (env->ExceptionCheck()) {\n95    return 0;\n96  }\n97  ScopedObjectAccess soa(env);\n98\n99  uint32_t dex_location_checksum;\n100  if (!DexFile::GetChecksum(dex_location, &dex_location_checksum)) {\n101    LOG(WARNING) << \"Failed to compute checksum: \" << dex_location;\n102    ThrowLocation throw_location = soa.Self()->GetCurrentLocationForThrow();\n103    soa.Self()->ThrowNewExceptionF(throw_location, \"Ljava/io/IOException;\",\n104                                   \"Unable to get checksum of dex file: %s\", dex_location.c_str());\n105    return 0;\n106  }\n107\n108  ClassLinker* linker = Runtime::Current()->GetClassLinker();\n109  const DexFile* dex_file;\n110  if (outputName.c_str() == NULL) {\n111    dex_file = linker->FindDexFileInOatFileFromDexLocation(dex_location, dex_location_checksum);\n112  } else {\n113    std::string oat_location(outputName.c_str());\n114    dex_file = linker->FindOrCreateOatFileForDexLocation(dex_location, dex_location_checksum, oat_location);\n115  }\n116  if (dex_file == NULL) {\n117    LOG(WARNING) << \"Failed to open dex file: \" << dex_location;\n118    ThrowLocation throw_location = soa.Self()->GetCurrentLocationForThrow();\n119    soa.Self()->ThrowNewExceptionF(throw_location, \"Ljava/io/IOException;\",\n120                                   \"Unable to open dex file: %s\", dex_location.c_str());\n121    return 0;\n122  }\n123  return static_cast<jint>(reinterpret_cast<uintptr_t>(dex_file));\n124 }\n```\n\n```cpp\nconst DexFile* ClassLinker::FindOrCreateOatFileForDexLocationLocked(const std::string& dex_location,\n799                                                                    uint32_t dex_location_checksum,\n800                                                                    const std::string& oat_location) {\n801  // We play a locking game here so that if two different processes\n802  // race to generate (or worse, one tries to open a partial generated\n803  // file) we will be okay. This is actually common with apps that use\n804  // DexClassLoader to work around the dex method reference limit and\n805  // that have a background service running in a separate process.\n806  ScopedFlock scoped_flock;\n807  if (!scoped_flock.Init(oat_location)) {\n808    LOG(ERROR) << \"Failed to open locked oat file: \" << oat_location;\n809    return NULL;\n810  }\n811\n812  // Check if we already have an up-to-date output file\n813  const DexFile* dex_file = FindDexFileInOatLocation(dex_location,\n814                                                     dex_location_checksum,\n815                                                     oat_location);\n816  if (dex_file != NULL) {\n817    return dex_file;\n818  }\n819\n820  // Generate the output oat file for the dex file\n821  VLOG(class_linker) << \"Generating oat file \" << oat_location << \" for \" << dex_location;\n822  if (!GenerateOatFile(dex_location, scoped_flock.GetFile().Fd(), oat_location)) {\n823    LOG(ERROR) << \"Failed to generate oat file: \" << oat_location;\n824    return NULL;\n825  }\n826  const OatFile* oat_file = OatFile::Open(oat_location, oat_location, NULL,\n827                                          !Runtime::Current()->IsCompiler());\n828  if (oat_file == NULL) {\n829    LOG(ERROR) << \"Failed to open generated oat file: \" << oat_location;\n830    return NULL;\n831  }\n832  RegisterOatFileLocked(*oat_file);\n833  const OatFile::OatDexFile* oat_dex_file = oat_file->GetOatDexFile(dex_location, &dex_location_checksum);\n834  if (oat_dex_file == NULL) {\n835    LOG(ERROR) << \"Failed to find dex file \" << dex_location\n836               << \" (checksum \" << dex_location_checksum\n837               << \") in generated oat file: \" << oat_location;\n838    return NULL;\n839  }\n840  const DexFile* result = oat_dex_file->OpenDexFile();\n841  CHECK_EQ(dex_location_checksum, result->GetLocationChecksum())\n842          << \"dex_location=\" << dex_location << \" oat_location=\" << oat_location << std::hex\n843          << \" dex_location_checksum=\" << dex_location_checksum\n844          << \" DexFile::GetLocationChecksum()=\" << result->GetLocationChecksum();\n845  return result;\n846 }\n```\n\n```cpp\n543 bool ClassLinker::GenerateOatFile(const std::string& dex_filename,\n544                                  int oat_fd,\n545                                  const std::string& oat_cache_filename) {\n546  std::string dex2oat_string(GetAndroidRoot());\n547  dex2oat_string += (kIsDebugBuild ? \"/bin/dex2oatd\" : \"/bin/dex2oat\");\n548  const char* dex2oat = dex2oat_string.c_str();\n549\n550  const char* class_path = Runtime::Current()->GetClassPathString().c_str();\n551\n552  gc::Heap* heap = Runtime::Current()->GetHeap();\n553  std::string boot_image_option_string(\"--boot-image=\");\n554  boot_image_option_string += heap->GetImageSpace()->GetImageFilename();\n555  const char* boot_image_option = boot_image_option_string.c_str();\n556\n557  std::string dex_file_option_string(\"--dex-file=\");\n558  dex_file_option_string += dex_filename;\n559  const char* dex_file_option = dex_file_option_string.c_str();\n560\n561  std::string oat_fd_option_string(\"--oat-fd=\");\n562  StringAppendF(&oat_fd_option_string, \"%d\", oat_fd);\n563  const char* oat_fd_option = oat_fd_option_string.c_str();\n564\n565  std::string oat_location_option_string(\"--oat-location=\");\n566  oat_location_option_string += oat_cache_filename;\n567  const char* oat_location_option = oat_location_option_string.c_str();\n568\n569  std::string oat_compiler_filter_string(\"-compiler-filter:\");\n570  switch (Runtime::Current()->GetCompilerFilter()) {\n571    case Runtime::kInterpretOnly:\n572      oat_compiler_filter_string += \"interpret-only\";\n573      break;\n574    case Runtime::kSpace:\n575      oat_compiler_filter_string += \"space\";\n576      break;\n577    case Runtime::kBalanced:\n578      oat_compiler_filter_string += \"balanced\";\n579      break;\n580    case Runtime::kSpeed:\n581      oat_compiler_filter_string += \"speed\";\n582      break;\n583    case Runtime::kEverything:\n584      oat_compiler_filter_string += \"everything\";\n585      break;\n586    default:\n587      LOG(FATAL) << \"Unexpected case.\";\n588  }\n589  const char* oat_compiler_filter_option = oat_compiler_filter_string.c_str();\n590\n591  // fork and exec dex2oat\n592  pid_t pid = fork();\n593  if (pid == 0) {\n594    // no allocation allowed between fork and exec\n595\n596    // change process groups, so we don't get reaped by ProcessManager\n597    setpgid(0, 0);\n598\n599    // gLogVerbosity.class_linker = true;\n600    VLOG(class_linker) << dex2oat\n601                       << \" --runtime-arg -Xms64m\"\n602                       << \" --runtime-arg -Xmx64m\"\n603                       << \" --runtime-arg -classpath\"\n604                       << \" --runtime-arg \" << class_path\n605                       << \" --runtime-arg \" << oat_compiler_filter_option\n606#if !defined(ART_TARGET)\n607                       << \" --host\"\n608#endif\n609                       << \" \" << boot_image_option\n610                       << \" \" << dex_file_option\n611                       << \" \" << oat_fd_option\n612                       << \" \" << oat_location_option;\n613\n614    execl(dex2oat, dex2oat,\n615          \"--runtime-arg\", \"-Xms64m\",\n616          \"--runtime-arg\", \"-Xmx64m\",\n617          \"--runtime-arg\", \"-classpath\",\n618          \"--runtime-arg\", class_path,\n619          \"--runtime-arg\", oat_compiler_filter_option,\n620#if !defined(ART_TARGET)\n621          \"--host\",\n622#endif\n623          boot_image_option,\n624          dex_file_option,\n625          oat_fd_option,\n626          oat_location_option,\n627          NULL);\n628\n629    PLOG(FATAL) << \"execl(\" << dex2oat << \") failed\";\n630    return false;\n631  } else {\n632    // wait for dex2oat to finish\n633    int status;\n634    pid_t got_pid = TEMP_FAILURE_RETRY(waitpid(pid, &status, 0));\n635    if (got_pid != pid) {\n636      PLOG(ERROR) << \"waitpid failed: wanted \" << pid << \", got \" << got_pid;\n637      return false;\n638    }\n639    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n640      LOG(ERROR) << dex2oat << \" failed with dex-file=\" << dex_filename;\n641      return false;\n642    }\n643  }\n644  return true;\n645 }\n```\n\n```cpp\n376 const DexFile* OatFile::OatDexFile::OpenDexFile() const {\n377  return DexFile::Open(dex_file_pointer_, FileSize(), dex_file_location_,\n378                       dex_file_location_checksum_);\n379 }\n```","tags":["reverse"],"categories":["reverse"]},{"title":"Legu脱壳","url":"/2017/08/06/Legu脱壳/","content":"\n分析锁机样本中发现加了壳，硬着头皮撸了一遍，样本所使用加固为腾讯乐固，壳版本为2.10.3.1。\n\n使用乐固加固后会在Lib文件夹下生成如下文件。\n<!-- ![](Legu脱壳/1.png) -->\n{% asset_img 1.png %}\n加固的核心功能在libshella-2.10.3.1.so中，libBugly.so主要功能为监控程序异常数据，故不关注。\n\n修复so后，直接将so，拖入ida，如下图所示，JNI_OnLoad函数被加密，.init 与.init_array也无法显示。\n<!-- ![](Legu脱壳/2.png) -->\n{% asset_img 2.png %}\n这里需要修复so\n\n直接动态挂上IDA，在linker的.init_array调用出下好断点。\n\n<!-- ![](Legu脱壳/3.png) -->\n{% asset_img 3.png %}\n关于如何定位这里简单说一下，搜索字符串[ Calling %s @ %p for '%s' ]，BLX  R4就是调用出。\n\n<!-- ![](Legu脱壳/4.png) -->\n{% asset_img 4.png %}\n断点触发后运行到init_array位置。\n\n<!-- ![](Legu脱壳/5.png) -->\n{% asset_img 5.png %}\n看一下流程图，应该是被ollvm混淆过。\n\n来到函数尾部粗略看了看代码，调用了如下图中几个函数，在mprotect_0处断下后，代码解密完毕。\n\n<!-- ![](Legu脱壳/6.png) -->\n{% asset_img 6.png %}\n其中createthread创建了一个反调试线程，这里我直接nop了，粗略看了几眼。\n\n\n反调试线程函数伪代码如下：\n\n```c\nint __fastcall sub_6232D0B4(int a1)\n\n{\n\n  void *v1; // r1@48\n\n  signed int v2; // r2@48\n\n  int v4; // r0@54\n\n  int v5; // r0@54\n\n  int v6; // r1@54\n\n  int v7; // r0@54\n\n  int v8; // r0@55\n\n  void *v9; // r2@55\n\n  unsigned __int8 v10; // zf@55\n\n  signed int v11; // r0@55\n\n  void *v12; // r1@60\n\n  signed int v13; // r2@60\n\n  void *v14; // r1@65\n\n  signed int v15; // r2@65\n\n  int v16; // r2@71\n\n  int v17; // r0@71\n\n  int v18; // r0@73\n\n  int v19; // r0@74\n\n  void *v20; // r2@74\n\n  signed int v21; // r0@74\n\n  int v22; // r0@79\n\n  int v23; // r0@79\n\n  unsigned int v24; // r1@79\n\n  int v25; // r0@79\n\n  unsigned int v26; // r2@79\n\n  int v27; // r0@80\n\n  void *v28; // r2@80\n\n  unsigned __int8 v29; // nf@80\n\n  signed int v30; // r0@80\n\n  int v31; // r0@85\n\n  int *v32; // r1@86\n\n  int *v33; // r3@86\n\n  int v34; // r2@86\n\n  unsigned int v35; // r0@86\n\n  void *v36; // r2@86\n\n  signed int v37; // r0@86\n\n  int v38; // r0@91\n\n  int v39; // r0@91\n\n  int v40; // r0@92\n\n  int v41; // [sp+0h] [bp-4A0h]@54\n\n  int v42; // [sp+4h] [bp-49Ch]@92\n\n  int v43; // [sp+8h] [bp-498h]@91\n\n  int v44; // [sp+Ch] [bp-494h]@91\n\n  int v45; // [sp+10h] [bp-490h]@91\n\n  int v46; // [sp+14h] [bp-48Ch]@86\n\n  int v47; // [sp+18h] [bp-488h]@85\n\n  int v48; // [sp+1Ch] [bp-484h]@85\n\n  unsigned int v49; // [sp+20h] [bp-480h]@79\n\n  void *v50; // [sp+24h] [bp-47Ch]@79\n\n  int v51; // [sp+28h] [bp-478h]@79\n\n  int v52; // [sp+2Ch] [bp-474h]@79\n\n  int v53; // [sp+30h] [bp-470h]@79\n\n  int v54; // [sp+34h] [bp-46Ch]@79\n\n  int v55; // [sp+38h] [bp-468h]@73\n\n  int v56; // [sp+3Ch] [bp-464h]@71\n\n  int v57; // [sp+40h] [bp-460h]@71\n\n  int v58; // [sp+44h] [bp-45Ch]@54\n\n  int v59; // [sp+48h] [bp-458h]@54\n\n  int v60; // [sp+4Ch] [bp-454h]@54\n\n  int v61; // [sp+50h] [bp-450h]@54\n\n  void *v62; // [sp+54h] [bp-44Ch]@2\n\n  int v63; // [sp+58h] [bp-448h]@1\n\n  void *v64; // [sp+5Ch] [bp-444h]@1\n\n  char *v65; // [sp+60h] [bp-440h]@1\n\n  void *v66; // [sp+64h] [bp-43Ch]@1\n\n  void *v67; // [sp+68h] [bp-438h]@1\n\n  char v68; // [sp+6Ch] [bp-434h]@1\n\n  char v69; // [sp+6Dh] [bp-433h]@1\n\n  char v70; // [sp+6Eh] [bp-432h]@1\n\n  char v71; // [sp+6Fh] [bp-431h]@1\n\n  char v72; // [sp+70h] [bp-430h]@1\n\n  char v73; // [sp+71h] [bp-42Fh]@1\n\n  char v74; // [sp+72h] [bp-42Eh]@1\n\n  char v75; // [sp+73h] [bp-42Dh]@1\n\n  char v76; // [sp+74h] [bp-42Ch]@1\n\n  char v77; // [sp+75h] [bp-42Bh]@1\n\n  char v78; // [sp+76h] [bp-42Ah]@1\n\n  char v79; // [sp+77h] [bp-429h]@1\n\n  char v80; // [sp+78h] [bp-428h]@1\n\n  char v81; // [sp+79h] [bp-427h]@1\n\n  char v82; // [sp+7Ah] [bp-426h]@1\n\n  char v83; // [sp+7Bh] [bp-425h]@1\n\n  int v84; // [sp+7Ch] [bp-424h]@54\n\n  char v85; // [sp+80h] [bp-420h]@71\n\n  int v86; // [sp+480h] [bp-20h]@55\n\n  int v87; // [sp+484h] [bp-1Ch]@1\n\n  int v88; // [sp+488h] [bp-18h]@1\n\n  int v89; // [sp+48Ch] [bp-14h]@1\n\n \n\n  v88 = a1;\n\n  ++dword_62330398;\n\n  v66 = &unk_6232FF38;\n\n  v65 = &v68;\n\n  v64 = &unk_6232FF38;\n\n  unk_623303A8 = malloc_0(1024);\n\n  v63 = sub_6232B17C();\n\n  unk_623303AC = sub_6232B4E8(0, v88, unk_623303A4);\n\n  v82 = unk_623302EF ^ 0xD7;\n\n  v74 = unk_623302E7 ^ 0x9D;\n\n  v72 = unk_623302E5 ^ 0xC6;\n\n  v77 = unk_623302EA ^ 0xC3;\n\n  v80 = unk_623302ED ^ 0xBB;\n\n  v69 = unk_623302E2 ^ 0x81;\n\n  v78 = unk_623302EB ^ 0xD7;\n\n  v75 = unk_623302E8 ^ 0x95;\n\n  v70 = unk_623302E3 ^ 0xB5;\n\n  v81 = unk_623302EE ^ 0xDA;\n\n  v68 = unk_623302E1 ^ 0xF5;\n\n  v76 = unk_623302E9 ^ 0x9B;\n\n  v79 = unk_623302EC ^ 0xF2;\n\n  v73 = unk_623302E6 ^ 0xEA;\n\n  v71 = unk_623302E4 ^ 0xB7;\n\n  v83 = unk_623302F0;\n\n  v87 = opendir(&v68);\n\n  v89 = v87;\n\n  v67 = (void *)-1296986714;\n\n  do\n\n  {\n\n    while ( 1 )\n\n    {\n\n      while ( 1 )\n\n      {\n\n        while ( 1 )\n\n        {\n\n          while ( 1 )\n\n          {\n\n            while ( 1 )\n\n            {\n\n              while ( 1 )\n\n              {\n\n                while ( 1 )\n\n                {\n\n                  while ( 1 )\n\n                  {\n\n                    while ( 1 )\n\n                    {\n\n                      v62 = v67;\n\n                      if ( (signed int)v67 > -1437465226 )\n\n                        break;\n\n                      if ( v62 == (void *)-1866223142 )\n\n                        v67 = (void *)812103489;\n\n                    }\n\n                    if ( (signed int)v62 > -1296986715 )\n\n                      break;\n\n                    if ( v62 == (void *)-1437465225 )\n\n                    {\n\n                      *((_BYTE *)&v41 - 7) = byte_62330331;\n\n                      *((_BYTE *)&v41 - 18) = byte_62330326 ^ 0x8E;\n\n                      *((_BYTE *)&v41 - 9) = byte_6233032F ^ 0xB4;\n\n                      *((_BYTE *)&v41 - 19) = byte_62330325 ^ 0xD3;\n\n                      *((_BYTE *)&v41 - 13) = byte_6233032B ^ 0xBB;\n\n                      *((_BYTE *)&v41 - 24) = unk_62330320 ^ 0x90;\n\n                      *((_BYTE *)&v41 - 22) = byte_62330322 ^ 0xE0;\n\n                      *((_BYTE *)&v41 - 16) = byte_62330328 ^ 0xE9;\n\n                      *((_BYTE *)&v41 - 11) = byte_6233032D ^ 0xF0;\n\n                      *((_BYTE *)&v41 - 8) = byte_62330330 ^ 0xB8;\n\n                      *((_BYTE *)&v41 - 20) = byte_62330324 ^ 0xF7;\n\n                      *((_BYTE *)&v41 - 12) = byte_6233032C ^ 0xC2;\n\n                      *((_BYTE *)&v41 - 14) = byte_6233032A ^ 0xED;\n\n                      *((_BYTE *)&v41 - 17) = byte_62330327 ^ 0x9B;\n\n                      *((_BYTE *)&v41 - 23) = byte_62330321 ^ 0x84;\n\n                      *((_BYTE *)&v41 - 15) = byte_62330329 ^ 0xE5;\n\n                      *((_BYTE *)&v41 - 10) = byte_6233032E ^ 0xDB;\n\n                      *((_BYTE *)&v41 - 21) = byte_62330323 ^ 0xBC;\n\n                      v19 = sub_6232B7B8(&v41 - 6);\n\n                      v20 = (void *)936246879;\n\n                      v10 = v19 == 0;\n\n                      v21 = 0;\n\n                      if ( !v10 )\n\n                        v21 = 1;\n\n                      if ( v21 )\n\n                        v20 = &unk_53451D86;\n\n                      v67 = v20;\n\n                    }\n\n                  }\n\n                  if ( (signed int)v62 <= 2011994327 )\n\n                    break;\n\n                  if ( v62 == (void *)2011994328 )\n\n                  {\n\n                    v40 = ((int (__fastcall *)(signed int))unk_623223E4)(1);\n\n                    v67 = (void *)-1437465225;\n\n                    v42 = v40;\n\n                  }\n\n                }\n\n                if ( (signed int)v62 <= 1892825734 )\n\n                  break;\n\n                if ( v62 == (void *)1892825735 )\n\n                {\n\n                  v16 = v86 + 19;\n\n                  *((_BYTE *)&v41 - 21) = byte_62330303 ^ 0x83;\n\n                  *((_BYTE *)&v41 - 17) = byte_62330307 ^ 0x95;\n\n                  *((_BYTE *)&v41 - 13) = byte_6233030B ^ 0xD5;\n\n                  *((_BYTE *)&v41 - 20) = byte_62330304 ^ 0xE0;\n\n                  *((_BYTE *)&v41 - 11) = byte_6233030D ^ 0xB5;\n\n                  *((_BYTE *)&v41 - 24) = unk_62330300 ^ 0xE4;\n\n                  *((_BYTE *)&v41 - 3) = byte_62330315 ^ 0xAB;\n\n                  *((_BYTE *)&v41 - 10) = byte_6233030E ^ 0x93;\n\n                  *((_BYTE *)&v41 - 9) = byte_6233030F ^ 0xBD;\n\n                  *((_BYTE *)&v41 - 15) = byte_62330309 ^ 0xE5;\n\n                  *((_BYTE *)&v41 - 16) = byte_62330308 ^ 0xCB;\n\n                  *((_BYTE *)&v41 - 22) = byte_62330302 ^ 0xE6;\n\n                  *((_BYTE *)&v41 - 18) = byte_62330306 ^ 0xC8;\n\n                  *((_BYTE *)&v41 - 12) = byte_6233030C ^ 0x8F;\n\n                  *((_BYTE *)&v41 - 23) = byte_62330301 ^ 0x85;\n\n                  *((_BYTE *)&v41 - 5) = byte_62330313 ^ 0xB1;\n\n                  *((_BYTE *)&v41 - 6) = byte_62330312 ^ 0xE7;\n\n                  *((_BYTE *)&v41 - 4) = byte_62330314 ^ 0xE0;\n\n                  *((_BYTE *)&v41 - 14) = byte_6233030A ^ 0xB7;\n\n                  *((_BYTE *)&v41 - 19) = byte_62330305 ^ 0x8F;\n\n                  *((_BYTE *)&v41 - 7) = byte_62330311 ^ 0xAD;\n\n                  *((_BYTE *)&v41 - 8) = byte_62330310 ^ 0xD1;\n\n                  *((_BYTE *)&v41 - 2) = byte_62330316;\n\n                  v57 = sprintf_0(&v85, &v41 - 6, v16);\n\n                  v17 = add_watch(v84, &v85, 4095);\n\n                  v67 = (void *)-1866223142;\n\n                  v56 = v17;\n\n                }\n\n              }\n\n              if ( (signed int)v62 > -1215902312 )\n\n                break;\n\n              if ( v62 == (void *)-1296986714 )\n\n              {\n\n                v1 = (void *)-870557634;\n\n                v2 = 0;\n\n                if ( !v89 )\n\n                  v2 = 1;\n\n                if ( v2 )\n\n                  v1 = (void *)363810945;\n\n                v67 = v1;\n\n              }\n\n            }\n\n            if ( (signed int)v62 > -870557635 )\n\n              break;\n\n            if ( v62 == (void *)-1215902311 )\n\n            {\n\n              v32 = (int *)((char *)v66 + 1132);\n\n              v33 = (int *)((char *)v66 + 1140);\n\n              ++*((_DWORD *)v66 + 280);\n\n              v34 = *v32;\n\n              v46 = *v33;\n\n              v35 = sub_6232B4E8(0, v88, v34);\n\n              v36 = (void *)2011994328;\n\n              v10 = v46 == v35;\n\n              v37 = 0;\n\n              if ( !v10 )\n\n                v37 = 1;\n\n              if ( v37 )\n\n                v36 = &unk_4791A5A5;\n\n              v67 = v36;\n\n            }\n\n          }\n\n          if ( (signed int)v62 > 248389379 )\n\n            break;\n\n          if ( v62 == (void *)-870557634 )\n\n          {\n\n            v61 = 4095;\n\n            v84 = init();\n\n            v60 = v84;\n\n            v4 = fcntl_0(v84, 3, 0);\n\n            v5 = fcntl_0(v60, 4, v4 | 0x800);\n\n            v6 = v84;\n\n            *((_BYTE *)&v41 - 14) = byte_623302F3 ^ 0xFB;\n\n            *((_BYTE *)&v41 - 7) = byte_623302FA ^ 0xC7;\n\n            *((_BYTE *)&v41 - 3) = byte_623302FE ^ 0xA4;\n\n            *((_BYTE *)&v41 - 6) = byte_623302FB ^ 0xCD;\n\n            *((_BYTE *)&v41 - 8) = byte_623302F9 ^ 0xDF;\n\n            *((_BYTE *)&v41 - 12) = byte_623302F5 ^ 0xC2;\n\n            *((_BYTE *)&v41 - 11) = byte_623302F6 ^ 0xAD;\n\n            *((_BYTE *)&v41 - 9) = byte_623302F8 ^ 0xB5;\n\n            *((_BYTE *)&v41 - 10) = byte_623302F7 ^ 0xBB;\n\n            *((_BYTE *)&v41 - 16) = unk_623302F1 ^ 0xDF;\n\n            *((_BYTE *)&v41 - 5) = byte_623302FC ^ 0xF0;\n\n            *((_BYTE *)&v41 - 4) = byte_623302FD ^ 0xE9;\n\n            *((_BYTE *)&v41 - 2) = byte_623302FF;\n\n            *((_BYTE *)&v41 - 13) = byte_623302F4 ^ 0xEA;\n\n            *((_BYTE *)&v41 - 15) = byte_623302F2 ^ 0x93;\n\n            v59 = v5;\n\n            v7 = add_watch(v6, &v41 - 4, v61);\n\n            v67 = (void *)812103489;\n\n            v58 = v7;\n\n          }\n\n        }\n\n        if ( (signed int)v62 > 363810944 )\n\n          break;\n\n        if ( v62 == (void *)248389380 )\n\n        {\n\n          *((_BYTE *)&v41 - 6) = byte_62330334 ^ 0x99;\n\n          *((_BYTE *)&v41 - 5) = byte_62330335 ^ 0xA1;\n\n          *((_BYTE *)&v41 - 4) = byte_62330336;\n\n          *((_BYTE *)&v41 - 8) = unk_62330332 ^ 0xA3;\n\n          *((_BYTE *)&v41 - 7) = byte_62330333 ^ 0xD8;\n\n          *((_BYTE *)&v41 - 10) = byte_6233034B ^ 0xE8;\n\n          *((_BYTE *)&v41 - 12) = byte_62330349 ^ 0x94;\n\n          *((_BYTE *)&v41 - 16) = unk_62330345 ^ 0x9B;\n\n          *((_BYTE *)&v41 - 13) = byte_62330348 ^ 0xA8;\n\n          *((_BYTE *)&v41 - 14) = byte_62330347 ^ 0x8C;\n\n          *((_BYTE *)&v41 - 11) = byte_6233034A ^ 0xDC;\n\n          *((_BYTE *)&v41 - 6) = byte_6233034F;\n\n          *((_BYTE *)&v41 - 8) = byte_6233034D ^ 0x9B;\n\n          *((_BYTE *)&v41 - 7) = byte_6233034E ^ 0xBF;\n\n          *((_BYTE *)&v41 - 15) = byte_62330346 ^ 0x89;\n\n          *((_BYTE *)&v41 - 9) = byte_6233034C ^ 0x80;\n\n          v48 = sub_62322228(6, &v41 - 2, &v41 - 4);\n\n          v31 = raise(9);\n\n          v67 = (void *)-1215902311;\n\n          v47 = v31;\n\n        }\n\n      }\n\n      if ( (signed int)v62 <= 812103488 )\n\n        break;\n\n      if ( (signed int)v62 > 936246878 )\n\n      {\n\n        if ( (signed int)v62 > (signed int)&unk_43EA34CA )\n\n        {\n\n          if ( (signed int)v62 > (signed int)&unk_57D1BE0A )\n\n          {\n\n            if ( v62 == &unk_57D1BE0B )\n\n            {\n\n              v18 = closedir(v87);\n\n              v67 = (void *)-1437465225;\n\n              v55 = v18;\n\n            }\n\n          }\n\n          else if ( (signed int)v62 > (signed int)&unk_53451D85 )\n\n          {\n\n            if ( v62 == &unk_53451D86 )\n\n            {\n\n              *((_BYTE *)&v41 - 4) = byte_62330336;\n\n              *((_BYTE *)&v41 - 6) = byte_62330334 ^ 0x99;\n\n              *((_BYTE *)&v41 - 7) = byte_62330333 ^ 0xD8;\n\n              *((_BYTE *)&v41 - 8) = unk_62330332 ^ 0xA3;\n\n              *((_BYTE *)&v41 - 5) = byte_62330335 ^ 0xA1;\n\n              *((_BYTE *)&v41 - 12) = byte_6233033B ^ 0xB0;\n\n              *((_BYTE *)&v41 - 6) = byte_62330341 ^ 0xE3;\n\n              *((_BYTE *)&v41 - 14) = byte_62330339 ^ 0xE9;\n\n              *((_BYTE *)&v41 - 16) = unk_62330337 ^ 0x94;\n\n              *((_BYTE *)&v41 - 10) = byte_6233033D ^ 0xF5;\n\n              *((_BYTE *)&v41 - 13) = byte_6233033A ^ 0xEE;\n\n              *((_BYTE *)&v41 - 7) = byte_62330340 ^ 0xDE;\n\n              *((_BYTE *)&v41 - 8) = byte_6233033F ^ 0x83;\n\n              *((_BYTE *)&v41 - 9) = byte_6233033E ^ 0xD8;\n\n              *((_BYTE *)&v41 - 3) = byte_62330344;\n\n              *((_BYTE *)&v41 - 11) = byte_6233033C ^ 0xD4;\n\n              *((_BYTE *)&v41 - 4) = byte_62330343 ^ 0x9C;\n\n              *((_BYTE *)&v41 - 5) = byte_62330342 ^ 0xE2;\n\n              *((_BYTE *)&v41 - 15) = byte_62330338 ^ 0xCE;\n\n              v54 = sub_62322228(6, &v41 - 2, &v41 - 4);\n\n              v22 = getpid_0();\n\n              v53 = kill_0(v22, 9);\n\n              v23 = raise(9);\n\n              v24 = *((_DWORD *)v66 - 8) & 0xFFFFF000;\n\n              v52 = v23;\n\n              v25 = mprotect_0(v24, 0x2000, 3);\n\n              v26 = *((_DWORD *)v66 - 8) & 0xFFFFF000;\n\n              v51 = v25;\n\n              v50 = (void *)936246879;\n\n              v49 = v26;\n\n              aeabi_memset8(1074606080, 0x2000, 0);\n\n              v67 = v50;\n\n            }\n\n          }\n\n          else if ( (signed int)v62 > (signed int)&unk_4B2A5020 )\n\n          {\n\n            if ( v62 == &unk_4B2A5021 )\n\n            {\n\n              v12 = (void *)-1866223142;\n\n              v13 = 0;\n\n              if ( *(_BYTE *)(v86 + 18) & 4 )\n\n                v13 = 1;\n\n              if ( v13 )\n\n                v12 = &unk_43EA34CB;\n\n              v67 = v12;\n\n            }\n\n          }\n\n          else if ( v62 == &unk_43EA34CB )\n\n          {\n\n            v14 = (void *)1892825735;\n\n            v15 = 0;\n\n            if ( 46 == *(_BYTE *)(v86 + 19) )\n\n              v15 = 1;\n\n            if ( v15 )\n\n              v14 = &unk_45BD5515;\n\n            v67 = v14;\n\n          }\n\n          else if ( v62 == &unk_45BD5515 )\n\n          {\n\n            v67 = (void *)812103489;\n\n          }\n\n          else if ( v62 == &unk_4791A5A5 )\n\n          {\n\n            *((_BYTE *)&v41 - 5) = byte_62330335 ^ 0xA1;\n\n            *((_BYTE *)&v41 - 4) = byte_62330336;\n\n            *((_BYTE *)&v41 - 6) = byte_62330334 ^ 0x99;\n\n            *((_BYTE *)&v41 - 8) = unk_62330332 ^ 0xA3;\n\n            *((_BYTE *)&v41 - 7) = byte_62330333 ^ 0xD8;\n\n            *((_BYTE *)&v41 - 5) = byte_62330353 ^ 0xB6;\n\n            *((_BYTE *)&v41 - 6) = byte_62330352 ^ 0xA8;\n\n            *((_BYTE *)&v41 - 8) = unk_62330350 ^ 0xCA;\n\n            *((_BYTE *)&v41 - 3) = byte_62330355 ^ 0xBF;\n\n            *((_BYTE *)&v41 - 7) = byte_62330351 ^ 0xD6;\n\n            *((_BYTE *)&v41 - 2) = byte_62330356;\n\n            *((_BYTE *)&v41 - 4) = byte_62330354 ^ 0xD9;\n\n            v45 = sub_62322228(6, &v41 - 2, &v41 - 2);\n\n            v38 = getpid_0();\n\n            v44 = kill_0(v38, 9);\n\n            v39 = raise(9);\n\n            v67 = (void *)2011994328;\n\n            v43 = v39;\n\n          }\n\n        }\n\n        else if ( v62 == (void *)936246879 )\n\n        {\n\n          v27 = read_0(v84, &v85, 1024);\n\n          v28 = (void *)-1215902311;\n\n          v10 = v27 == 0;\n\n          v29 = v27 < 0;\n\n          v30 = 0;\n\n          if ( !(v29 | v10) )\n\n            v30 = 1;\n\n          if ( v30 )\n\n            v28 = (void *)248389380;\n\n          v67 = v28;\n\n        }\n\n      }\n\n      else if ( v62 == (void *)812103489 )\n\n      {\n\n        v8 = readdir(v87);\n\n        v9 = &unk_57D1BE0B;\n\n        v86 = v8;\n\n        v10 = v8 == 0;\n\n        v11 = 0;\n\n        if ( !v10 )\n\n          v11 = 1;\n\n        if ( v11 )\n\n          v9 = &unk_4B2A5021;\n\n        v67 = v9;\n\n      }\n\n    }\n\n  }\n\n  while ( v62 != (void *)363810945 );\n\n  return 0;\n\n}\n```\n\n之后根据偏移定位到JNI_OnLoad函数调用处，这中间好像还有两三处反调试，直接nop掉即可。\n<!-- ![](Legu脱壳/7.png) -->\n{% asset_img 7.png %}\n在JNI_OnLoad中发现有一个分支再次调用了JNI_OnLoad。\n<!-- ![](Legu脱壳/8.png) -->\n{% asset_img 8.png %}\n跟进，反汇编有些问题，不贴伪代码了。\n<!-- ![](Legu脱壳/9.png) -->\n{% asset_img 9.png %}\n其中init函数初始化了一些字符串，register_nativers这个函数大家应该都很熟悉了。\n<!-- ![](Legu脱壳/10.png) -->\n{% asset_img 10.png %}\nregister_nativers函数原型如下：\n```c\njint RegisterNatives（jclass clazz，const JNINativeMethod * methods，jint nMethods）\n```\n根据参数可知注册了五个函数，函数名分别为。\n<!-- ![](Legu脱壳/11.png) -->\n{% asset_img 11.png %}\n在java层中首先调用Jni的load函数，load函数获取PID，获取sdk版本，获取vm.version， 判断是art还是dalvik虚拟机，执行不同的加载方案，我这里是dalvik虚拟机，执行方案2。\n<!-- ![](Legu脱壳/12.png) -->\n{% asset_img 12.png %}\n<!-- ![](Legu脱壳/13.png) -->\n{% asset_img 13.png %}\n根据Log信息定位dex加载到内存中的位置。\n<!-- ![](Legu脱壳/14.png) -->\n{% asset_img 14.png %}\n分配内存空间，初始化dex内存结构。\n<!-- ![](Legu脱壳/15.png) -->\n{% asset_img 15.png %}\n<!-- ![](Legu脱壳/16.png) -->\n{% asset_img 16.png %}\n内存结构如下图所示，标红处为真实dex文件起始位置，此处即可dump\n<!-- ![](Legu脱壳/17.png) -->\n{% asset_img 17.png %}\nDalvikLoad函数伪代码如下：\n\n```c\nint v3; // r6@1\n\n  int v4; // r0@2\n\n  int v5; // r4@2\n\n  int v6; // r0@2\n\n  int v7; // r0@2\n\n  int v8; // r0@2\n\n  int v9; // r7@2\n\n  int v10; // ST00_4@3\n\n  int v11; // ST00_4@3\n\n  int v12; // r0@5\n\n  int v13; // ST00_4@5\n\n  const char *v14; // r1@6\n\n  const char *v15; // r2@6\n\n  int v16; // r0@16\n\n  int v17; // r5@16\n\n  _DWORD *v18; // r3@16\n\n  int v19; // ST00_4@17\n\n  int v20; // ST00_4@18\n\n  const char *v21; // r1@20\n\n  const char *v22; // r2@20\n\n  int v23; // r4@21\n\n  int v24; // r1@23\n\n  const char *v25; // r1@24\n\n  const char *v26; // r2@24\n\n  int v27; // r4@34\n\n  int v28; // ST14_4@40\n\n  int v29; // r0@40\n\n  int v30; // r1@41\n\n  int v31; // r1@44\n\n  int v32; // r5@47\n\n  int v33; // ST00_4@47\n\n  int v34; // r0@48\n\n  int v35; // ST00_4@49\n\n  int v36; // r5@49\n\n  int v37; // r4@53\n\n  int v38; // r4@57\n\n  int v39; // r2@61\n\n  int v40; // r3@62\n\n  int v41; // r3@64\n\n  int v42; // r3@65\n\n  int v43; // r3@66\n\n  int v44; // r1@67\n\n  int v45; // r3@67\n\n  int v46; // r5@67\n\n  int v47; // r2@68\n\n  int v48; // r5@80\n\n  int v49; // r2@80\n\n  int v50; // r0@82\n\n  int v51; // r4@85\n\n  int v52; // r0@87\n\n  int v53; // r5@87\n\n  int m; // r4@87\n\n  int v55; // r0@89\n\n  int v56; // r2@90\n\n  const char *v57; // r3@90\n\n  int v58; // ST00_4@90\n\n  int v59; // r1@90\n\n  int v60; // r0@90\n\n  int v61; // r0@79\n\n  int i; // r4@79\n\n  int v63; // r0@93\n\n  int v64; // r5@95\n\n  int v65; // r0@95\n\n  int j; // r4@95\n\n  int v67; // r0@97\n\n  int v68; // r5@98\n\n  int v69; // r4@98\n\n  int v70; // r0@98\n\n  int k; // r4@98\n\n  int v72; // r0@100\n\n  int v73; // r5@101\n\n  int v74; // r4@101\n\n  int v75; // r7@101\n\n  int v76; // r0@101\n\n  int v77; // r0@101\n\n  int l; // r4@101\n\n  int v79; // r0@103\n\n  int v80; // r4@104\n\n  int v81; // r0@104\n\n  int v82; // ST00_4@105\n\n  int v83; // ST00_4@106\n\n  _DWORD *result; // r0@108\n\n  int v85; // [sp+10h] [bp-180h]@3\n\n  int v86; // [sp+10h] [bp-180h]@79\n\n  int v87; // [sp+14h] [bp-17Ch]@5\n\n  signed int v88; // [sp+14h] [bp-17Ch]@40\n\n  int v89; // [sp+14h] [bp-17Ch]@98\n\n  int v90; // [sp+18h] [bp-178h]@3\n\n  int v91; // [sp+18h] [bp-178h]@13\n\n  int v92; // [sp+1Ch] [bp-174h]@1\n\n  signed int v93; // [sp+1Ch] [bp-174h]@36\n\n  int v94; // [sp+1Ch] [bp-174h]@54\n\n  int v95; // [sp+20h] [bp-170h]@1\n\n  int v96; // [sp+24h] [bp-16Ch]@3\n\n  int v97; // [sp+24h] [bp-16Ch]@98\n\n  int v98; // [sp+28h] [bp-168h]@13\n\n  int v99; // [sp+2Ch] [bp-164h]@2\n\n  signed int v100; // [sp+2Ch] [bp-164h]@54\n\n  int v101; // [sp+30h] [bp-160h]@3\n\n  int v102; // [sp+34h] [bp-15Ch]@13\n\n  int v103; // [sp+38h] [bp-158h]@2\n\n  int v104; // [sp+3Ch] [bp-154h]@13\n\n  int v105; // [sp+40h] [bp-150h]@40\n\n  int v106; // [sp+44h] [bp-14Ch]@3\n\n  int v107; // [sp+4Ch] [bp-144h]@95\n\n  int v108; // [sp+50h] [bp-140h]@40\n\n  int v109; // [sp+54h] [bp-13Ch]@2\n\n  _DWORD *v110; // [sp+5Ch] [bp-134h]@1\n\n  int v111; // [sp+60h] [bp-130h]@37\n\n  char v112; // [sp+64h] [bp-12Ch]@53\n\n  int v113; // [sp+78h] [bp-118h]@53\n\n  char v114; // [sp+7Ch] [bp-114h]@53\n\n  int v115; // [sp+90h] [bp-100h]@53\n\n  char v116; // [sp+94h] [bp-FCh]@37\n\n  int v117; // [sp+A8h] [bp-E8h]@37\n\n  signed int v118; // [sp+B4h] [bp-DCh]@40\n\n  int v119; // [sp+174h] [bp-1Ch]@1\n\n \n\n  v3 = a1;\n\n  v92 = a3;\n\n  v119 = *dword_62282DA4;\n\n  v110 = dword_62282DA4;\n\n  v95 = (unk_6226ACF8)(a1);\n\n  if ( !v95 )\n\n    goto LABEL_108;\n\n  v4 = (unk_6226A980)(v3, \"com/tencent/StubShell/TxAppEntry\");\n\n  v5 = v4;\n\n  v6 = (unk_6226C90C)(v3, v4, \"mSrcPath\", \"Ljava/lang/String;\");\n\n  v103 = (unk_6226C91A)(v3, v5, v6);\n\n  v99 = (unk_6226AEC0)(v3, v103);\n\n  v7 = (unk_6226C90C)(v3, v5, \"mPKName\", \"Ljava/lang/String;\");\n\n  v8 = (unk_6226C91A)(v3, v5, v7);\n\n  v109 = (unk_6226AEC0)(v3, v8);\n\n  v9 = unk_62282DA8;\n\n  if ( dword_622836F8 > 10 )\n\n  {\n\n    v10 = *(unk_62282DA8 + 248);\n\n    v106 = (unk_6226AF4C)(v3, v95, *(unk_62282DA8 + 240), *(unk_62282DA8 + 244));\n\n    v11 = *(v9 + 220);\n\n    v101 = (unk_6226AF4C)(v3, v106, *(v9 + 212), *(v9 + 216));\n\n    v96 = (unk_6226A9C6)(v3, v101);\n\n    v90 = 0;\n\n    v85 = 0;\n\n    while ( 1 )\n\n    {\n\n      if ( v90 >= v96 )\n\n      {\n\n        v91 = 0;\n\n        v104 = 0;\n\n        v102 = 0;\n\n        v98 = 0;\n\n        goto LABEL_33;\n\n      }\n\n      v12 = (unk_6226A9D4)(v3, v101, v90);\n\n      v13 = *(v9 + 232);\n\n      v87 = (unk_6226AF4C)(v3, v12, *(v9 + 224), *(v9 + 228));\n\n      if ( !v87 )\n\n        break;\n\n      v85 = (unk_6226B87C)(v3, v87, *(v9 + 236), *(v9 + 424));\n\n      if ( !v85 )\n\n      {\n\n        v85 = (unk_6226BA5C)(v3, v87, *(v9 + 236), *(v9 + 424));\n\n        if ( !v85 )\n\n        {\n\n          v14 = \"SecShell\";\n\n          v15 = \"SetDexClassLoaderCookie GetIntField fail\";\n\n          goto LABEL_10;\n\n        }\n\n      }\n\n      if ( *v85 && !(unk_6227B18C)(*v85) )\n\n      {\n\n        v91 = 0;\n\n        v104 = 0;\n\n        v102 = 0;\n\n        v98 = 0;\n\n        goto LABEL_33;\n\n      }\n\nLABEL_14:\n\n      ++v90;\n\n    }\n\n    v14 = \"SecShell\";\n\n    v15 = \"SetDexClassLoaderCookie GetObjectField fail:pDexPathListElementsClassName\";\n\nLABEL_10:\n\n    Log(3, v14, v15);\n\n    goto LABEL_14;\n\n  }\n\n  v16 = (unk_6226A980)(v3, *(unk_62282DA8 + 456));\n\n  v17 = (unk_6226C8B6)(v3, v95, v16);\n\n  v18 = (v9 + 204);\n\n  if ( v17 )\n\n  {\n\n    v19 = *(v9 + 208);\n\n    v98 = (unk_6226AF4C)(v3, v95, *(v9 + 456), *v18);\n\n    v102 = (unk_6226AF4C)(v3, v95, *(v9 + 456), \"mPaths\");\n\n    v104 = (unk_6226AF4C)(v3, v95, *(v9 + 456), \"mFiles\");\n\n    v91 = (unk_6226AF4C)(v3, v95, *(v9 + 456), \"mZips\");\n\n  }\n\n  else\n\n  {\n\n    v20 = *(v9 + 208);\n\n    v98 = (unk_6226AF4C)(v3, v95, *(v9 + 200), *v18);\n\n    v104 = (unk_6226AF4C)(v3, v95, *(v9 + 200), \"mFiles\");\n\n    v102 = 0;\n\n    v91 = (unk_6226AF4C)(v3, v95, *(v9 + 200), \"mZips\");\n\n  }\n\n  if ( !v98 )\n\n  {\n\n    v21 = \"SecShell\";\n\n    v22 = \"SetDexClassLoaderCookie GetObjectField fail:pmDexs\";\n\n    goto LABEL_51;\n\n  }\n\n  v23 = 0;\n\n  v96 = (unk_6226A9C6)(v3, v98);\n\n  v85 = 0;\n\n  while ( 1 )\n\n  {\n\n    if ( v23 >= v96 )\n\n    {\n\n      v101 = 0;\n\n      v106 = 0;\n\n      goto LABEL_33;\n\n    }\n\n    v24 = (unk_6226A9D4)(v3, v98, v23);\n\n    if ( !v24 )\n\n    {\n\n      v25 = \"SecShell\";\n\n      v26 = \"SetDexClassLoaderCookie GetObjectArrayElement fail\";\n\nLABEL_27:\n\n      Log(3, v25, v26);\n\n      goto LABEL_30;\n\n    }\n\n    v85 = (unk_6226B87C)(v3, v24, *(v9 + 236), *(v9 + 424));\n\n    if ( !v85 )\n\n    {\n\n      v25 = \"SecShell\";\n\n      v26 = \"SetDexClassLoaderCookie GetIntField fail\";\n\n      goto LABEL_27;\n\n    }\n\n    if ( *v85 && !(unk_6227B18C)(*v85) )\n\n      break;\n\nLABEL_30:\n\n    ++v23;\n\n  }\n\n  v101 = 0;\n\n  v106 = 0;\n\nLABEL_33:\n\n  if ( v92 )\n\n    v27 = v92 - 40;\n\n  else\n\n    v27 = (unk_6226E5A4)(v109, \"classes.dex\", 0);\n\n  v93 = 0;\n\n  if ( !v27 )\n\n  {\n\n    (unk_6226E6E8)(&v116, v99, &v111);\n\n    Log(3, \"SecShell\", \"strSrcPath:%s\");\n\n    (unk_6226EC54)(&v116);\n\n    Log(3, \"SecShell\", \"strSrcPath:%s\");\n\n    v27 = (unk_6226E5A4)(v117, \"classes.dex\", 0);\n\n    (unk_6226E6A4)(&v116);\n\n    if ( v27 )\n\n    {\n\n      v93 = 0;\n\n    }\n\n    else\n\n    {\n\n      v27 = (unk_6226D964)(v85) - 40;\n\n      v93 = 1;\n\n    }\n\n  }\n\n  v28 = (unk_6226C9BA)(v27 + 40);\n\n  Log(3, \"SecShell\", \"orgDexOffset:%d\");\n\n  (unk_6227B1FC)(&v116, 0, 224);\n\n  v108 = v27 + v28 + 40;\n\n  (unk_6227B27C)(&v116, v27 + v28 + 40, 224);\n\n  (unk_622743D8)(&unk_62283248, &v116, 224, 32);\n\n  v105 = v27 + v28 + 40;\n\n  v88 = v118;\n\n  v29 = Log(3, \"SecShell\", \"fileSize:%d\");\n\n  if ( v93 )\n\n  {\n\n    v30 = v88;\n\n    if ( v88 & 0xFFF )\n\n      v30 = (v88 / 4096 + 1) << 12;\n\n    v29 = (unk_6227B1DC)(v27, v30, 3);\n\n    if ( v29 )\n\n    {\n\n      v31 = v88;\n\n      if ( v88 & 0xFFF )\n\n        v31 = (v88 / 4096 + 1) << 12;\n\n      v29 = (unk_6227B1DC)(v27, v31, 5);\n\n    }\n\n  }\n\n  v32 = (unk_6226CDBC)(v29);\n\n  v33 = *(unk_6227B3DC)(v32);\n\n  Log(3, \"SecShell\", \"mRes:%d error:%d\");\n\n  if ( v32 != -1 || (v34 = Log(3, \"SecShell\", \"wrong code1\"), (unk_6226CE0C)(v34) != -1) )\n\n  {\n\nLABEL_53:\n\n    (unk_622743D8)(&unk_62283248, v105, 224, 32);\n\n    (unk_6226E6E8)(&v112, \"/data/data/\", &v111);\n\n    (unk_6226E81A)(&v112, v109);\n\n    (unk_6226E9D4)(&v114, &v112, \"/mix.so\");\n\n    (unk_6226E81A)(&v112, \"/mix.dex\");\n\n    v37 = sub_6226ADB0(v3, v113);\n\n    sub_6226ADB0(v3, v115);\n\n    if ( (unk_6226D4A8)(v3, v103, v113)\n\n      && (v94 = (unk_6226AAD0)(\n\n                  v3,\n\n                  \"dalvik/system/DexFile\",\n\n                  \"loadDex\",\n\n                  \"(Ljava/lang/String;Ljava/lang/String;I)Ldalvik/system/DexFile;\")) != 0 )\n\n    {\n\n      v103 = v37;\n\n      v100 = 0;\n\n    }\n\n    else\n\n    {\n\n      Log(3, \"SecShell\", \"load mix.dex failed\");\n\n      (unk_6226E938)(&v112, v99);\n\n      v94 = (unk_6226AAD0)(\n\n              v3,\n\n              \"dalvik/system/DexFile\",\n\n              \"loadDex\",\n\n              \"(Ljava/lang/String;Ljava/lang/String;I)Ldalvik/system/DexFile;\");\n\n      Log(3, \"SecShell\", \"load org.dex end\");\n\n      v100 = 1;\n\n    }\n\n    v38 = (unk_6226B87C)(v3, v94, *(v9 + 236), *(v9 + 424));\n\n    if ( !v38 )\n\n    {\n\n      v38 = (unk_6226BA5C)(v3, v94, *(v9 + 236), *(v9 + 424));\n\n      if ( !v38 )\n\n        Log(3, \"SecShell\", \"testCookie is null\");\n\n    }\n\n    if ( v100 )\n\n    {\n\n      v39 = dword_622836F8;\n\n    }\n\n    else\n\n    {\n\n      v39 = dword_622836F8;\n\n      if ( dword_622836F8 > 10 )\n\n      {\n\n        v40 = *(*(v38 + 8) + 4);\n\n        goto LABEL_67;\n\n      }\n\n    }\n\n    v41 = *(v38 + 12);\n\n    if ( v39 == 8 )\n\n      v42 = *(v41 + 36);\n\n    else\n\n      v43 = *(v41 + 40);\n\nLABEL_67:\n\n    v111 = 0;\n\n    (unk_6226D850)(v3, v105, v88, &v111);\n\n    v45 = v111;\n\n    v46 = *(v111 + 4);\n\n    if ( v100 )\n\n    {\n\n      *(v38 + 8) = v111;\n\n      *(v38 + 4) = 1;\n\n      if ( dword_622836F8 == 10 )\n\n        *(v85 + 16) = v105;\n\n    }\n\n    else\n\n    {\n\n      v47 = dword_622836F8;\n\n      if ( dword_622836F8 > 10 )\n\n      {\n\n        if ( dword_622836F8 <= 18 && (unk_6226CE60)(v100, v44, dword_622836F8) )\n\n          (unk_6227227C)(*(*(v38 + 8) + 4), v46, dword_622836F8);\n\n        else\n\n          (unk_62272290)(*(*(v38 + 8) + 4), v46, dword_622836F8);\n\nLABEL_78:\n\n        if ( dword_622836F8 <= 10 )\n\n        {\n\n          v61 = (unk_6226A980)(v3, \"dalvik/system/DexFile\");\n\n          v86 = (unk_6226C928)(v3, v96 + 1, v61, 0);\n\n          (unk_6226A9E2)(v3, v86, 0, v94);\n\n          for ( i = 0; i < v96; (unk_6226A9E2)(v3, v86, i, v63) )\n\n            v63 = (unk_6226A9D4)(v3, v98, i++);\n\n          if ( v102 )\n\n          {\n\n            v64 = (unk_6226A9C6)(v3, v102);\n\n            v65 = (unk_6226A980)(v3, \"java/lang/String\");\n\n            v107 = (unk_6226C928)(v3, v64 + 1, v65, 0);\n\n            (unk_6226A9E2)(v3, v107, 0, v103);\n\n            for ( j = 0; j < v64; (unk_6226A9E2)(v3, v107, j, v67) )\n\n              v67 = (unk_6226A9D4)(v3, v102, j++);\n\n          }\n\n          v68 = (unk_6226A9C6)(v3, v104);\n\n          v69 = (unk_6226A980)(v3, \"java/io/File\");\n\n          v89 = (unk_6226C928)(v3, v68 + 1, v69, 0);\n\n          v70 = (unk_6226A9AE)(v3, v69, \"<init>\", \"(Ljava/lang/String;)V\");\n\n          v97 = (unk_6226A994)(v3, v69, v70, v103);\n\n          (unk_6226A9E2)(v3, v89, 0, v97);\n\n          for ( k = 0; k < v68; (unk_6226A9E2)(v3, v89, k, v72) )\n\n            v72 = (unk_6226A9D4)(v3, v104, k++);\n\n          v73 = (unk_6226A9C6)(v3, v91);\n\n          v74 = (unk_6226A980)(v3, \"java/util/zip/ZipFile\");\n\n          v75 = (unk_6226C928)(v3, v73 + 1, v74, 0);\n\n          v76 = (unk_6226A9AE)(v3, v74, \"<init>\", \"(Ljava/io/File;)V\");\n\n          v77 = (unk_6226A994)(v3, v74, v76, v97);\n\n          (unk_6226A9E2)(v3, v75, 0, v77);\n\n          for ( l = 0; l < v73; (unk_6226A9E2)(v3, v75, l, v79) )\n\n            v79 = (unk_6226A9D4)(v3, v91, l++);\n\n          v80 = unk_62282DA8;\n\n          v81 = (unk_6226A980)(v3, *(unk_62282DA8 + 456));\n\n          if ( (unk_6226C8B6)(v3, v95, v81) )\n\n          {\n\n            v82 = *(v80 + 208);\n\n            (unk_6226B008)(v3, v95, *(v80 + 456), *(v80 + 204));\n\n            (unk_6226B008)(v3, v95, *(v80 + 456), \"mPaths\");\n\n            (unk_6226B008)(v3, v95, *(v80 + 456), \"mFiles\");\n\n            v56 = *(v80 + 456);\n\n            v60 = v3;\n\n            v59 = v95;\n\n            v57 = \"mZips\";\n\n          }\n\n          else\n\n          {\n\n            v83 = *(v80 + 208);\n\n            (unk_6226B008)(v3, v95, *(v80 + 200), *(v80 + 204));\n\n            (unk_6226B008)(v3, v95, *(v80 + 200), \"mFiles\");\n\n            v56 = *(v80 + 200);\n\n            v60 = v3;\n\n            v59 = v95;\n\n            v57 = \"mZips\";\n\n          }\n\n          goto LABEL_91;\n\n        }\n\n        v48 = (unk_6226A980)(v3, \"dalvik/system/DexPathList$Element\");\n\n        v49 = (unk_6226A9AE)(v3, v48, \"<init>\", \"(Ljava/io/File;Ljava/util/zip/ZipFile;Ldalvik/system/DexFile;)V\");\n\n        if ( v49\n\n          || ((unk_6226C8AC)(v3),\n\n              (v49 = (unk_6226A9AE)(v3, v48, \"<init>\", \"(Ljava/io/File;Ljava/io/File;Ldalvik/system/DexFile;)V\")) != 0) )\n\n        {\n\n          v50 = (unk_6226A994)(v3, v48, v49);\n\n        }\n\n        else\n\n        {\n\n          (unk_6226C8AC)(v3);\n\n          if ( !(unk_6226A9AE)(v3, v48, \"<init>\", \"(Ljava/io/File;ZLjava/io/File;Ldalvik/system/DexFile;)V\") )\n\n          {\n\n            v51 = 0;\n\nLABEL_87:\n\n            v52 = (unk_6226A980)(v3, \"dalvik/system/DexPathList$Element\");\n\n            v53 = (unk_6226C928)(v3, v96 + 1, v52, 0);\n\n            (unk_6226A9E2)(v3, v53, 0, v51);\n\n            for ( m = 0; m < v96; (unk_6226A9E2)(v3, v53, m, v55) )\n\n              v55 = (unk_6226A9D4)(v3, v101, m++);\n\n            v56 = *(v9 + 212);\n\n            v57 = *(v9 + 216);\n\n            v58 = *(v9 + 220);\n\n            v59 = v106;\n\n            v60 = v3;\n\nLABEL_91:\n\n            (unk_6226B008)(v60, v59, v56, v57);\n\n            dword_62283728 = (*(*v3 + 84))(v3, v94);\n\n            Log(3, \"SecShell\", &unk_6227F13A);\n\n            (unk_6226E6A4)(&v114);\n\n            (unk_6226E6A4)(&v112);\n\n            goto LABEL_108;\n\n          }\n\n          v50 = (unk_6226A994)(v3, v48);\n\n        }\n\n        v51 = v50;\n\n        goto LABEL_87;\n\n      }\n\n      *(v38 + 4) = 1;\n\n      *(v38 + 8) = v45;\n\n      if ( v47 == 10 )\n\n        *(v85 + 16) = v105;\n\n    }\n\n    *(v38 + 12) = 0;\n\n    goto LABEL_78;\n\n  }\n\n  Log(3, \"SecShell\", \"wrong code\");\n\n  v35 = (unk_6227B32C)(\"/dev/zero\", 2);\n\n  v36 = (unk_6227B44C)(0, v88);\n\n  (unk_6227B38C)(v35);\n\n  if ( v36 )\n\n  {\n\n    (unk_6227B28C)(v36, v108, v88);\n\n    v105 = v36;\n\n    goto LABEL_53;\n\n  }\n\n  v21 = \"SecShell\";\n\n  v22 = \"mmap fail\";\n\nLABEL_51:\n\n  Log(3, v21, v22);\n\nLABEL_108:\n\n  result = v110;\n\n  if ( v119 != *v110 )\n\n    sub_6227B24C(v110);\n\n  return result;\n\n}\n```\n\n文档写的有些流水账，只是调试过程中的一些记录，各位看官勿喷。如有误欢迎交流与指点。","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之DES","url":"/2017/05/08/算法识别之DES/","content":"\n## DES算法简介\nDES（Data Encryption Standard，即数据加密标准），是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。\n\n## DES算法原理\nDES的每个分组是64位，既明文和密钥都是64位（密钥实际用56位，每字节第8位为校验）。这个算法的核心是Feistel密码，由于其设计的巧妙，加密解密都用一个函数，具体原理请查阅其他资料。DES的流程基本是执行16轮下面的运算：\n1 初始变换Initial Permutation\n2 右边32位f函数\n2.1 E置换\n2.2 与轮密钥XOR\n2.3 S盒替换\n2.4 P置换\n2.5 和左边32位XOR\n3 左右交换，最终变换final permutation\n需要特别注意的是，最后一轮是不需要做左右交换这一部的。 \n{% asset_img des_1.jpg %}\n\n初始化置换IP表\n首先准备一个置换IP(Initial Permutation)表，IP表用于处理输出的数据分组，我们的明文会以64位为一个分组的形式，按照置换IP表的规则来置换\n```\n58 50 42 34 26 18 10 02 \n60 52 44 36 28 20 12 04 \n62 54 46 38 30 22 14 06 \n64 56 48 40 32 24 16 08 \n57 49 41 33 25 17 09 01 \n59 51 43 35 27 19 11 03 \n61 53 45 37 29 21 13 05 \n63 55 47 39 31 23 15 07\n```\n根据置换后的数据分成两组，第一组为L[0]，第二组为R[0]\n```\n58 50 42 34 26 18 10 02 \n60 52 44 36 28 20 12 04 \n62 54 46 38 30 22 14 06 \n64 56 48 40 32 24 16 08\n```\n```\n58 50 42 34 26 18 10 02 \n60 52 44 36 28 20 12 04 \n62 54 46 38 30 22 14 06 \n64 56 48 40 32 24 16 08\n```\n\n变换密钥 \n取得64位的密钥，每个第8位作为奇偶校验位，DES的密钥由64位减至56位，产生的56位密钥如下所示。\n```\nPermuted Choice 1 (PC-1) \n57 49 41 33 25 17 09 \n01 58 50 42 34 26 18 \n10 02 59 51 43 35 27 \n19 11 03 60 52 44 36 \n63 55 47 39 31 23 15 \n07 62 54 46 38 30 22 \n14 06 61 53 45 37 29 \n21 13 05 28 20 12 04\n```\n将变换后的密钥分为两个部分，开始的28位称为C[0]，最后的28位称为D[0]\n```\n57 49 41 33 25 17 09 \n01 58 50 42 34 26 18 \n10 02 59 51 43 35 27 \n19 11 03 60 52 44 36\n```\n```\n63 55 47 39 31 23 15 \n07 62 54 46 38 30 22 \n14 06 61 53 45 37 29 \n21 13 05 28 20 12 04\n```\n同时将C[I]、D[I]分别按照下面的左移位数循环移位操作。\n```\n1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1\n```\n\n移位完成后将C[I]和D[I]作为一个整体，按照PC-2(Permuted Choice 2)表置换，得到48位子秘钥K[i]，然后继续使用循环移位后的C[0]和D[0]再循环进行移位，下一次的循环移位一定要在上一次循环移位之后的C[0]和D[0]的基础上移位，最终计算出16组48位的子秘钥K[0]-K[15]\n```\n14 17 11 24 01 05 \n03 28 15 06 21 10 \n23 19 12 04 26 08 \n16 07 27 20 13 02 \n41 52 31 37 47 55 \n30 40 51 45 33 48 \n44 49 39 56 34 53 \n46 42 50 36 29 32\n```\n\nE扩展\n通过扩展置换E，数据的右半部分Rn从32位扩展到48位。扩展置换改变了位的次序，重复了某些位。\n扩展置换的目的：a、产生与秘钥相同长度的数据以进行异或运算，R0是32位，子秘钥是48位，所以R0要先进行扩展置换之后与子秘钥进行异或运算；b、提供更长的结果，使得在替代运算时能够进行压缩。\n```\n32 01 02 03 04 05\n04 05 06 07 08 09\n08 09 10 11 12 13\n12 13 14 15 16 17\n16 17 18 19 20 21\n20 21 22 23 24 25\n24 25 26 27 28 29\n28 29 30 31 32 01\n```\n\nS盒替代\n将E[i]和K[i]异或，异或完后得到的数据依旧为48位，将异或后的结果分为8个6位长的部分，第一组为B[0]，依次8组直到B[7]，每一组对应一个S表，比如B[0]对应S[0]，然后XXXXXXXXXXXXXXXXXXXXX，依次计算完B[0]-B[7]\nS[0]\n```\n14 04 13 01 02 15 11 08 03 10 06 12 05 09 00 07 \n00 15 07 04 14 02 13 01 10 06 12 11 09 05 03 08 \n04 01 14 08 13 06 02 11 15 12 09 07 03 10 05 00 \n15 12 08 02 04 09 01 07 05 11 03 14 10 00 06 13\n\n```\nS[1]\n```\n15 01 08 14 06 11 03 04 09 07 02 13 12 00 05 10 \n03 13 04 07 15 02 08 14 12 00 01 10 06 09 11 05 \n00 14 7 11 10 04 13 01 05 08 12 06 09 03 02 15 \n13 08 10 01 03 15 04 02 11 06 07 12 00 05 14 09\n```\nS[2]\n```\n10 00 09 14 06 03 15 05 01 13 12 07 11 04 02 08 \n13 07 00 09 03 04 06 10 02 08 05 14 12 11 15 01 \n13 06 04 09 08 15 03 00 11 01 02 12 05 10 14 07 \n01 10 13 00 06 09 08 07 04 15 14 03 11 05 02 12\n```\nS[3]\n```\n07 13 14 03 00 06 09 10 01 02 08 05 11 12 04 15 \n13 08 11 05 06 15 00 03 04 07 02 12 01 10 14 09 \n10 06 09 00 12 11 07 13 15 01 03 14 05 02 08 04 \n03 15 00 06 10 01 13 08 09 04 05 11 12 07 02 14\n```\nS[4]\n```\n02 12 04 01 07 10 11 06 08 05 03 15 13 00 14 09 \n14 11 02 12 04 07 13 01 05 00 15 10 03 09 08 06 \n04 02 01 11 10 13 07 08 15 09 12 05 06 03 00 14 \n11 08 12 07 01 14 02 13 06 15 00 09 10 04 05 03\n```\nS[5]\n```\n12 01 10 15 09 02 06 08 00 13 03 04 14 07 05 11 \n10 15 04 02 07 12 09 05 06 01 13 14 00 11 03 08 \n09 14 15 05 02 08 12 03 07 00 04 10 01 13 11 06 \n04 03 02 12 09 05 15 10 11 14 01 07 06 00 80 13\n```\nS[6]\n```\n04 11 02 14 15 00 08 13 03 12 09 07 05 10 06 01 \n13 00 11 07 04 09 01 10 14 03 05 12 02 15 08 06 \n01 04 11 13 12 03 07 14 10 15 06 08 00 05 09 02 \n06 11 13 08 01 04 10 07 09 05 00 15 14 02 03 12\n```\nS[7]\n```\n13 02 08 04 06 15 11 01 10 09 03 14 05 00 12 07 \n01 15 13 08 10 03 07 04 12 05 06 11 00 14 09 02 \n07 11 04 01 09 12 14 02 00 06 10 13 15 03 05 08 \n02 01 14 07 04 10 08 13 15 12 09 00 03 05 06 11\n```\n\n\nP置换\n将计算出的8个B[i]进行P(Permutation)盒置换\n```\n16 07 20 21 29 12 28 17 \n01 15 23 26 05 18 31 10 \n02 08 24 14 32 27 03 09 \n19 13 30 06 22 11 04 25\n```\n将置换后的数据和L[i]进行异或，异或完，将结果保存在R[i+1]，将R[i]赋值给L[i+1]，再回到E盒扩展循环，直到完成16轮计算\n\n逆置换\n将最终计算出的R[16]与L[16]结合，R放前面，再按IP-1表置换就能得到最后的结果\n```\n40 08 48 16 56 24 64 32 \n39 07 47 15 55 23 63 31 \n38 06 46 14 54 22 62 30 \n37 05 45 13 53 21 61 29 \n36 04 44 12 52 20 60 28 \n35 03 43 11 51 19 59 27 \n34 02 42 10 50 18 58 26 \n33 01 41 09 49 17 57 25\n```\n\n## 实例分析\nDES C实现源码\n```c\n#define LB32_MASK   0x00000001\n#define LB64_MASK   0x0000000000000001\n#define L64_MASK    0x00000000ffffffff\n#define H64_MASK    0xffffffff00000000\n\n/* Initial Permutation Table */\nstatic char IP[] = {\n    58, 50, 42, 34, 26, 18, 10,  2, \n    60, 52, 44, 36, 28, 20, 12,  4, \n    62, 54, 46, 38, 30, 22, 14,  6, \n    64, 56, 48, 40, 32, 24, 16,  8, \n    57, 49, 41, 33, 25, 17,  9,  1, \n    59, 51, 43, 35, 27, 19, 11,  3, \n    61, 53, 45, 37, 29, 21, 13,  5, \n    63, 55, 47, 39, 31, 23, 15,  7\n};\n\n/* Inverse Initial Permutation Table */\nstatic char PI[] = {\n    40,  8, 48, 16, 56, 24, 64, 32, \n    39,  7, 47, 15, 55, 23, 63, 31, \n    38,  6, 46, 14, 54, 22, 62, 30, \n    37,  5, 45, 13, 53, 21, 61, 29, \n    36,  4, 44, 12, 52, 20, 60, 28, \n    35,  3, 43, 11, 51, 19, 59, 27, \n    34,  2, 42, 10, 50, 18, 58, 26, \n    33,  1, 41,  9, 49, 17, 57, 25\n};\n\n/*Expansion table */\nstatic char E[] = {\n    32,  1,  2,  3,  4,  5,  \n     4,  5,  6,  7,  8,  9,  \n     8,  9, 10, 11, 12, 13, \n    12, 13, 14, 15, 16, 17, \n    16, 17, 18, 19, 20, 21, \n    20, 21, 22, 23, 24, 25, \n    24, 25, 26, 27, 28, 29, \n    28, 29, 30, 31, 32,  1\n};\n\n/* Post S-Box permutation */\nstatic char P[] = {\n    16,  7, 20, 21, \n    29, 12, 28, 17, \n     1, 15, 23, 26, \n     5, 18, 31, 10, \n     2,  8, 24, 14, \n    32, 27,  3,  9, \n    19, 13, 30,  6, \n    22, 11,  4, 25\n};\n\n/* The S-Box tables */\nstatic char S[8][64] = {{\n    /* S1 */\n    14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,  \n     0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,  \n     4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0, \n    15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13\n},{\n    /* S2 */\n    15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,  \n     3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,  \n     0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15, \n    13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9\n},{\n    /* S3 */\n    10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,  \n    13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,  \n    13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,\n     1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12\n},{\n    /* S4 */\n     7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,  \n    13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,  \n    10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,\n     3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14\n},{\n    /* S5 */\n     2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9, \n    14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6, \n     4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14, \n    11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3\n},{\n    /* S6 */\n    12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,\n    10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,\n     9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,\n     4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13\n},{\n    /* S7 */\n     4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,\n    13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,\n     1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,\n     6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12\n},{\n    /* S8 */\n    13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,\n     1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,\n     7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,\n     2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11\n}};\n\n/* Permuted Choice 1 Table */\nstatic char PC1[] = {\n    57, 49, 41, 33, 25, 17,  9,\n     1, 58, 50, 42, 34, 26, 18,\n    10,  2, 59, 51, 43, 35, 27,\n    19, 11,  3, 60, 52, 44, 36,\n    \n    63, 55, 47, 39, 31, 23, 15,\n     7, 62, 54, 46, 38, 30, 22,\n    14,  6, 61, 53, 45, 37, 29,\n    21, 13,  5, 28, 20, 12,  4\n};\n\n/* Permuted Choice 2 Table */\nstatic char PC2[] = {\n    14, 17, 11, 24,  1,  5,\n     3, 28, 15,  6, 21, 10,\n    23, 19, 12,  4, 26,  8,\n    16,  7, 27, 20, 13,  2,\n    41, 52, 31, 37, 47, 55,\n    30, 40, 51, 45, 33, 48,\n    44, 49, 39, 56, 34, 53,\n    46, 42, 50, 36, 29, 32\n};\n\n/* Iteration Shift Array */\nstatic char iteration_shift[] = {\n /* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */\n    1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1\n};\n\n/*\n * The DES function\n * input: 64 bit message\n * key: 64 bit key for encryption/decryption\n * mode: 'e' = encryption; 'd' = decryption\n */\nuint64_t des(uint64_t input, uint64_t key, char mode) {\n    \n    int i, j;\n    \n    /* 8 bits */\n    char row, column;\n    \n    /* 28 bits */\n    uint32_t C                  = 0;\n    uint32_t D                  = 0;\n    \n    /* 32 bits */\n    uint32_t L                  = 0;\n    uint32_t R                  = 0;\n    uint32_t s_output           = 0;\n    uint32_t f_function_res     = 0;\n    uint32_t temp               = 0;\n    \n    /* 48 bits */\n    uint64_t sub_key[16]        = {0};\n    uint64_t s_input            = 0;\n    \n    /* 56 bits */\n    uint64_t permuted_choice_1  = 0;\n    uint64_t permuted_choice_2  = 0;\n    \n    /* 64 bits */\n    uint64_t init_perm_res      = 0;\n    uint64_t inv_init_perm_res  = 0;\n    uint64_t pre_output         = 0;\n    \n    /* initial permutation */\n    for (i = 0; i < 64; i++) {\n        \n        init_perm_res <<= 1;\n        init_perm_res |= (input >> (64-IP[i])) & LB64_MASK;\n        \n    }\n    \n    L = (uint32_t) (init_perm_res >> 32) & L64_MASK;\n    R = (uint32_t) init_perm_res & L64_MASK;\n        \n    /* initial key schedule calculation */\n    for (i = 0; i < 56; i++) {\n        \n        permuted_choice_1 <<= 1;\n        permuted_choice_1 |= (key >> (64-PC1[i])) & LB64_MASK;\n\n    }\n    \n    C = (uint32_t) ((permuted_choice_1 >> 28) & 0x000000000fffffff);\n    D = (uint32_t) (permuted_choice_1 & 0x000000000fffffff);\n    \n    /* Calculation of the 16 keys */\n    for (i = 0; i< 16; i++) {\n        \n        /* key schedule */\n        // shifting Ci and Di\n        for (j = 0; j < iteration_shift[i]; j++) {\n            \n            C = 0x0fffffff & (C << 1) | 0x00000001 & (C >> 27);\n            D = 0x0fffffff & (D << 1) | 0x00000001 & (D >> 27);\n            \n        }\n        \n        permuted_choice_2 = 0;\n        permuted_choice_2 = (((uint64_t) C) << 28) | (uint64_t) D ;\n        \n        sub_key[i] = 0;\n        \n        for (j = 0; j < 48; j++) {\n            \n            sub_key[i] <<= 1;\n            sub_key[i] |= (permuted_choice_2 >> (56-PC2[j])) & LB64_MASK;\n            \n        }\n        \n    }\n    \n    for (i = 0; i < 16; i++) {\n        \n        /* f(R,k) function */\n        s_input = 0;\n        \n        for (j = 0; j< 48; j++) {\n            \n            s_input <<= 1;\n            s_input |= (uint64_t) ((R >> (32-E[j])) & LB32_MASK);\n            \n        }\n        \n        /* \n         * Encryption/Decryption \n         * XORing expanded Ri with Ki\n         */\n        if (mode == 'd') {\n            // decryption\n            s_input = s_input ^ sub_key[15-i];\n            \n        } else {\n            // encryption\n            s_input = s_input ^ sub_key[i];\n            \n        }\n        \n        /* S-Box Tables */\n        for (j = 0; j < 8; j++) {\n            // 00 00 RCCC CR00 00 00 00 00 00 s_input\n            // 00 00 1000 0100 00 00 00 00 00 row mask\n            // 00 00 0111 1000 00 00 00 00 00 column mask\n            \n            row = (char) ((s_input & (0x0000840000000000 >> 6*j)) >> 42-6*j);\n            row = (row >> 4) | row & 0x01;\n            \n            column = (char) ((s_input & (0x0000780000000000 >> 6*j)) >> 43-6*j);\n            \n            s_output <<= 4;\n            s_output |= (uint32_t) (S[j][16*row + column] & 0x0f);\n            \n        }\n        \n        f_function_res = 0;\n        \n        for (j = 0; j < 32; j++) {\n            \n            f_function_res <<= 1;\n            f_function_res |= (s_output >> (32 - P[j])) & LB32_MASK;\n            \n        }\n        \n        temp = R;\n        R = L ^ f_function_res;\n        L = temp;\n        \n    }\n    \n    pre_output = (((uint64_t) R) << 32) | (uint64_t) L;\n        \n    /* inverse initial permutation */\n    for (i = 0; i < 64; i++) {\n        \n        inv_init_perm_res <<= 1;\n        inv_init_perm_res |= (pre_output >> (64-PI[i])) & LB64_MASK;\n        \n    }\n    \n    return inv_init_perm_res;\n    \n}\n```\n编译出来，直接使用IDA静态分析\n{% asset_img des_2.jpg %}\n{% asset_img des_3.jpg %}\n总结一下识别DES的关键特征：有S盒或IP表等数组，可高度怀疑使用了DES算法\n## Reference\nhttps://blog.csdn.net/u014316433/article/details/26342437\nhttps://blog.csdn.net/a745233700/article/details/102315531\nhttps://www.cnblogs.com/idreamo/p/9333753.html","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之AES","url":"/2017/05/06/算法识别之AES/","content":"\n## AES算法简介\nAES的全称是Advanced Encryption Standard，意思是高级加密标准。 AES密码分组大小和密钥大小可以为128位、192位和256位。然而AES只要求分组大小为128位。本文只对分组大小128位，密钥长度也为128位的Rijndael算法进行分析。密钥长度为192位和256位的处理方式和128位的处理方式类似，只不过密钥长度每增加64位，算法的循环次数就增加2轮，128位循环10轮、192位循环12轮、256位循环14轮。\n\n## AES算法原理\nAES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度，暂时不考虑)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。AES算法在处理的轮数上只有最后一轮操作与前面的轮处理上有些许不同(最后一轮只是少了列混淆处理)，在轮处理开始前还单独进行了一次轮密钥加的处理。在处理轮数上，我们只考虑128位密钥的10轮处理。接下来，就开始一步步的介绍AES算法的处理流程了。\n\nAES加密算法流程\n{% asset_img aes_1.png %}\n\n轮密钥加(Add Round Key)\n在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。k[0]实际上就等同于密钥k，具体原因在密钥扩展生成中进行介绍。我们前面在介绍扩展域加减法中提到过，在扩展域中加减法操作和异或运算等价，所以这里的处理也就异常的简单了，只需要将两个输入的数据进行按字节异或操作就会得到运算的结果。\n{% asset_img aes_2.png %}\n\n字节代换(SubByte)\n字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，这里的S_box表是通过某种方法计算出来的，具体的计算方法在此不做详述，我们主需要知道如何使用S_box结果即可。S_box表是一个拥有256个字节元素的数组，可以将其定义为一维数组，也可以将其定义为16·16的二维数组，如果将其定义为二维数组，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标，略有点麻烦。这里建议将其视作一维数组即可。逆S盒与S盒对应，用于解密时对数据处理，我们对解密时的程序处理称作逆字节代换，只是使用的代换表盒加密时不同而已。\nS盒\n{% asset_img aes_3.png %}\n逆S盒\n{% asset_img aes_4.png %}\n加密图示：\n{% asset_img aes_5.png %}\n\n行移位(ShiftRows)\n行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到雪崩效应。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。\n加密时：保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。\n解密时：保持矩阵的第一行不变，第二行向右移动8Bit(一个字节)、第三行向右移动2个字节、第四行向右移动3个字节。\n正向行位移图解:\n{% asset_img aes_6.png %}\n逆向行位移图解\n{% asset_img aes_7.png %}\n\n列混淆(MixColumn)\n列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。\n在加密的正向列混淆中，我们要将输入的4·4矩阵左乘一个给定的4·4矩阵。而它们之间的加法、乘法都在扩展域GF(28)中进行，所以也就可以将这一个步骤分成两个部分进行讲解：\n1) 正向列混淆\n    正向列混淆的原理图如下：\n    {% asset_img aes_8.png %}\n    根据矩阵的乘法可知，在列混淆的过程中，每个字节对应的值只与该列的4个值有关系。此处的乘法和加法都是定义在GF(28)上的，需要注意如下几点：\n　　1) 将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011；\n　　2) 乘法对加法满足分配率，例如：07·S0,0=(01⊕02⊕04)·S0,0= S0,0⊕(02·S0,0)(04·S0,0)\n　　3) 此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模28加法（异或运算）。\n\n2) 逆向列混淆\n    逆向列混淆的原理图如下：\n    {% asset_img aes_9.png %}\n    由于：\n    {% asset_img aes_10.png %}\n    说明两个矩阵互逆，经过一次逆向列混淆后即可恢复原文。\n\n正向列混淆处理\n{% asset_img aes_11.png %}\n逆向列混淆\n{% asset_img aes_12.png %}\n加解密验证\n{% asset_img aes_13.png %}\n\nAES密钥扩展\n{% asset_img aes_14.png %}\n\n子密钥的生成是以列为单位进行的，一列是32Bit，四列组成子密钥共128Bit。生成子密钥的数量比AES算法的轮数多一个，因为第一个密钥加法层进行密钥漂白时也需要子密钥。密钥漂白是指在AES的输入盒输出中都使用的子密钥的XOR加法。子密钥在图中都存储在W[0]、W[1]、...、W[43]的扩展密钥数组之中。k1-k16表示原始密钥对应的字节，而图中子密钥k0与原始子密钥相同。在生成的扩展密钥中W的下标如果是4的倍数时(从零开始)需要对异或的参数进行G函数处理。扩展密钥生成有关公式如下：\n```\n1<= i <= 10\n1<= j <= 3\nw[4i]     = W[4(i-1)] + G(W[4i-1]);\nw[4i+j]   = W[4(i-1)+j] + W[4i-1+j];\n```\n{% asset_img aes_15.png %}\n\n函数G()首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。轮系数是一个有10个元素的一维数组，一个元素1个字节。G()函数存在的目的有两个，一是增加密钥编排中的非线性；二是消除AES中的对称性。这两种属性都是抵抗某些分组密码攻击必要的。\n\nAES解密流程图\n{% asset_img aes_16.png %}\n至此，AES算法基础部分介绍完毕！\n以上内容完全摘抄自大佬博客，复杂的部分没有添加，有需要的小伙伴直接去大佬博客学习吧。\n\n## 实例分析\nAES C实现源码\n```c\n/**\n * S盒\n */\nstatic const int S[16][16] = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };\n\n/**\n * 逆S盒\n */\nstatic const int S2[16][16] = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n\t0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n\t0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n\t0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n\t0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n\t0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n\t0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n\t0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n\t0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n\t0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n\t0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n\t0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n\t0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n\t0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n\t0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n\t0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };\n\n/**\n * 获取整形数据的低8位的左4个位\n */\nstatic int getLeft4Bit(int num) {\n\tint left = num & 0x000000f0;\n\treturn left >> 4;\n}\n\n/**\n * 获取整形数据的低8位的右4个位\n */\nstatic int getRight4Bit(int num) {\n\treturn num & 0x0000000f;\n}\n/**\n * 根据索引，从S盒中获得元素\n */\nstatic int getNumFromSBox(int index) {\n\tint row = getLeft4Bit(index);\n\tint col = getRight4Bit(index);\n\treturn S[row][col];\n}\n\n/**\n * 把一个字符转变成整型\n */\nstatic int getIntFromChar(char c) {\n\tint result = (int) c;\n\treturn result & 0x000000ff;\n}\n\n/**\n * 把16个字符转变成4X4的数组，\n * 该矩阵中字节的排列顺序为从上到下，\n * 从左到右依次排列。\n */\nstatic void convertToIntArray(char *str, int pa[4][4]) {\n\tint k = 0;\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tpa[j][i] = getIntFromChar(str[k]);\n\t\t\tk++;\n\t\t}\n}\n\n/**\n * 打印4X4的数组\n */\nstatic void printArray(int a[4][4]) {\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tprintf(\"a[%d][%d] = 0x%x \", i, j, a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n/**\n * 打印字符串的ASSCI，\n * 以十六进制显示。\n */\nstatic void printASSCI(char *str, int len) {\n\tfor(int i = 0; i < len; i++)\n\t\tprintf(\"0x%x \", getIntFromChar(str[i]));\n\tprintf(\"\\n\");\n}\n\n/**\n * 把连续的4个字符合并成一个4字节的整型\n */\nstatic int getWordFromStr(char *str) {\n\tint one = getIntFromChar(str[0]);\n\tone = one << 24;\n\tint two = getIntFromChar(str[1]);\n\ttwo = two << 16;\n\tint three = getIntFromChar(str[2]);\n\tthree = three << 8;\n\tint four = getIntFromChar(str[3]);\n\treturn one | two | three | four;\n}\n\n/**\n * 把一个4字节的数的第一、二、三、四个字节取出，\n * 入进一个4个元素的整型数组里面。\n */\nstatic void splitIntToArray(int num, int array[4]) {\n\tint one = num >> 24;\n\tarray[0] = one & 0x000000ff;\n\tint two = num >> 16;\n\tarray[1] = two & 0x000000ff;\n\tint three = num >> 8;\n\tarray[2] = three & 0x000000ff;\n\tarray[3] = num & 0x000000ff;\n}\n\n/**\n * 将数组中的元素循环左移step位\n */\nstatic void leftLoop4int(int array[4], int step) {\n\tint temp[4];\n\tfor(int i = 0; i < 4; i++)\n\t\ttemp[i] = array[i];\n\n\tint index = step % 4 == 0 ? 0 : step % 4;\n\tfor(int i = 0; i < 4; i++){\n\t\tarray[i] = temp[index];\n\t\tindex++;\n\t\tindex = index % 4;\n\t}\n}\n\n/**\n * 把数组中的第一、二、三和四元素分别作为\n * 4字节整型的第一、二、三和四字节，合并成一个4字节整型\n */\nstatic int mergeArrayToInt(int array[4]) {\n\tint one = array[0] << 24;\n\tint two = array[1] << 16;\n\tint three = array[2] << 8;\n\tint four = array[3];\n\treturn one | two | three | four;\n}\n\n/**\n * 常量轮值表\n */\nstatic const int Rcon[10] = { 0x01000000, 0x02000000,\n\t0x04000000, 0x08000000,\n\t0x10000000, 0x20000000,\n\t0x40000000, 0x80000000,\n\t0x1b000000, 0x36000000 };\n/**\n * 密钥扩展中的T函数\n */\nstatic int T(int num, int round) {\n\tint numArray[4];\n\tsplitIntToArray(num, numArray);\n\tleftLoop4int(numArray, 1);//字循环\n\n\t//字节代换\n\tfor(int i = 0; i < 4; i++)\n\t\tnumArray[i] = getNumFromSBox(numArray[i]);\n\n\tint result = mergeArrayToInt(numArray);\n\treturn result ^ Rcon[round];\n}\n\n//密钥对应的扩展数组\nstatic int w[44];\n\n/**\n * 扩展密钥，结果是把w[44]中的每个元素初始化\n */\nstatic void extendKey(char *key) {\n\tfor(int i = 0; i < 4; i++)\n\t\tw[i] = getWordFromStr(key + i * 4);\n\n\tfor(int i = 4, j = 0; i < 44; i++) {\n\t\tif( i % 4 == 0) {\n\t\t\tw[i] = w[i - 4] ^ T(w[i - 1], j);\n\t\t\tj++;//下一轮\n\t\t}else {\n\t\t\tw[i] = w[i - 4] ^ w[i - 1];\n\t\t}\n\t}\n\n}\n\n/**\n * 轮密钥加\n */\nstatic void addRoundKey(int array[4][4], int round) {\n\tint warray[4];\n\tfor(int i = 0; i < 4; i++) {\n\n\t\tsplitIntToArray(w[ round * 4 + i], warray);\n\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tarray[j][i] = array[j][i] ^ warray[j];\n\t\t}\n\t}\n}\n\n/**\n * 字节代换\n */\nstatic void subBytes(int array[4][4]){\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tarray[i][j] = getNumFromSBox(array[i][j]);\n}\n\n/**\n * 行移位\n */\nstatic void shiftRows(int array[4][4]) {\n\tint rowTwo[4], rowThree[4], rowFour[4];\n\t//复制状态矩阵的第2,3,4行\n\tfor(int i = 0; i < 4; i++) {\n\t\trowTwo[i] = array[1][i];\n\t\trowThree[i] = array[2][i];\n\t\trowFour[i] = array[3][i];\n\t}\n\t//循环左移相应的位数\n\tleftLoop4int(rowTwo, 1);\n\tleftLoop4int(rowThree, 2);\n\tleftLoop4int(rowFour, 3);\n\n\t//把左移后的行复制回状态矩阵中\n\tfor(int i = 0; i < 4; i++) {\n\t\tarray[1][i] = rowTwo[i];\n\t\tarray[2][i] = rowThree[i];\n\t\tarray[3][i] = rowFour[i];\n\t}\n}\n\n/**\n * 列混合要用到的矩阵\n */\nstatic const int colM[4][4] = { 2, 3, 1, 1,\n\t1, 2, 3, 1,\n\t1, 1, 2, 3,\n\t3, 1, 1, 2 };\n\nstatic int GFMul2(int s) {\n\tint result = s << 1;\n\tint a7 = result & 0x00000100;\n\n\tif(a7 != 0) {\n\t\tresult = result & 0x000000ff;\n\t\tresult = result ^ 0x1b;\n\t}\n\n\treturn result;\n}\n\nstatic int GFMul3(int s) {\n\treturn GFMul2(s) ^ s;\n}\n\nstatic int GFMul4(int s) {\n\treturn GFMul2(GFMul2(s));\n}\n\nstatic int GFMul8(int s) {\n\treturn GFMul2(GFMul4(s));\n}\n\nstatic int GFMul9(int s) {\n\treturn GFMul8(s) ^ s;\n}\n\nstatic int GFMul11(int s) {\n\treturn GFMul9(s) ^ GFMul2(s);\n}\n\nstatic int GFMul12(int s) {\n\treturn GFMul8(s) ^ GFMul4(s);\n}\n\nstatic int GFMul13(int s) {\n\treturn GFMul12(s) ^ s;\n}\n\nstatic int GFMul14(int s) {\n\treturn GFMul12(s) ^ GFMul2(s);\n}\n\n/**\n * GF上的二元运算\n */\nstatic int GFMul(int n, int s) {\n\tint result;\n\n\tif(n == 1)\n\t\tresult = s;\n\telse if(n == 2)\n\t\tresult = GFMul2(s);\n\telse if(n == 3)\n\t\tresult = GFMul3(s);\n\telse if(n == 0x9)\n\t\tresult = GFMul9(s);\n\telse if(n == 0xb)//11\n\t\tresult = GFMul11(s);\n\telse if(n == 0xd)//13\n\t\tresult = GFMul13(s);\n\telse if(n == 0xe)//14\n\t\tresult = GFMul14(s);\n\n\treturn result;\n}\n/**\n * 列混合\n */\nstatic void mixColumns(int array[4][4]) {\n\n\tint tempArray[4][4];\n\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\ttempArray[i][j] = array[i][j];\n\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tarray[i][j] = GFMul(colM[i][0],tempArray[0][j]) ^ GFMul(colM[i][1],tempArray[1][j]) \n\t\t\t\t^ GFMul(colM[i][2],tempArray[2][j]) ^ GFMul(colM[i][3], tempArray[3][j]);\n\t\t}\n}\n/**\n * 把4X4数组转回字符串\n */\nstatic void convertArrayToStr(int array[4][4], char *str) {\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\t*str++ = (char)array[j][i];\t\n}\n/**\n * 检查密钥长度\n */\nstatic int checkKeyLen(int len) {\n\tif(len == 16)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * 参数 p: 明文的字符串数组。\n * 参数 plen: 明文的长度。\n * 参数 key: 密钥的字符串数组。\n */\nvoid aes(char *p, int plen, char *key){\n\n\tint keylen = strlen(key);\n\tif(plen == 0 || plen % 16 != 0) {\n\t\tprintf(\"明文字符长度必须为16的倍数！\\n\");\n\t\texit(0);\n\t}\n\n\tif(!checkKeyLen(keylen)) {\n\t\tprintf(\"密钥字符长度错误！长度必须为16、24和32。当前长度为%d\\n\",keylen);\n\t\texit(0);\n\t}\n\n\textendKey(key);//扩展密钥\n\tint pArray[4][4];\n\n\tfor(int k = 0; k < plen; k += 16) {\t\n\t\tconvertToIntArray(p + k, pArray);\n\n\t\taddRoundKey(pArray, 0);//一开始的轮密钥加\n\n\t\tfor(int i = 1; i < 10; i++){//前9轮\n\t\t\tsubBytes(pArray);//字节代换\n\t\t\tshiftRows(pArray);//行移位\n\t\t\tmixColumns(pArray);//列混合\n\t\t\taddRoundKey(pArray, i);\n\n\t\t}\n\n\t\t//第10轮\n\t\tsubBytes(pArray);//字节代换\n\t\tshiftRows(pArray);//行移位\n\t\taddRoundKey(pArray, 10);\n\t\tconvertArrayToStr(pArray, p + k);\n\t}\n}\n/**\n * 根据索引从逆S盒中获取值\n */\nstatic int getNumFromS1Box(int index) {\n\tint row = getLeft4Bit(index);\n\tint col = getRight4Bit(index);\n\treturn S2[row][col];\n}\n/**\n * 逆字节变换\n */\nstatic void deSubBytes(int array[4][4]) {\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tarray[i][j] = getNumFromS1Box(array[i][j]);\n}\n/**\n * 把4个元素的数组循环右移step位\n */\nstatic void rightLoop4int(int array[4], int step) {\n\tint temp[4];\n\tfor(int i = 0; i < 4; i++)\n\t\ttemp[i] = array[i];\n\n\tint index = step % 4 == 0 ? 0 : step % 4;\n\tindex = 3 - index;\n\tfor(int i = 3; i >= 0; i--) {\n\t\tarray[i] = temp[index];\n\t\tindex--;\n\t\tindex = index == -1 ? 3 : index;\n\t}\n}\n\n/**\n * 逆行移位\n */\nstatic void deShiftRows(int array[4][4]) {\n\tint rowTwo[4], rowThree[4], rowFour[4];\n\tfor(int i = 0; i < 4; i++) {\n\t\trowTwo[i] = array[1][i];\n\t\trowThree[i] = array[2][i];\n\t\trowFour[i] = array[3][i];\n\t}\n\n\trightLoop4int(rowTwo, 1);\n\trightLoop4int(rowThree, 2);\n\trightLoop4int(rowFour, 3);\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tarray[1][i] = rowTwo[i];\n\t\tarray[2][i] = rowThree[i];\n\t\tarray[3][i] = rowFour[i];\n\t}\n}\n/**\n * 逆列混合用到的矩阵\n */\nstatic const int deColM[4][4] = { 0xe, 0xb, 0xd, 0x9,\n\t0x9, 0xe, 0xb, 0xd,\n\t0xd, 0x9, 0xe, 0xb,\n\t0xb, 0xd, 0x9, 0xe };\n\n/**\n * 逆列混合\n */\nstatic void deMixColumns(int array[4][4]) {\n\tint tempArray[4][4];\n\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\ttempArray[i][j] = array[i][j];\n\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tarray[i][j] = GFMul(deColM[i][0],tempArray[0][j]) ^ GFMul(deColM[i][1],tempArray[1][j]) \n\t\t\t\t^ GFMul(deColM[i][2],tempArray[2][j]) ^ GFMul(deColM[i][3], tempArray[3][j]);\n\t\t}\n}\n/**\n * 把两个4X4数组进行异或\n */\nstatic void addRoundTowArray(int aArray[4][4],int bArray[4][4]) {\n\tfor(int i = 0; i < 4; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\taArray[i][j] = aArray[i][j] ^ bArray[i][j];\n}\n/**\n * 从4个32位的密钥字中获得4X4数组，\n * 用于进行逆列混合\n */\nstatic void getArrayFrom4W(int i, int array[4][4]) {\n\tint index = i * 4;\n\tint colOne[4], colTwo[4], colThree[4], colFour[4];\n\tsplitIntToArray(w[index], colOne);\n\tsplitIntToArray(w[index + 1], colTwo);\n\tsplitIntToArray(w[index + 2], colThree);\n\tsplitIntToArray(w[index + 3], colFour);\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tarray[i][0] = colOne[i];\n\t\tarray[i][1] = colTwo[i];\n\t\tarray[i][2] = colThree[i];\n\t\tarray[i][3] = colFour[i];\n\t}\n\n}\n\n/**\n * 参数 c: 密文的字符串数组。\n * 参数 clen: 密文的长度。\n * 参数 key: 密钥的字符串数组。\n */\nvoid deAes(char *c, int clen, char *key) {\n\n\tint keylen = strlen(key);\n\tif(clen == 0 || clen % 16 != 0) {\n\t\tprintf(\"密文字符长度必须为16的倍数！现在的长度为%d\\n\",clen);\n\t\texit(0);\n\t}\n\n\tif(!checkKeyLen(keylen)) {\n\t\tprintf(\"密钥字符长度错误！长度必须为16、24和32。当前长度为%d\\n\",keylen);\n\t\texit(0);\n\t}\n\n\textendKey(key);//扩展密钥\n\tint cArray[4][4];\n\tfor(int k = 0; k < clen; k += 16) {\n\t\tconvertToIntArray(c + k, cArray);\n\t\taddRoundKey(cArray, 10);\n\t\tint wArray[4][4];\n\t\tfor(int i = 9; i >= 1; i--) {\n\t\t\tdeSubBytes(cArray);\n\t\t\tdeShiftRows(cArray);\n\t\t\tdeMixColumns(cArray);\n\t\t\tgetArrayFrom4W(i, wArray);\n\t\t\tdeMixColumns(wArray);\n\n\t\t\taddRoundTowArray(cArray, wArray);\n\t\t}\n\t\tdeSubBytes(cArray);\n\t\tdeShiftRows(cArray);\n\t\taddRoundKey(cArray, 0);\n\t\tconvertArrayToStr(cArray, c + k);\n\t}\n}\n\n```\n编译出来，直接使用IDA静态分析\n{% asset_img aes_17.jpg %}\n{% asset_img aes_18.jpg %}\n总结一下识别AES的关键特征：有S盒/逆S盒或者Rcon等数组，可高度怀疑使用了AES算法\n\n## Update\n查表法实现AES，参考xhs shield\n\n## Reference\nhttps://blog.csdn.net/qq_28205153/article/details/55798628\nhttps://www.cnblogs.com/chenshikun/p/11667438.html","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之RC6","url":"/2017/03/23/算法识别之RC6/","content":"\n## RC6算法简介\n\nRC6是作为AES(Advanced Encryption Standard)的候选算法提交给NIST（美国国家标准局）的一种新的分组密码。它是在RC5的基础上设计的，以更好地符合AES的要求，且提高了安全性，增强了性能。\n\nRC6分组长度为128bit，使用了4个寄存器，并使用32bit的整数模乘运算，用于加强扩散特性。RC6更精确的表示是RC6-w/r/b，其中字长为w bit，r为加密轮数，b为加密密钥用字节表示的长度。通常令w=32，r=20，b=16(24,32)。\n\n密钥扩展方案，在密钥扩展中用到两个常数P、Q，P=0xB7E15163，Q=0x9E3779B9\n首先，将用户密钥输入到c个w比特字的L[0],...,L[c-1]阵列，若不够，用0字节填充，其中c为8b/w的整数部分\n```\nS[0]=P\nfor i=1 to 2r+3 do\n  S[i]=S[i-1]+Q\n用户密钥混合到S中\nA=B=i=j=0\nv=3*max{c,2r+4}\nfor s=1 to v do循环体循环v次\n  A=S[i]=ROL(S[i]+A+B,3)\n  B=L[j]=ROL(L[j]+A+B,A+B)\n  i=(i+1)mod(2r+4)\n  j=(j+1)mod c\n输出S[0],S[1],...,S[2r+3]即为子密钥\n```\n\n加密过程，把128bit明文放入4个32bit的寄存器A、B、C、D中\n```\nB=B+S[0] (S为密钥)\nD=D+S[1]\nfor i=1 to r do\n  t=ROL(B*(2B+1),log2w)\n  u=ROL(D*(2D+1),log2w)\n  A=ROL(A⊕t,u)+S[2i]\n  C=ROL(C⊕u,t)+S[2i+1]\n  (A,B,C,D)=(B,C,D,A)\nA=A+S[2r+2]\nC=C+S[2r+3]\nA、B、C、D即为密文\n```\n\n解密过程，把128bit密文放入4个32bit的寄存器A、B、C、D中\n```\nC=C-S[2r+3]\nA=A-S[2r+2]\nfor i=r down to 1 do\n  (A,B,C,D)=(D,A,B,C)\n  u=ROL(D*(2D+1),log2w)\n  t=ROL(B*(2B+1),log2w)\n  C=ROR(C-S[2i+1],t)⊕u\n  A=ROR(A-S[2i],u)⊕t\nD=D-S[1]\nB=B-S[0]\nA、B、C、D即为明文\n```\n\n## 实例分析\nC实现源码\n```c\n#define w 32    /* word为32bits */\n#define r 20    //加密轮数\n\n#define P32 0xB7E15163 /* 定义两个常量，用于子密钥生成 */\n#define Q32 0x9E3779B9\n\n#define bytes   (w / 8)                        /* 定义字节*/\n#define c       ((b + bytes - 1) / bytes)      /* 密钥字数 */\n#define R24     (2 * r + 4)\n#define lgw     5                           /* log2(w)  */\n\n/* 定义逻辑移位操作运算 */\n#define ROTL(x,y) (((x)<<(y&(w-1))) | ((x)>>(w-(y&(w-1)))))\n#define ROTR(x,y) (((x)>>(y&(w-1))) | ((x)<<(w-(y&(w-1)))))\n\nunsigned int S[R24 - 1];                    /* 子密钥组 */\n\nvoid rc6_key_setup(unsigned char *K, int b)\n{\n    int i, j, s, v;\n    unsigned int L[(32 + bytes - 1) / bytes]; /* Big enough for max b */\n    unsigned int A, B;\n\n    L[c - 1] = 0;\n    for (i = b - 1; i >= 0; i--)\n        L[i / bytes] = (L[i / bytes] << 8) + K[i];\n\n    S[0] = P32;\n    for (i = 1; i <= 2 * r + 3; i++)\n        S[i] = S[i - 1] + Q32;\n\n    A = B = i = j = 0;\n    v = R24;\n    if (c > v) v = c;\n    v *= 3;\n\n    for (s = 1; s <= v; s++)\n    {\n        A = S[i] = ROTL(S[i] + A + B, 3);\n        B = L[j] = ROTL(L[j] + A + B, A + B);\n        i = (i + 1) % R24;\n        j = (j + 1) % c;\n    }\n}\n\nvoid rc6_block_encrypt(unsigned int *pt, unsigned int *ct)\n{\n    unsigned int A, B, C, D, t, u, x;\n    int i;\n\n    A = pt[0];\n    B = pt[1];\n    C = pt[2];\n    D = pt[3];\n    B += S[0];\n    D += S[1];\n    for (i = 2; i <= 2 * r; i += 2)\n    {\n        t = ROTL(B * (2 * B + 1), lgw);\n        u = ROTL(D * (2 * D + 1), lgw);\n        A = ROTL(A ^ t, u) + S[i];\n        C = ROTL(C ^ u, t) + S[i + 1];\n        x = A;\n        A = B;\n        B = C;\n        C = D;\n        D = x;\n    }\n    A += S[2 * r + 2];\n    C += S[2 * r + 3];\n    ct[0] = A;\n    ct[1] = B;\n    ct[2] = C;\n    ct[3] = D;\n}\n\nvoid rc6_block_decrypt(unsigned int *ct, unsigned int *pt)\n{\n    unsigned int A, B, C, D, t, u, x;\n    int i;\n\n    A = ct[0];\n    B = ct[1];\n    C = ct[2];\n    D = ct[3];\n    C -= S[2 * r + 3];\n    A -= S[2 * r + 2];\n    for (i = 2 * r; i >= 2; i -= 2)\n    {\n        x = D;\n        D = C;\n        C = B;\n        B = A;\n        A = x;\n        u = ROTL(D * (2 * D + 1), lgw);\n        t = ROTL(B * (2 * B + 1), lgw);\n        C = ROTR(C - S[i + 1], t) ^ u;\n        A = ROTR(A - S[i], u) ^ t;\n    }\n    D -= S[1];\n    B -= S[0];\n    pt[0] = A;\n    pt[1] = B;\n    pt[2] = C;\n    pt[3] = D;\n}\n\n```\n编译出来，直接使用IDA静态分析\n{% asset_img rc6_1.jpg %}\n使用findcrypt搜索一下当前bin中可能使用的算法\n{% asset_img rc6_2.jpg %}\n总结一下识别RC6的关键特征：初始化函数中有常数0xb7e15163和0x9e3779b9\n\n","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之RC4","url":"/2017/03/22/算法识别之RC4/","content":"\n## RC4算法简介\nRC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，以达到加密的目的，解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。\n 1. KSA (the Key-Scheduling Algorithm)\n    RC4首先使用密钥调度算法(KSA)完成对大小为256字节的数组S的初始化及替换，在替换时使用密钥。其密钥的长度一般取5-16字节，即40-128位，也可以更长，通常不超过256位。先用0~255初始化数组S,然后使用密钥进行替换，伪代码如下。\n    ```\n    for i = 0 to 255 do\n      S[i] := i;\n    j := 0;\n    for i = 0 to 255 do\n      j := (j + s[i] + key[i mod keylength]) mod 256; //重复使用密钥\n      Swap(s[i],S[j]); //交换s[i]与S[j]\n    ```\n 2. PRGA (the Pseudo-Random Generation Algorithm)\n    数组S在完成初始化之后，便不再使用输人的密钥。密钥流的生成是从S0]到S[255]的。对每个S[i],根据当前S的值，将S[i]与S中的另一字节置换。在S[255]完成转换后，操作仍重复执行。\n    伪代码如下。\n    ```\n    i,j = 0;\n    while(明文未结束)\n      i = (i+1) mod 256;\n      j = (j + S[i]) mod 256;\n      Swpa(S[i],S[j]);\n      t = (S[i] + S[j]) mod 256;\n      k = S[t];\n    ```\n    得到的子密码k用于和明文进行XOR运算，得到密文。解密过程也完全相同。由于RC4算法在加密时采用的是XOR运算，一旦子密钥序列出现了重复，密文就有可能被破解。因此，在使用RC4算法时，必须对加密密钥进行测试，以判断其是否为弱密钥。\n    \n## 实例分析\n\nC实现源码\n```c\n#define N 256   // 2^8\n\nvoid swap(unsigned char *a, unsigned char *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint KSA(char *key, unsigned char *S) {\n\n    int len = strlen(key);\n    int j = 0;\n\n    for(int i = 0; i < N; i++)\n        S[i] = i;\n\n    for(int i = 0; i < N; i++) {\n        j = (j + S[i] + key[i % len]) % N;\n\n        swap(&S[i], &S[j]);\n    }\n\n    return 0;\n}\n\nint PRGA(unsigned char *S, char *plaintext, unsigned char *ciphertext) {\n\n    int i = 0;\n    int j = 0;\n\n    for(size_t n = 0, len = strlen(plaintext); n < len; n++) {\n        i = (i + 1) % N;\n        j = (j + S[i]) % N;\n\n        swap(&S[i], &S[j]);\n        int rnd = S[(S[i] + S[j]) % N];\n\n        ciphertext[n] = rnd ^ plaintext[n];\n\n    }\n\n    return 0;\n}\n\nint RC4(char *key, char *plaintext, unsigned char *ciphertext) {\n\n    unsigned char S[N];\n    KSA(key, S);\n\n    PRGA(S, plaintext, ciphertext);\n\n    return 0;\n}\n```\n编译出来，直接使用IDA静态分析\n{% asset_img rc4_1.jpg %}\n{% asset_img rc4_2.jpg %}\n总结一下识别RC4的关键特征：KSA和PRGA过程中的循环，如看见图中高度相似的代码可怀疑使用了RC4算法","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之CRC","url":"/2016/12/16/算法识别之CRC/","content":"\nCRC的识别比较简单了。\n\n```c\nunsigned long table[256];\n//位逆转  \nstatic unsigned long bitrev(unsigned long input, int bw)\n{\n    int i;\n    unsigned long var;\n    var = 0;\n    for (i = 0; i < bw; i++)\n    {\n        if (input & 0x01)\n        {\n            var |= 1 << (bw - 1 - i);\n        }\n        input >>= 1;\n    }\n    return var;\n}\n//码表生成  \n//如:X32+X26+...X1+1,poly=(1<<26)|...|(1<<1)|(1<<0)  \nvoid crc32_init(unsigned long poly)\n{\n    int i;\n    int j;\n    unsigned long c;\n    poly = bitrev(poly, 32);\n    for (i = 0; i < 256; i++)\n    {\n        c = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (c & 1)\n            {\n                c = poly ^ (c >> 1);\n            }\n            else\n            {\n                c = c >> 1;\n            }\n        }\n        table[i] = c;\n        printf(\"CRC32表:%x\\n\", c);\n    }\n}\nunsigned long crc32(unsigned long crc, void* input, int len)\n{\n    int i;\n    unsigned char index;\n    unsigned char* pch;\n    pch = (unsigned char*)input;\n    for (i = 0; i < len; i++)\n    {\n        index = (unsigned char)(crc^*pch);\n        crc = (crc >> 8) ^ table[index];\n        pch++;\n    }\n    return crc;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    unsigned long crc;\n    crc32_init(0x4C11DB7);  \n    crc = 0xFFFFFFFF;\n    crc = crc32(crc, \"1234567890\", 10);\n    crc ^= 0xFFFFFFFF;\n    printf(\"CRC32=%08X\\n\", crc);\n    system(\"pause\");\n}\n```\n\n初始化的这张表就是关键了。\n\n\n总结一下识别Crc32的关键特征：\n会生成一张大小为0x400大小的表，表数据如下。\n\n```c\nstatic const ub4 crctab[256] = {\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n};\n```","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之Sha1","url":"/2016/12/15/算法识别之Sha1/","content":"\n又打了几天鱼晒了几天终于干了点什么，记录一下。\n\n## SHA1算法简介\n\n简介\n安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。\n\nSHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。\n\n术语和概念\n位(Bit)，字节（Byte）和字（Word）\nSHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串: 0x616263.\n\n运算符和符号\n下面的逻辑运算符都被运用于“字”（Word）\n\nX^Y = X， Y逻辑与\n\nX // Y = X， Y逻辑或\n\nX XOR Y= X， Y逻辑异或\n\n~X = X逻辑取反\n\nX+Y定义如下：\n\n字 X 和 Y 代表两个整数 x 和y, 其中 0 <= x < 2^32 且 0 <= y < 2^32. 令整数z = (x + y) mod 2^32. 这时候 0 <= z < 2^32. 将z转换成字Z, 那么就是 Z = X + Y.\n\n循环左移位操作符Sn(X)。X是一个字，n是一个整数，0<=n<=32。Sn(X) = (X<>32-n)\n\nX<>n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算\n\n## SHA1算法描述\n\n在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下：\n\n01100001 01100010 01100011\n\n―――――――――――――\n\n‘a’=97 ‘b’=98 ‘c’=99\n\n这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。\n\n补位\n消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。\n\n补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。\n\n原始信息： 01100001 01100010 01100011\n\n补位第一步：01100001 01100010 01100011 1\n\n首先补一个“1”\n\n补位第二步：01100001 01100010 01100011 10…..0\n\n然后补423个“0”\n\n我们可以把最后补位完成后的数据用16进制写成下面的样子\n\n61626380 00000000 00000000 00000000\n\n00000000 00000000 00000000 00000000\n\n00000000 00000000 00000000 00000000\n\n00000000 00000000\n\n现在，数据的长度是448了，我们可以进行下一步操作。\n\n补长度\n所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）\n\n61626380 00000000 00000000 00000000\n\n00000000 00000000 00000000 00000000\n\n00000000 00000000 00000000 00000000\n\n00000000 00000000 00000000 00000018\n\n如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。\n\n使用的常量\n一系列的常量字K(0), K(1), … , K(79)，如果以16进制给出。它们如下：\n\nKt = 0x5A827999 (0 <= t <= 19)\n\nKt = 0x6ED9EBA1 (20 <= t <= 39)\n\nKt = 0x8F1BBCDC (40 <= t <= 59)\n\nKt = 0xCA62C1D6 (60 <= t <= 79).\n\n需要使用的函数\n\n在SHA1中我们需要一系列的函数。每个函数ft (0 <= t <= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义\n\nft(B,C,D) = (B AND C) or ((NOT B) AND D) ( 0 <= t <= 19)\n\nft(B,C,D) = B XOR C XOR D (20 <= t <= 39)\n\nft(B,C,D) = (B AND C) or (B AND D) or (C AND D) (40 <= t <= 59)\n\nft(B,C,D) = B XOR C XOR D (60 <= t <= 79).\n\n计算消息摘要\n\n必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第一个5个字的缓冲区被标识为H0, H1, H2, H3, H4\n\n。80个字的缓冲区被标识为W0, W1,…, W79\n\n另外还需要一个一个字的TEMP缓冲区。\n\n为了产生消息摘要，在第4部分中定义的16个字的数据块M1, M2,…, Mn\n\n会依次进行处理，处理每个数据块Mi 包含80个步骤。\n\n在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制）\n\nH0 = 0x67452301\n\nH1 = 0xEFCDAB89\n\nH2 = 0x98BADCFE\n\nH3 = 0x10325476\n\nH4 = 0xC3D2E1F0.\n现在开始处理M1, M2, … , Mn。为了处理 Mi,需要进行下面的步骤\n\n(1). 将 Mi 分成 16 个字 W0, W1, … , W15, W0 是最左边的字\n\n(2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).\n\n(3). 令 A = H0, B = H1, C = H2, D = H3, E = H4.\n\n(4) 对于 t = 0 到 79，执行下面的循环\n\nTEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;\n\nE = D; D = C; C = S30(B); B = A; A = TEMP;\n\n(5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.\n在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识\n\nH0 H1 H2 H3 H4.\n\n对于SHA256,SHA384,SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。\n\n## 实例分析\n\n例子很简单直接GetWindowTextA断点回溯即可找到验证函数。\n\n```c\n004014A4  |.  68 C9000000   push 0xC9                                ; /Count = C9 (201.)\n004014A9  |.  895424 40     mov dword ptr ss:[esp+0x40],edx          ; |\n004014AD  |.  66:8B15 5C604>mov dx,word ptr ds:[0x40605C]            ; |\n004014B4  |.  51            push ecx                                 ; |Buffer = 0019F5D4\n004014B5  |.  66:894424 2D  mov word ptr ss:[esp+0x2D],ax            ; |\n004014BA  |.  68 E8030000   push 0x3E8                               ; |ControlID = 3E8 (1000.)\n004014BF  |.  55            push ebp                                 ; |hWnd = 00030A82 ('SHA1 *KeyGenMe*',class='#32770')\n004014C0  |.  66:895424 40  mov word ptr ss:[esp+0x40],dx            ; |\n004014C5  |.  885C24 20     mov byte ptr ss:[esp+0x20],bl            ; |\n004014C9  |.  884424 37     mov byte ptr ss:[esp+0x37],al            ; |\n004014CD  |.  FFD7          call edi                                 ; \\GetDlgItemTextA\n004014CF  |.  8BF0          mov esi,eax                              ;  取用户名\n004014D1  |.  3BF3          cmp esi,ebx                              ;  user32.wsprintfA\n004014D3  |.  0F84 11010000 je SHA1KeyG.004015EA\n004014D9  |.  8D9424 980200>lea edx,dword ptr ss:[esp+0x298]\n004014E0  |.  68 C9000000   push 0xC9                                ; /Count = C9 (201.)\n004014E5  |.  52            push edx                                 ; |Buffer = 0019F34C\n004014E6  |.  68 E9030000   push 0x3E9                               ; |ControlID = 3E9 (1001.)\n004014EB  |.  55            push ebp                                 ; |hWnd = 00030A82 ('SHA1 *KeyGenMe*',class='#32770')\n004014EC  |.  FFD7          call edi                                 ; \\GetDlgItemTextA\n004014EE  |.  83F8 14       cmp eax,0x14                             ;  取key，长度要为0x14\n004014F1  |.  0F85 F3000000 jnz SHA1KeyG.004015EA\n004014F7  |.  8D8424 600300>lea eax,dword ptr ss:[esp+0x360]\n004014FE  |.  50            push eax\n004014FF  |.  E8 FCFAFFFF   call SHA1KeyG.00401000                   ;  Sha1Init\n00401504  |.  83C4 04       add esp,0x4\n00401507  |.  33FF          xor edi,edi\n00401509  |.  3BF3          cmp esi,ebx                              ;  user32.wsprintfA\n0040150B  |.  7E 1E         jle short SHA1KeyG.0040152B\n0040150D  |>  0FBE8C3C D001>/movsx ecx,byte ptr ss:[esp+edi+0x1D0]   ;  取用户名\n00401515  |.  8D9424 600300>|lea edx,dword ptr ss:[esp+0x360]\n0040151C  |.  51            |push ecx\n0040151D  |.  52            |push edx\n0040151E  |.  E8 1DFBFFFF   |call SHA1KeyG.00401040                  ;  消息填充\n00401523  |.  83C4 08       |add esp,0x8\n00401526  |.  47            |inc edi\n00401527  |.  3BFE          |cmp edi,esi\n00401529  |.^ 7C E2         \\jl short SHA1KeyG.0040150D\n0040152B  |>  8D8424 080100>lea eax,dword ptr ss:[esp+0x108]\n00401532  |.  8D8C24 600300>lea ecx,dword ptr ss:[esp+0x360]\n00401539  |.  50            push eax\n0040153A  |.  51            push ecx\n0040153B  |.  E8 60FDFFFF   call SHA1KeyG.004012A0                   ;  Sha1End\n00401540  |.  83C4 08       add esp,0x8\n00401543  |.  33C0          xor eax,eax\n00401545  |>  8A5404 34     /mov dl,byte ptr ss:[esp+eax+0x34]       ;  pediy forum\n00401549  |.  8A8C04 080100>|mov cl,byte ptr ss:[esp+eax+0x108]      ;  sha1值\n00401550  |.  32D1          |xor dl,cl                               ;  xor\n00401552  |.  885404 40     |mov byte ptr ss:[esp+eax+0x40],dl       ;  endbuf\n00401556  |.  40            |inc eax\n00401557  |.  83F8 11       |cmp eax,0x11\n0040155A  |.^ 7C E9         \\jl short SHA1KeyG.00401545\n0040155C  |.  83F8 14       cmp eax,0x14\n0040155F  |.  7D 1B         jge short SHA1KeyG.0040157C\n00401561  |.  8D4C24 28     lea ecx,dword ptr ss:[esp+0x28]          ;  pediy.com\n00401565  |.  83E9 11       sub ecx,0x11\n00401568  |>  8A1401        /mov dl,byte ptr ds:[ecx+eax]\n0040156B  |.  329404 080100>|xor dl,byte ptr ss:[esp+eax+0x108]      ;  异或后三字节\n00401572  |.  40            |inc eax\n00401573  |.  83F8 14       |cmp eax,0x14\n00401576  |.  885404 3F     |mov byte ptr ss:[esp+eax+0x3F],dl\n0040157A  |.^ 7C EC         \\jl short SHA1KeyG.00401568\n0040157C  |>  8B1D A4504000 mov ebx,dword ptr ds:[<&USER32.wsprintfA>;  user32.wsprintfA\n00401582  |.  33F6          xor esi,esi\n00401584  |.  8D7C24 10     lea edi,dword ptr ss:[esp+0x10]\n00401588  |>  8A4434 4A     /mov al,byte ptr ss:[esp+esi+0x4A]\n0040158C  |.  8A4C34 40     |mov cl,byte ptr ss:[esp+esi+0x40]\n00401590  |.  32C8          |xor cl,al                               ;  十字节异或\n00401592  |.  8AC1          |mov al,cl\n00401594  |.  884C34 40     |mov byte ptr ss:[esp+esi+0x40],cl       ;  endbuf\n00401598  |.  25 FF000000   |and eax,0xFF\n0040159D  |.  50            |push eax\n0040159E  |.  68 4C604000   |push SHA1KeyG.0040604C                  ;  ASCII \"%02X\"\n004015A3  |.  57            |push edi\n004015A4  |.  FFD3          |call ebx                                ;  user32.wsprintfA\n004015A6  |.  83C4 0C       |add esp,0xC\n004015A9  |.  46            |inc esi\n004015AA  |.  83C7 02       |add edi,0x2\n004015AD  |.  83FE 0A       |cmp esi,0xA\n004015B0  |.^ 7C D6         \\jl short SHA1KeyG.00401588\n004015B2  |.  8D8C24 980200>lea ecx,dword ptr ss:[esp+0x298]\n004015B9  |.  8D5424 10     lea edx,dword ptr ss:[esp+0x10]\n004015BD  |.  51            push ecx                                 ; /String2 = \"1234567890abcdefghij\"\n004015BE  |.  52            push edx                                 ; |String1 = \"F24CB1C3CDAE9D0F970D\"\n004015BF  |.  FF15 00504000 call dword ptr ds:[<&KERNEL32.lstrcmpA>] ; \\lstrcmpA\n004015C5  |.  85C0          test eax,eax\n004015C7  |.  75 21         jnz short SHA1KeyG.004015EA\n004015C9  |.  68 40604000   push SHA1KeyG.00406040                   ; /Text = \"Success!\"\n004015CE  |.  68 E9030000   push 0x3E9                               ; |ControlID = 3E9 (1001.)\n004015D3  |.  55            push ebp                                 ; |hWnd = 00030A82 ('SHA1 *KeyGenMe*',class='#32770')\n004015D4  |.  FF15 A8504000 call dword ptr ds:[<&USER32.SetDlgItemTe>; \\SetDlgItemTextA\n004015DA  |.  5F            pop edi                                  ;  0019F34C\n004015DB  |.  5E            pop esi                                  ;  0019F34C\n004015DC  |.  5D            pop ebp                                  ;  0019F34C\n004015DD  |.  B8 01000000   mov eax,0x1\n004015E2  |.  5B            pop ebx                                  ;  0019F34C\n004015E3  |.  81C4 B8040000 add esp,0x4B8\n004015E9  |.  C3            retn\n004015EA  |>  68 30604000   push SHA1KeyG.00406030                   ; /Text = \"Wrong Serial!\"\n004015EF  |.  68 E9030000   push 0x3E9                               ; |ControlID = 3E9 (1001.)\n004015F4  |.  55            push ebp                                 ; |hWnd = 00030A82 ('SHA1 *KeyGenMe*',class='#32770')\n004015F5  |.  FF15 A8504000 call dword ptr ds:[<&USER32.SetDlgItemTe>; \\SetDlgItemTextA\n004015FB  |.  5F            pop edi                                  ;  0019F34C\n004015FC  |.  5E            pop esi                                  ;  0019F34C\n004015FD  |.  5D            pop ebp                                  ;  0019F34C\n004015FE  |.  33C0          xor eax,eax\n00401600  |.  5B            pop ebx                                  ;  0019F34C\n00401601  |.  81C4 B8040000 add esp,0x4B8\n00401607  \\.  C3            retn\nSha1Init\n00401000  /$  8B5424 04     mov edx,dword ptr ss:[esp+0x4]\n00401004  |.  57            push edi                                 ;  user32.GetDlgItemTextA\n00401005  |.  B9 50000000   mov ecx,0x50\n0040100A  |.  33C0          xor eax,eax\n0040100C  |.  8D7A 28       lea edi,dword ptr ds:[edx+0x28]\n0040100F  |.  F3:AB         rep stos dword ptr es:[edi]\n00401011  |.  8942 04       mov dword ptr ds:[edx+0x4],eax\n00401014  |.  8902          mov dword ptr ds:[edx],eax\n00401016  |.  C742 08 01234>mov dword ptr ds:[edx+0x8],0x67452301\n0040101D  |.  C742 0C 89ABC>mov dword ptr ds:[edx+0xC],0xEFCDAB89\n00401024  |.  C742 10 FEDCB>mov dword ptr ds:[edx+0x10],0x98BADCFE\n0040102B  |.  C742 14 76543>mov dword ptr ds:[edx+0x14],0x10325476\n00401032  |.  C742 18 F0E1D>mov dword ptr ds:[edx+0x18],0xC3D2E1F0\n00401039  |.  5F            pop edi                                  ;  0019F69C\n0040103A  \\.  C3            retn\n```\n\nSha1初始化后内存数据\n\n进行消息填充后内存数据\n\n以上就是分析流程，根据这就能写出注册机。\n\n```c\n#include \"stdafx.h\"\n#include <string.h>\ntypedef struct {\n    unsigned int length[2];\n    unsigned int h[8];\n    unsigned int w[80];\n} sha;\n#define H0 0x67452301L\n#define H1 0xefcdab89L\n#define H2 0x98badcfeL\n#define H3 0x10325476L\n#define H4 0xc3d2e1f0L\n#define K0 0x5a827999L\n#define K1 0x6ed9eba1L\n#define K2 0x8f1bbcdcL\n#define K3 0xca62c1d6L\n#define PAD  0x80\n#define ZERO 0\n/* functions */\n#define S(n,x) (((x)<<n) | ((x)>>(32-n)))\n#define F0(x,y,z) ((x&y)|((~x)&z))\n#define F1(x,y,z) (x^y^z)\n#define F2(x,y,z) ((x&y) | (x&z)|(y&z)) \n#define F3(x,y,z) (x^y^z)\nstatic void sha1_transform(sha *sh)\n{ /* basic transformation step */\n    unsigned int a, b, c, d, e, temp;\n    int t;\n    for (t = 16; t < 80; t++) sh->w[t] = S(1, sh->w[t - 3] ^ sh->w[t - 8] ^ sh->w[t - 14] ^ sh->w[t - 16]);\n    a = sh->h[0]; b = sh->h[1]; c = sh->h[2]; d = sh->h[3]; e = sh->h[4];\n    for (t = 0; t < 20; t++)\n    { /* 20 times - mush it up */\n        temp = K0 + F0(b, c, d) + S(5, a) + e + sh->w[t];\n        e = d; d = c;\n        c = S(30, b);\n        b = a; a = temp;\n    }\n    for (t = 20; t < 40; t++)\n    { /* 20 more times - mush it up */\n        temp = K1 + F1(b, c, d) + S(5, a) + e + sh->w[t];\n        e = d; d = c;\n        c = S(30, b);\n        b = a; a = temp;\n    }\n    for (t = 40; t < 60; t++)\n    { /* 20 more times - mush it up */\n        temp = K2 + F2(b, c, d) + S(5, a) + e + sh->w[t];\n        e = d; d = c;\n        c = S(30, b);\n        b = a; a = temp;\n    }\n    for (t = 60; t < 80; t++)\n    { /* 20 more times - mush it up */\n        temp = K3 + F3(b, c, d) + S(5, a) + e + sh->w[t];\n        e = d; d = c;\n        c = S(30, b);\n        b = a; a = temp;\n    }\n    sh->h[0] += a; sh->h[1] += b; sh->h[2] += c;\n    sh->h[3] += d; sh->h[4] += e;\n}\nvoid sha1_init(sha *sh)\n{ /* re-initialise */\n    int i;\n    for (i = 0; i < 80; i++) sh->w[i] = 0L;\n    sh->length[0] = sh->length[1] = 0L;\n    sh->h[0] = H0;\n    sh->h[1] = H1;\n    sh->h[2] = H2;\n    sh->h[3] = H3;\n    sh->h[4] = H4;\n}\nvoid sha1_process(sha *sh, int byte)\n{ /* process the next message byte */\n    int cnt;\n    cnt = (int)((sh->length[0] / 32) % 16);\n    sh->w[cnt] <<= 8;\n    sh->w[cnt] |= (unsigned int)(byte & 0xFF);\n    sh->length[0] += 8;\n    if (sh->length[0] == 0L) { sh->length[1]++; sh->length[0] = 0L; }\n    if ((sh->length[0] % 512) == 0) sha1_transform(sh);\n}\nvoid sha1_hash(sha *sh, char hash[20])\n{ /* pad message and finish - supply digest */\n    int i;\n    unsigned int len0, len1;\n    len0 = sh->length[0];\n    len1 = sh->length[1];\n    sha1_process(sh, PAD);\n    while ((sh->length[0] % 512) != 448) sha1_process(sh, ZERO);\n    sh->w[14] = len1;\n    sh->w[15] = len0;\n    sha1_transform(sh);\n    for (i = 0; i < 20; i++)\n    { /* convert to bytes */\n        hash[i] = ((sh->h[i / 4] >> (8 * (3 - i % 4))) & 0xffL);\n    }\n    sha1_init(sh);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    sha sh;\n    sha1_init(&sh);\n    char *strName = \"abcde\" ;\n    for (int i = 0; i < strlen(strName); i++)\n    {\n        sha1_process(&sh, strName[i]);\n    }\n    \n    char strRes[0x20] = { 0 };\n    sha1_hash(&sh, strRes);\n    char *str1 = \"PEDIY Forum\";\n    char strEnd[0x20] = { 0 };\n    int i = 0;\n    for (i = 0; i < 17; i++)\n    {\n        strEnd[i] = strRes[i] ^ str1[i];\n    }\n    \n    char *str2 = \"pediy.com\";\n    for (; i < 0x14;i++)\n    {\n        strEnd[i] = str2[i] ^ strRes[i - 0x11];\n    }\n    for (i = 0; i < 0xa; i++)\n    {\n        strEnd[i] ^= strEnd[i + 0xa];\n    }\n    return 0;\n}\n```\n\n总结一下识别Sha1的关键特征：\n1）五个初始化的常量0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之MD5","url":"/2016/12/08/算法识别之MD5/","content":"\n先来谈谈最熟悉的MD5吧，很小时候就听过的加密算法了。🌚\n\n## Md5算法简介\n\n算法简介内容来源自网络。\n\n### 一、MD5概念\n\nMD5，全名Message Digest Algorithm 5 ，中文名为消息摘要算法第五版，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。上面这段话话引用自百度百科，我的理解MD5是一种信息摘要算法，主要是通过特定的hash散列方法将文本信息转换成简短的信息摘要，压缩+加密+hash算法的结合体，是绝对不可逆的。\n\n### 二、MD5计算步骤\n\nMD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。\n第一步、填充\n如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；\n第二步、记录信息长度\n用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N512+448+64=(N+1)512位。\n第三步、装入标准的幻数（四个整数）\n标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L）。\n第四步、四轮循环运算\n循环的次数是分组的个数（N+1）\n1）将每一512字节细分成16个小组，每个小组64位（8个字节）\n2）先认识四个线性函数(&是与,|是或,~是非,^是异或)\n\n```c\nF(X,Y,Z)=(X&Y)|((~X)&Z)  \nG(X,Y,Z)=(X&Z)|(Y&(~Z))  \nH(X,Y,Z)=X^Y^Z  \nI(X,Y,Z)=Y^(X|(~Z))\n```\n\n3）设Mj表示消息的第j个子分组（从0到15），<<< s表示循环左移s位，则四种操作为：\n\n```c\nFF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)<< <s) \nGG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)<< <s)  \nHH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)<< <s)  \nII(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)<< <s)\n```\n\n4）四轮运算\n\n```c\n第一轮\na=FF(a,b,c,d,M0,7,0xd76aa478)\nb=FF(d,a,b,c,M1,12,0xe8c7b756)\nc=FF(c,d,a,b,M2,17,0x242070db)\nd=FF(b,c,d,a,M3,22,0xc1bdceee)\na=FF(a,b,c,d,M4,7,0xf57c0faf)\nb=FF(d,a,b,c,M5,12,0x4787c62a)\nc=FF(c,d,a,b,M6,17,0xa8304613)\nd=FF(b,c,d,a,M7,22,0xfd469501)\na=FF(a,b,c,d,M8,7,0x698098d8)\nb=FF(d,a,b,c,M9,12,0x8b44f7af)\nc=FF(c,d,a,b,M10,17,0xffff5bb1)\nd=FF(b,c,d,a,M11,22,0x895cd7be)\na=FF(a,b,c,d,M12,7,0x6b901122)\nb=FF(d,a,b,c,M13,12,0xfd987193)\nc=FF(c,d,a,b,M14,17,0xa679438e)\nd=FF(b,c,d,a,M15,22,0x49b40821)\n第二轮\na=GG(a,b,c,d,M1,5,0xf61e2562)\nb=GG(d,a,b,c,M6,9,0xc040b340)\nc=GG(c,d,a,b,M11,14,0x265e5a51)\nd=GG(b,c,d,a,M0,20,0xe9b6c7aa)\na=GG(a,b,c,d,M5,5,0xd62f105d)\nb=GG(d,a,b,c,M10,9,0x02441453)\nc=GG(c,d,a,b,M15,14,0xd8a1e681)\nd=GG(b,c,d,a,M4,20,0xe7d3fbc8)\na=GG(a,b,c,d,M9,5,0x21e1cde6)\nb=GG(d,a,b,c,M14,9,0xc33707d6)\nc=GG(c,d,a,b,M3,14,0xf4d50d87)\nd=GG(b,c,d,a,M8,20,0x455a14ed)\na=GG(a,b,c,d,M13,5,0xa9e3e905)\nb=GG(d,a,b,c,M2,9,0xfcefa3f8)\nc=GG(c,d,a,b,M7,14,0x676f02d9)\nd=GG(b,c,d,a,M12,20,0x8d2a4c8a)\n第三轮\na=HH(a,b,c,d,M5,4,0xfffa3942)\nb=HH(d,a,b,c,M8,11,0x8771f681)\nc=HH(c,d,a,b,M11,16,0x6d9d6122)\nd=HH(b,c,d,a,M14,23,0xfde5380c)\na=HH(a,b,c,d,M1,4,0xa4beea44)\nb=HH(d,a,b,c,M4,11,0x4bdecfa9)\nc=HH(c,d,a,b,M7,16,0xf6bb4b60)\nd=HH(b,c,d,a,M10,23,0xbebfbc70)\na=HH(a,b,c,d,M13,4,0x289b7ec6)\nb=HH(d,a,b,c,M0,11,0xeaa127fa)\nc=HH(c,d,a,b,M3,16,0xd4ef3085)\nd=HH(b,c,d,a,M6,23,0x04881d05)\na=HH(a,b,c,d,M9,4,0xd9d4d039)\nb=HH(d,a,b,c,M12,11,0xe6db99e5)\nc=HH(c,d,a,b,M15,16,0x1fa27cf8)\nd=HH(b,c,d,a,M2,23,0xc4ac5665)\n第四轮\na=II(a,b,c,d,M0,6,0xf4292244)\nb=II(d,a,b,c,M7,10,0x432aff97)\nc=II(c,d,a,b,M14,15,0xab9423a7)\nd=II(b,c,d,a,M5,21,0xfc93a039)\na=II(a,b,c,d,M12,6,0x655b59c3)\nb=II(d,a,b,c,M3,10,0x8f0ccc92)\nc=II(c,d,a,b,M10,15,0xffeff47d)\nd=II(b,c,d,a,M1,21,0x85845dd1)\na=II(a,b,c,d,M8,6,0x6fa87e4f)\nb=II(d,a,b,c,M15,10,0xfe2ce6e0)\nc=II(c,d,a,b,M6,15,0xa3014314)\nd=II(b,c,d,a,M13,21,0x4e0811a1)\na=II(a,b,c,d,M4,6,0xf7537e82)\nb=II(d,a,b,c,M11,10,0xbd3af235)\nc=II(c,d,a,b,M2,15,0x2ad7d2bb)\nd=II(b,c,d,a,M9,21,0xeb86d391)\n```\n\n5）每轮循环后，将A，B，C，D分别加上a，b，c，d，然后进入下一循环。\n\n## 实例分析\n简单了解了一下MD5的实现原理，直接来个例子分析一下，例子有很多，就直接拿加密与解密这本书中的例子来说吧。\n例子很简单直接GetWindowTextA断点，回溯找到验证函数。\n\n```\n0040114A  |.  68 C9000000   push 0xC9                                        ; /Count = C9 (201.)\n0040114F  |.  A4            movs byte ptr es:[edi],byte ptr ds:[esi]         ; |\n00401150  |.  8BB424 E00300>mov esi,dword ptr ss:[esp+0x3E0]                 ; |\n00401157  |.  894424 21     mov dword ptr ss:[esp+0x21],eax                  ; |\n0040115B  |.  51            push ecx                                         ; |Buffer = NULL\n0040115C  |.  66:894424 29  mov word ptr ss:[esp+0x29],ax                    ; |\n00401161  |.  68 E8030000   push 0x3E8                                       ; |ControlID = 3E8 (1000.)\n00401166  |.  56            push esi                                         ; |hWnd = 00090812 ('MD5 *KeyGenMe*',class='#32770')\n00401167  |.  885C24 20     mov byte ptr ss:[esp+0x20],bl                    ; |\n0040116B  |.  884424 33     mov byte ptr ss:[esp+0x33],al                    ; |\n0040116F  |.  FFD5          call ebp                                         ; \\GetDlgItemTextA\n00401171  |.  8BF8          mov edi,eax\n00401173  |.  3BFB          cmp edi,ebx\n00401175  |.  0F84 0E010000 je MD5KeyGe.00401289\n0040117B  |.  8D5424 60     lea edx,dword ptr ss:[esp+0x60]\n0040117F  |.  68 C9000000   push 0xC9                                        ; /Count = C9 (201.)\n00401184  |.  52            push edx                                         ; |Buffer = 0019F674\n00401185  |.  68 E9030000   push 0x3E9                                       ; |ControlID = 3E9 (1001.)\n0040118A  |.  56            push esi                                         ; |hWnd = 00090812 ('MD5 *KeyGenMe*',class='#32770')\n0040118B  |.  FFD5          call ebp                                         ; \\GetDlgItemTextA\n0040118D  |.  83F8 13       cmp eax,0x13                                     ;  判断序列号长度是否为0x13\n00401190  |.  0F85 F3000000 jnz MD5KeyGe.00401289\n00401196  |.  8A4C24 64     mov cl,byte ptr ss:[esp+0x64]\n0040119A  |.  B0 2D         mov al,0x2D\n0040119C  |.  3AC8          cmp cl,al                                        ;  判断第五位是否为-\n0040119E  |.  0F85 E5000000 jnz MD5KeyGe.00401289\n004011A4  |.  384424 69     cmp byte ptr ss:[esp+0x69],al                    ;  判断第十位是否为-\n004011A8  |.  0F85 DB000000 jnz MD5KeyGe.00401289\n004011AE  |.  384424 6E     cmp byte ptr ss:[esp+0x6E],al                    ;  判断第十五位是否为-\n004011B2  |.  0F85 D1000000 jnz MD5KeyGe.00401289\n004011B8  |.  8B4C24 65     mov ecx,dword ptr ss:[esp+0x65]\n004011BC  |.  8B4424 60     mov eax,dword ptr ss:[esp+0x60]\n004011C0  |.  8B5424 6A     mov edx,dword ptr ss:[esp+0x6A]\n004011C4  |.  894C24 14     mov dword ptr ss:[esp+0x14],ecx\n004011C8  |.  894424 10     mov dword ptr ss:[esp+0x10],eax\n004011CC  |.  8B4424 6F     mov eax,dword ptr ss:[esp+0x6F]\n004011D0  |.  8D8C24 280100>lea ecx,dword ptr ss:[esp+0x128]\n004011D7  |.  895424 18     mov dword ptr ss:[esp+0x18],edx\n004011DB  |.  51            push ecx\n004011DC  |.  894424 20     mov dword ptr ss:[esp+0x20],eax\n004011E0  |.  E8 CB000000   call MD5KeyGe.004012B0                           ;  Md5_Init\n004011E5  |.  8D9424 4C0200>lea edx,dword ptr ss:[esp+0x24C]                 ;  取用户名存放地址\n004011EC  |.  57            push edi                                         ;  长度\n004011ED  |.  8D8424 300100>lea eax,dword ptr ss:[esp+0x130]\n004011F4  |.  52            push edx\n004011F5  |.  50            push eax\n004011F6  |.  E8 E5000000   call MD5KeyGe.004012E0 ;函数内进行循环运算\n004011FB  |.  83C4 10       add esp,0x10\n004011FE  |.  8D4C24 24     lea ecx,dword ptr ss:[esp+0x24]\n00401202  |.  51            push ecx                                         ; /String = NULL\n00401203  |.  FF15 04604000 call dword ptr ds:[<&KERNEL32.lstrlenA>]         ; \\lstrlenA\n00401209  |.  50            push eax\n0040120A  |.  8D5424 28     lea edx,dword ptr ss:[esp+0x28]\n0040120E  |.  8D8424 2C0100>lea eax,dword ptr ss:[esp+0x12C]\n00401215  |.  52            push edx\n00401216  |.  50            push eax\n00401217  |.  E8 C4000000   call MD5KeyGe.004012E0\n0040121C  |.  8D8C24 340100>lea ecx,dword ptr ss:[esp+0x134]\n00401223  |.  8D9424 8C0100>lea edx,dword ptr ss:[esp+0x18C]\n0040122A  |.  51            push ecx\n0040122B  |.  52            push edx\n0040122C  |.  E8 5F010000   call MD5KeyGe.00401390\n00401231  |.  83C4 14       add esp,0x14\n00401234  |.  33C0          xor eax,eax\n00401236  |>  8A8C04 800100>/mov cl,byte ptr ss:[esp+eax+0x180]\n0040123D  |.  83E1 1F       |and ecx,0x1F\n00401240  |.  40            |inc eax\n00401241  |.  83F8 10       |cmp eax,0x10\n00401244  |.  8A540C 3C     |mov dl,byte ptr ss:[esp+ecx+0x3C]\n00401248  |.  889404 0F0300>|mov byte ptr ss:[esp+eax+0x30F],dl\n0040124F  |.^ 7C E5         \\jl short MD5KeyGe.00401236\n00401251  |.  8D8424 100300>lea eax,dword ptr ss:[esp+0x310]\n00401258  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n0040125C  |.  50            push eax                                         ; /String2 = \"\"\n0040125D  |.  51            push ecx                                         ; |String1 = NULL\n0040125E  |.  FF15 00604000 call dword ptr ds:[<&KERNEL32.lstrcmpA>]         ; \\lstrcmpA\n00401264  |.  85C0          test eax,eax\n00401266  |.  75 21         jnz short MD5KeyGe.00401289\n00401268  |.  68 80704000   push MD5KeyGe.00407080                           ; /Text = \"Success!\"\n0040126D  |.  68 E9030000   push 0x3E9                                       ; |ControlID = 3E9 (1001.)\n00401272  |.  56            push esi                                         ; |hWnd = 00090812 ('MD5 *KeyGenMe*',class='#32770')\n00401273  |.  FF15 A8604000 call dword ptr ds:[<&USER32.SetDlgItemTextA>]    ; \\SetDlgItemTextA\n00401279  |.  5F            pop edi                                          ;  0019F554\n0040127A  |.  5E            pop esi                                          ;  0019F554\n0040127B  |.  5D            pop ebp                                          ;  0019F554\n0040127C  |.  B8 01000000   mov eax,0x1\n00401281  |.  5B            pop ebx                                          ;  0019F554\n00401282  |.  81C4 C8030000 add esp,0x3C8\n00401288  |.  C3            retn\n00401289  |>  68 70704000   push MD5KeyGe.00407070                           ; /Text = \"Wrong Serial!\"\n0040128E  |.  68 E9030000   push 0x3E9                                       ; |ControlID = 3E9 (1001.)\n00401293  |.  56            push esi                                         ; |hWnd = 00090812 ('MD5 *KeyGenMe*',class='#32770')\n00401294  |.  FF15 A8604000 call dword ptr ds:[<&USER32.SetDlgItemTextA>]    ; \\SetDlgItemTextA\n0040129A  |.  5F            pop edi                                          ;  0019F554\n0040129B  |.  5E            pop esi                                          ;  0019F554\n0040129C  |.  5D            pop ebp                                          ;  0019F554\n0040129D  |.  33C0          xor eax,eax\n0040129F  |.  5B            pop ebx                                          ;  0019F554\n004012A0  |.  81C4 C8030000 add esp,0x3C8\n004012A6  \\.  C3            retn\nMd5 Init函数：\n004012B0  /$  8B4424 04     mov eax,dword ptr ss:[esp+0x4]\n004012B4  |.  33C9          xor ecx,ecx\n004012B6  |.  8948 14       mov dword ptr ds:[eax+0x14],ecx\n004012B9  |.  8948 10       mov dword ptr ds:[eax+0x10],ecx\n004012BC  |.  C700 01234567 mov dword ptr ds:[eax],0x67452301\n004012C2  |.  C740 04 89ABC>mov dword ptr ds:[eax+0x4],0xEFCDAB89\n004012C9  |.  C740 08 FEDCB>mov dword ptr ds:[eax+0x8],0x98BADCFE\n004012D0  |.  C740 0C 76543>mov dword ptr ds:[eax+0xC],0x10325476\n004012D7  \\.  C3            retn\n```\n\n由此可看出这里初始化了几个常量，可以高度怀疑是Md5算法了。\n这里差不多就分析完了，写个注册机测试一下。\n\n```c\n// MD5.cpp : 定义控制台应用程序的入口点。\n//\n#include \"stdafx.h\"\n#include <STRING.H>\n#include <STDIO.H>\n#include <stdlib.h>\n//! 定义MD5状态数据结构类型\ntypedef struct{\n    unsigned long int    state[4];        // 初始链接变量;保存16字节摘要\n    unsigned long int    count[2];        // 明文位数\n    unsigned char        PADDING[64];    // 填充位，最大64*8位\n    unsigned char        buffer[64];        // 输入缓冲\n}MD5_State;\n//! MD5转换常量\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\n//! F, G, H and I 基本MD5函数\n#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))\n#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define I(x, y, z) ((y) ^ ((x) | (~z)))\n//! 将x循环左移n位\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))\n//! 4轮运算中FF(第1轮), GG(第2轮), HH(第3轮), and II(第4轮)转换\n#define FF(a, b, c, d, x, s, ac) { \\\n    (a) += F ((b), (c), (d)) + (x) + (unsigned long int)(ac); \\\n    (a) = ROTATE_LEFT ((a), (s)); \\\n    (a) += (b); \\\n    }\n#define GG(a, b, c, d, x, s, ac) { \\\n    (a) += G ((b), (c), (d)) + (x) + (unsigned long int)(ac); \\\n    (a) = ROTATE_LEFT ((a), (s)); \\\n    (a) += (b); \\\n    }\n#define HH(a, b, c, d, x, s, ac) { \\\n    (a) += H ((b), (c), (d)) + (x) + (unsigned long int)(ac); \\\n    (a) = ROTATE_LEFT ((a), (s)); \\\n    (a) += (b); \\\n    }\n#define II(a, b, c, d, x, s, ac) { \\\n    (a) += I ((b), (c), (d)) + (x) + (unsigned long int)(ac); \\\n    (a) = ROTATE_LEFT ((a), (s)); \\\n    (a) += (b); \\\n    }\n/******************************************************************************/\n//    名称：MD5_memcpy\n//    功能：输入输出字节拷贝\n//  参数：output:    指向unsigned char类型输出缓冲区\n//          input:    指向unsigned char类型输入缓冲区\n//          len:        输入数据长度(字节)\n//    返回：无\n/******************************************************************************/\nvoid MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len)\n{\n    unsigned int i;\n    for (i = 0; i < len; i++)\n        output[i] = input[i];\n}\n/******************************************************************************/\n//    名称：MD5_memset\n//    功能：对MD5运算缓冲区中填充数据\n//  参数：output:    指向unsigned char类型缓冲区\n//          value:    数据\n//          len:        填充大小\n//    返回：无\n/******************************************************************************/\nvoid MD5_memset(unsigned char *output, int value, unsigned int len)\n{\n    unsigned int i;\n    for (i = 0; i < len; i++)\n        ((char *)output)[i] = (char)value;\n}\n/******************************************************************************/\n//    名称：Encode\n//    功能：数据类型轮换(unsigned long char -> unsigned char)\n//  参数：output:    指向unsigned char类型输出缓冲区\n//          input:    指向unsigned long int类型输入缓冲区\n//          len:        输入数据长度(字节)\n//    返回：无\n/******************************************************************************/\nvoid Encode(unsigned char *output, unsigned long int *input, unsigned int len)\n{\n    unsigned int i, j;\n    for (i = 0, j = 0; j < len; i++, j += 4)\n    {\n        output[j] = (unsigned char)(input[i] & 0xff);\n        output[j + 1] = (unsigned char)((input[i] >> 8) & 0xff);\n        output[j + 2] = (unsigned char)((input[i] >> 16) & 0xff);\n        output[j + 3] = (unsigned char)((input[i] >> 24) & 0xff);\n    }\n}\n/******************************************************************************/\n//    名称：Decode\n//    功能：数据类型轮换(unsigned char -> unsigned long int)\n//  参数：output:    指向unsigned long int类型输出缓冲区\n//          input:    指向unsigned char类型输入缓冲区\n//          len:        输入数据长度(字节)\n//    返回：无\n/******************************************************************************/\nvoid Decode(unsigned long int *output, unsigned char *input, unsigned int len)\n{\n    unsigned int i, j;\n    for (i = 0, j = 0; j < len; i++, j += 4)\n        output[i] = ((unsigned long int)input[j]) | (((unsigned long int)input[j + 1]) << 8) |\n        (((unsigned long int)input[j + 2]) << 16) | (((unsigned long int)input[j + 3]) << 24);\n}\n/******************************************************************************/\n//    名称：MD5Init\n//    功能：初始链接变量赋值；初始化填充位\n//  参数：指向MD5状态数据变量\n//    返回：无\n//  备注：填充位第1位为1,其余位为0\n/******************************************************************************/\nvoid MD5_Init(MD5_State *s)\n{\n    s->count[0] = s->count[1] = 0;\n    //! 初始链接变量\n    s->state[0] = 0x67452301;\n    s->state[1] = 0xefcdab89;\n    s->state[2] = 0x98badcfe;\n    s->state[3] = 0x10325476;\n    //! 初始填充位(目标形式: 0x80000000......，共计512位)\n    MD5_memset(s->PADDING, 0, sizeof(s->PADDING));\n    *(s->PADDING) = 0x80;\n    //  s->PADDING = {\n    //    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    //    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    //    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0    };\n}\n/******************************************************************************/\n//    名称：MD5Transform\n//    功能：MD5 4轮运算\n//  参数：state: 链接变量；block: 子明文分组\n//    返回：无\n//  备注：4轮共计64步运算\n/******************************************************************************/\nvoid MD5_Transform(unsigned long int state[4], unsigned char block[64])\n{\n    unsigned long int a = state[0], b = state[1], c = state[2], d = state[3], x[16];\n    Decode(x, block, 64);\n    //! 第1轮\n    FF(a, b, c, d, x[0], S11, 0xd76aa478); // 1\n    FF(d, a, b, c, x[1], S12, 0xe8c7b756); // 2\n    FF(c, d, a, b, x[2], S13, 0x242070db); // 3\n    FF(b, c, d, a, x[3], S14, 0xc1bdceee); // 4\n    FF(a, b, c, d, x[4], S11, 0xf57c0faf); // 5\n    FF(d, a, b, c, x[5], S12, 0x4787c62a); // 6\n    FF(c, d, a, b, x[6], S13, 0xa8304613); // 7\n    FF(b, c, d, a, x[7], S14, 0xfd469501); // 8\n    FF(a, b, c, d, x[8], S11, 0x698098d8); // 9\n    FF(d, a, b, c, x[9], S12, 0x8b44f7af); // 10\n    FF(c, d, a, b, x[10], S13, 0xffff5bb1); // 11\n    FF(b, c, d, a, x[11], S14, 0x895cd7be); // 12\n    FF(a, b, c, d, x[12], S11, 0x6b901122); // 13\n    FF(d, a, b, c, x[13], S12, 0xfd987193); // 14\n    FF(c, d, a, b, x[14], S13, 0xa679438e); // 15\n    FF(b, c, d, a, x[15], S14, 0x49b40821); // 16\n    //! 第2轮\n    GG(a, b, c, d, x[1], S21, 0xf61e2562); // 17\n    GG(d, a, b, c, x[6], S22, 0xc040b340); // 18\n    GG(c, d, a, b, x[11], S23, 0x265e5a51); // 19\n    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); // 20\n    GG(a, b, c, d, x[5], S21, 0xd62f105d); // 21\n    GG(d, a, b, c, x[10], S22, 0x2441453); // 22\n    GG(c, d, a, b, x[15], S23, 0xd8a1e681); // 23\n    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); // 24\n    GG(a, b, c, d, x[9], S21, 0x21e1cde6); // 25\n    GG(d, a, b, c, x[14], S22, 0xc33707d6); // 26\n    GG(c, d, a, b, x[3], S23, 0xf4d50d87); // 27\n    GG(b, c, d, a, x[8], S24, 0x455a14ed); // 28\n    GG(a, b, c, d, x[13], S21, 0xa9e3e905); // 29\n    GG(d, a, b, c, x[2], S22, 0xfcefa3f8); // 30\n    GG(c, d, a, b, x[7], S23, 0x676f02d9); // 31\n    GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); // 32\n    //! 第3轮\n    HH(a, b, c, d, x[5], S31, 0xfffa3942); // 33\n    HH(d, a, b, c, x[8], S32, 0x8771f681); // 34\n    HH(c, d, a, b, x[11], S33, 0x6d9d6122); // 35\n    HH(b, c, d, a, x[14], S34, 0xfde5380c); // 36\n    HH(a, b, c, d, x[1], S31, 0xa4beea44); // 37\n    HH(d, a, b, c, x[4], S32, 0x4bdecfa9); // 38\n    HH(c, d, a, b, x[7], S33, 0xf6bb4b60); // 39\n    HH(b, c, d, a, x[10], S34, 0xbebfbc70); // 40\n    HH(a, b, c, d, x[13], S31, 0x289b7ec6); // 41\n    HH(d, a, b, c, x[0], S32, 0xeaa127fa); // 42\n    HH(c, d, a, b, x[3], S33, 0xd4ef3085); // 43\n    HH(b, c, d, a, x[6], S34, 0x4881d05); // 44\n    HH(a, b, c, d, x[9], S31, 0xd9d4d039); // 45\n    HH(d, a, b, c, x[12], S32, 0xe6db99e5); // 46\n    HH(c, d, a, b, x[15], S33, 0x1fa27cf8); // 47\n    HH(b, c, d, a, x[2], S34, 0xc4ac5665); // 48\n    //! 第4轮\n    II(a, b, c, d, x[0], S41, 0xf4292244); // 49\n    II(d, a, b, c, x[7], S42, 0x432aff97); // 50\n    II(c, d, a, b, x[14], S43, 0xab9423a7); // 51\n    II(b, c, d, a, x[5], S44, 0xfc93a039); // 52\n    II(a, b, c, d, x[12], S41, 0x655b59c3); // 53\n    II(d, a, b, c, x[3], S42, 0x8f0ccc92); // 54\n    II(c, d, a, b, x[10], S43, 0xffeff47d); // 55\n    II(b, c, d, a, x[1], S44, 0x85845dd1); // 56\n    II(a, b, c, d, x[8], S41, 0x6fa87e4f); // 57\n    II(d, a, b, c, x[15], S42, 0xfe2ce6e0); // 58\n    II(c, d, a, b, x[6], S43, 0xa3014314); // 59\n    II(b, c, d, a, x[13], S44, 0x4e0811a1); // 60\n    II(a, b, c, d, x[4], S41, 0xf7537e82); // 61\n    II(d, a, b, c, x[11], S42, 0xbd3af235); // 62\n    II(c, d, a, b, x[2], S43, 0x2ad7d2bb); // 63\n    II(b, c, d, a, x[9], S44, 0xeb86d391); // 64\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    MD5_memset((unsigned char*)x, 0, sizeof(x));\n}\n/******************************************************************************/\n//    名称：MD5_Update\n//    功能：明文填充，明文分组，16个子明文分组\n//  参数：指向SHA状态变量\n//    返回：无\n/******************************************************************************/\nvoid MD5_Update(MD5_State *s, unsigned char *input, unsigned int inputLen)\n{\n    unsigned int i, index, partLen;\n    //! 明文填充\n    //! 字节数 mod 64\n    index = (unsigned int)((s->count[0] >> 3) & 0x3F);\n    //! 更新位数\n    if ((s->count[0] += ((unsigned long int)inputLen << 3))\n        < ((unsigned long int)inputLen << 3))\n        s->count[1]++;\n    s->count[1] += ((unsigned long int)inputLen >> 29);\n    partLen = 64 - index;\n    //! MD5 4轮运算\n    if (inputLen >= partLen)\n    {\n        MD5_memcpy((unsigned char*)&s->buffer[index], (unsigned char*)input, partLen);\n        MD5_Transform(s->state, s->buffer);\n        for (i = partLen; i + 63 < inputLen; i += 64)\n            MD5_Transform(s->state, &input[i]);\n        index = 0;\n    }\n    else\n        i = 0;\n    MD5_memcpy((unsigned char*)&s->buffer[index], (unsigned char*)&input[i], inputLen - i);\n}\n/******************************************************************************/\n//    名称：MD5_Final\n//    功能：MD5最后变换\n//  参数：strContent:指向文件内容缓冲区; iLength:文件内容长度; output:摘要输出缓冲区\n//    返回：无\n/******************************************************************************/\nvoid MD5_Final(MD5_State *s, unsigned char digest[16])\n{\n    unsigned char bits[8];\n    unsigned int index, padLen;\n    Encode(bits, s->count, 8);\n    //! 长度小于448位(mod 512),对明文进行填充\n    index = (unsigned int)((s->count[0] >> 3) & 0x3f);\n    padLen = (index < 56) ? (56 - index) : (120 - index);\n    MD5_Update(s, s->PADDING, padLen);\n    MD5_Update(s, bits, 8);\n    Encode(digest, s->state, 16);\n    MD5_memset((unsigned char*)s, 0, sizeof(*s));\n    MD5_Init(s);\n}\n/******************************************************************************/\n//    名称：SHA_digest\n//    功能：生成文件摘要\n//  参数：strContent:指向文件内容缓冲区; iLength:文件内容长度; output:摘要输出缓冲区\n//    返回：无\n/******************************************************************************/\nvoid md5_digest(void const *strContent, unsigned int iLength, unsigned char output[16])\n{\n    unsigned char *q = (unsigned char*)strContent;\n    MD5_State s;\n    MD5_Init(&s);\n    MD5_Update(&s, q, iLength);\n    MD5_Final(&s, output);\n}\nint main(int argc, char* argv[])\n{\n    unsigned char output[16] = { 0 };\n    int i = 0;\n    //md5_digest(\"device0FCAA1460F12C\", strlen(\"device0FCAA1460F12C\"), output);\n    md5_digest(\"pediywww.pediy.com\", strlen(\"pediywww.pediy.com\"), output);\n    for (i = 0; i < 16; i++)\n    {\n        printf(\"%02x\", output[i]);\n    }\n    printf(\"\\r\\n\");\n    char table[0x20] = { \"3456789ABCDEFGHJKLMNPQRSTUVWXYZ\" };\n    char serial[0x20] = { 0 };\n    for (int i = 0; i < 0x10; i++)\n    {\n        int j = output[i] & 0x1f;\n        serial[i] = table[j];\n    }\n    printf(serial);\n    return 0;\n}\n```\n\n测试成功。\n总结一下识别Md5的关键特征：\n1）四个初始化的常量0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476\n2）4轮运算","tags":["reverse"],"categories":["reverse"]},{"title":"算法识别之Base64","url":"/2016/12/07/算法识别之Base64/","content":"\n## Base64简介\n> Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。> 3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。\n> ——维基百科\n它不是一种加解密技术，只是一种简单的编解码技术。Base64 常用于表示、传输、存储二进制数据，也可以用于将一些含有特殊字符的文本内容编码，以便传输。特征是最后面可能有=，同时编码只有a-zA-Z0-9+/字符\n\n## 实例分析\nbase64 C实现代码如下\n```c\n#include \"base64.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n *  转解码过程\n *  3 * 8 = 4 * 6; 3字节占24位, 4*6=24\n *  先将要编码的转成对应的ASCII值\n *  如编码: s 1 3\n *  对应ASCII值为: 115 49 51\n *  对应二进制为: 01110011 00110001 00110011\n *  将其6个分组分4组: 011100 110011 000100 110011\n *  而计算机是以8bit存储, 所以在每组的高位补两个0如下:\n *  00011100 00110011 00000100 00110011对应:28 51 4 51\n *  查找base64 转换表 对应 c z E z\n *\n *  解码\n *  c z E z\n *  对应ASCII值为 99 122 69 122\n *  对应表base64_suffix_map的值为 28 51 4 51\n *  对应二进制值为 00011100 00110011 00000100 00110011\n *  依次去除每组的前两位, 再拼接成3字节\n *  即: 01110011 00110001 00110011\n *  对应的就是s 1 3\n */\n\n#define BASE64_PAD '='\n#define BASE64DE_FIRST '+'\n#define BASE64DE_LAST 'z'\n\n/* BASE 64 encode table */\nstatic const char base64en[] = {\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n        'w', 'x', 'y', 'z', '0', '1', '2', '3',\n        '4', '5', '6', '7', '8', '9', '+', '/',\n};\n\n/* ASCII order for BASE 64 decode, 255 in unused character */\nstatic const unsigned char base64de[] = {\n        /* nul, soh, stx, etx, eot, enq, ack, bel, */\n        255, 255, 255, 255, 255, 255, 255, 255,\n\n        /*  bs,  ht,  nl,  vt,  np,  cr,  so,  si, */\n        255, 255, 255, 255, 255, 255, 255, 255,\n\n        /* dle, dc1, dc2, dc3, dc4, nak, syn, etb, */\n        255, 255, 255, 255, 255, 255, 255, 255,\n\n        /* can,  em, sub, esc,  fs,  gs,  rs,  us, */\n        255, 255, 255, 255, 255, 255, 255, 255,\n\n        /*  sp, '!', '\"', '#', '$', '%', '&', ''', */\n        255, 255, 255, 255, 255, 255, 255, 255,\n\n        /* '(', ')', '*', '+', ',', '-', '.', '/', */\n        255, 255, 255,  62, 255, 255, 255,  63,\n\n        /* '0', '1', '2', '3', '4', '5', '6', '7', */\n        52,  53,  54,  55,  56,  57,  58,  59,\n\n        /* '8', '9', ':', ';', '<', '=', '>', '?', */\n        60,  61, 255, 255, 255, 255, 255, 255,\n\n        /* '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', */\n        255,   0,   1,  2,   3,   4,   5,    6,\n\n        /* 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', */\n        7,   8,   9,  10,  11,  12,  13,  14,\n\n        /* 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', */\n        15,  16,  17,  18,  19,  20,  21,  22,\n\n        /* 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', */\n        23,  24,  25, 255, 255, 255, 255, 255,\n\n        /* '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', */\n        255,  26,  27,  28,  29,  30,  31,  32,\n\n        /* 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', */\n        33,  34,  35,  36,  37,  38,  39,  40,\n\n        /* 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', */\n        41,  42,  43,  44,  45,  46,  47,  48,\n\n        /* 'x', 'y', 'z', '{', '|', '}', '~', del, */\n        49,  50,  51, 255, 255, 255, 255, 255\n};\n\nunsigned int\nbase64_encode(const unsigned char *in, unsigned int inlen, char *out)\n{\n    int s;\n    unsigned int i;\n    unsigned int j;\n    unsigned char c;\n    unsigned char l;\n\n    s = 0;\n    l = 0;\n    for (i = j = 0; i < inlen; i++) {\n        c = in[i];\n\n        switch (s) {\n            case 0:\n                s = 1;\n                out[j++] = base64en[(c >> 2) & 0x3F];\n                break;\n            case 1:\n                s = 2;\n                out[j++] = base64en[((l & 0x3) << 4) | ((c >> 4) & 0xF)];\n                break;\n            case 2:\n                s = 0;\n                out[j++] = base64en[((l & 0xF) << 2) | ((c >> 6) & 0x3)];\n                out[j++] = base64en[c & 0x3F];\n                break;\n        }\n        l = c;\n    }\n\n    switch (s) {\n        case 1:\n            out[j++] = base64en[(l & 0x3) << 4];\n            out[j++] = BASE64_PAD;\n            out[j++] = BASE64_PAD;\n            break;\n        case 2:\n            out[j++] = base64en[(l & 0xF) << 2];\n            out[j++] = BASE64_PAD;\n            break;\n    }\n\n    out[j] = 0;\n\n    return j;\n}\n\nunsigned int\nbase64_decode(const char *in, unsigned int inlen, unsigned char *out)\n{\n    unsigned int i;\n    unsigned int j;\n    unsigned char c;\n\n    if (inlen & 0x3) {\n        return 0;\n    }\n\n    for (i = j = 0; i < inlen; i++) {\n        if (in[i] == BASE64_PAD) {\n            break;\n        }\n        if (in[i] < BASE64DE_FIRST || in[i] > BASE64DE_LAST) {\n            return 0;\n        }\n\n        c = base64de[(unsigned char)in[i]];\n        if (c == 255) {\n            return 0;\n        }\n\n        switch (i & 0x3) {\n            case 0:\n                out[j] = (c << 2) & 0xFF;\n                break;\n            case 1:\n                out[j++] |= (c >> 4) & 0x3;\n                out[j] = (c & 0xF) << 4;\n                break;\n            case 2:\n                out[j++] |= (c >> 2) & 0xF;\n                out[j] = (c & 0x3) << 6;\n                break;\n            case 3:\n                out[j++] |= c;\n                break;\n        }\n    }\n\n    return j;\n}\n```\n\n```c\n#define BASE64_ENCODE_OUT_SIZE(s) ((unsigned int)((((s) + 2) / 3) * 4 + 1))\n#define BASE64_DECODE_OUT_SIZE(s) ((unsigned int)(((s) / 4) * 3))\n\n/*\n * out is null-terminated encode string.\n * return values is out length, exclusive terminating `\\0'\n */\nunsigned int\nbase64_encode(const unsigned char *in, unsigned int inlen, char *out);\n\n/*\n * return values is out length\n */\nunsigned int\nbase64_decode(const char *in, unsigned int inlen, unsigned char *out);\n```\n\n编译一个bin出来，base64比较简单就不调试了，直接使用IDA静态分析\n解码函数\n{% asset_img base64_1.jpg %}\n编码函数\n{% asset_img base64_2.jpg %}\n看一眼伪代码，可以很明显的看见Base64使用的两张表，可以拷贝出来与原始Base64表进行对比，判断是否使用了Base64编码。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(八)","url":"/2016/12/06/逆向笔记-八/","content":"\n这是最后一篇了，大体就是这样，有遗漏的部分后续会继续补充，接下来在整理一些常用算法识别的相关内容。\n如果碰巧有各位大大看到了欢迎指点一二，谢谢。\n\n逆向笔记之虚函数，继承与多重继承。\n\n## 虚函数\n\n对象的多态性需要通过虚表和虚表指针来完成，虚表指针被定义在对象首地址的前4字节处，因此虚函数必须作为函数成员函数使用。因为非成员函数没有this指针，无法获取虚表指针，也就无法获取虚表，也就无法访问虚函数。\n\n### 虚函数的机制\n\n在C++中，使用关键字virtual声明函数为虚函数。当类中定义有虚函数时，编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。同时编译器还会在类中添加一个隐藏数据成员，称为虚表指针。该指针保存着虚表首地址，用于记录和查找虚函数。\n\n\nC代码：\n\n```c\nclass CVirtual\n{\npublic:\n    virtual int GetNum()\n    {\n        return m_nNum;\n    }\n    virtual void SetNum(int nNum)\n    {\n        m_nNum = nNum;\n    }\nprivate:\n    int m_nNum;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nSize = sizeof(CVirtual);\nCVirtual ogj;\n    return 0;\n}\n```\n\n这里定义了两个虚函数和一个数据成员。这里类的的大小为8，因为定义了虚函数后，含有虚表指针。\n\n\n对应反汇编Debug：\n\n```\nMain函数\n01111B20 >  55              push ebp\n01111B21    8BEC            mov ebp,esp\n01111B23    81EC DC000000   sub esp,0xDC\n01111B29    53              push ebx\n01111B2A    56              push esi\n01111B2B    57              push edi\n01111B2C    8DBD 24FFFFFF   lea edi,dword ptr ss:[ebp-0xDC]\n01111B32    B9 37000000     mov ecx,0x37\n01111B37    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01111B3C    F3:AB           rep stos dword ptr es:[edi]\n01111B3E    C745 F8 0800000>mov dword ptr ss:[ebp-0x8],0x8\n01111B45    8D4D E8         lea ecx,dword ptr ss:[ebp-0x18] //获取对象首地址\n01111B48    E8 CFF6FFFF     call TestCode.0111121C //调用构造函数，这里调用的是编译器提供的默认构造函数\n01111B4D    33C0            xor eax,eax\n01111B4F    52              push edx\n01111B50    8BCD            mov ecx,ebp\n01111B52    50              push eax\n01111B53    8D15 741B1101   lea edx,dword ptr ds:[0x1111B74]\n01111B59    E8 42F5FFFF     call TestCode.011110A0\n01111B5E    58              pop eax\n01111B5F    5A              pop edx\n01111B60    5F              pop edi\n01111B61    5E              pop esi\n01111B62    5B              pop ebx\n01111B63    81C4 DC000000   add esp,0xDC\n01111B69    3BEC            cmp ebp,esp\n01111B6B    E8 11F6FFFF     call TestCode.01111181\n01111B70    8BE5            mov esp,ebp\n01111B72    5D              pop ebp\n01111B73    C3              retn\n默认构造函数\n011115A0 >  55              push ebp\n011115A1    8BEC            mov ebp,esp\n011115A3    81EC CC000000   sub esp,0xCC\n011115A9    53              push ebx\n011115AA    56              push esi\n011115AB    57              push edi\n011115AC    51              push ecx\n011115AD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n011115B3    B9 33000000     mov ecx,0x33\n011115B8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n011115BD    F3:AB           rep stos dword ptr es:[edi]\n011115BF    59              pop ecx //还原this指针\n011115C0    894D F8         mov dword ptr ss:[ebp-0x8],ecx \n011115C3    8B45 F8         mov eax,dword ptr ss:[ebp-0x8] //eax为this指针\n011115C6    C700 88781101   mov dword ptr ds:[eax],offset TestCode.CVirtual::`vftable' //保存虚表指针\n011115CC    8B45 F8         mov eax,dword ptr ss:[ebp-0x8] //返回this指针\n011115CF    5F              pop edi\n011115D0    5E              pop esi\n011115D1    5B              pop ebx\n011115D2    8BE5            mov esp,ebp\n011115D4    5D              pop ebp\n011115D5    C3              retn\n```\n\n虚函数的识别\n在判断是否为虚函数时，我们需要鉴别类中是否出现这样的特征：\n1）类中隐式定义了一个数据成员\n2）该数据成员在首地址处，占4个字节\n3）构造函数会将此数据成员初始化为某个数组的首地址\n4）这个地址属于数据区，是相对固定的地址\n5）在这个数组内，每个元素都是函数指针\n6）这些函数在调用时第一个参数必然为this指针\n7）在这些函数内部，很有可能会对this指针使用相对间接寻址的访问方式\n\n## 从内存角度看继承和多重继承\n\n识别类和类之间的关系\n在C++的继承关系中，子类具备父类所有的成员数据和成员函数。子类对象可以直接使用父类中声明为公有和保护的数据成员和成员函数。在父类中声明为私有（private）的成员，虽然子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。C++语法规定的访问控制仅限于编译层面，在编译的过程中由编译器进行语法检查，因此访问控制不会影响对象的内存结构。\n\nC代码：\n\n```c\nclass CBase\n{\npublic:\n    CBase()\n    {\n        printf(\"CBase\\n\");\n    }\n    ~CBase()\n    {\n        printf(\"~CBase\\n\");\n    }\n    \n    void SetNum(int nNum)\n    {\n        m_nBase = nNum;\n    }\n    int GetNum()\n    {\n        return m_nBase;\n    }\n    int m_nBase;\n};\nclass CDervie : public CBase\n{\npublic:\n    void ShowNum(int nNum)\n    {\n        SetNum(nNum);\n        m_nDervie = nNum + 1;\n        printf(\"%d\\n\", GetNum());\n        printf(\"%d\\n\", m_nDervie);\n    }\n    \n    int m_nDervie;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CDervie obj;\n    obj.ShowNum(argc);\n    return 0;\n}\n```\n\n对应反汇编Debug:\n\n```\nMain函数\n00AF1D10 >  55              push ebp\n00AF1D11    8BEC            mov ebp,esp\n00AF1D13    6A FF           push -0x1\n00AF1D15    68 A855AF00     push TestCode.00AF55A8\n00AF1D1A    64:A1 00000000  mov eax,dword ptr fs:[0]\n00AF1D20    50              push eax\n00AF1D21    81EC DC000000   sub esp,0xDC\n00AF1D27    53              push ebx\n00AF1D28    56              push esi\n00AF1D29    57              push edi\n00AF1D2A    8DBD 18FFFFFF   lea edi,dword ptr ss:[ebp-0xE8]\n00AF1D30    B9 37000000     mov ecx,0x37\n00AF1D35    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00AF1D3A    F3:AB           rep stos dword ptr es:[edi]\n00AF1D3C    A1 04A0AF00     mov eax,dword ptr ds:[__security_cookie]\n00AF1D41    33C5            xor eax,ebp\n00AF1D43    50              push eax\n00AF1D44    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00AF1D47    64:A3 00000000  mov dword ptr fs:[0],eax\n00AF1D4D    8D4D E8         lea ecx,dword ptr ss:[ebp-0x18]//取对象首地址\n00AF1D50    E8 E7F2FFFF     call TestCode.00AF103C//调用子类构造函数\n00AF1D55    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n00AF1D5C    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00AF1D5F    50              push eax\n00AF1D60    8D4D E8         lea ecx,dword ptr ss:[ebp-0x18] //取对象首地址\n00AF1D63    E8 B1F2FFFF     call TestCode.00AF1019 //调用ShowNum函数\n00AF1D68    C785 1CFFFFFF 0>mov dword ptr ss:[ebp-0xE4],0x0\n00AF1D72    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00AF1D79    8D4D E8         lea ecx,dword ptr ss:[ebp-0x18]\n00AF1D7C    E8 B6F2FFFF     call TestCode.00AF1037 //调用子类析构函数\n00AF1D81    8B85 1CFFFFFF   mov eax,dword ptr ss:[ebp-0xE4]\n00AF1D87    52              push edx\n00AF1D88    8BCD            mov ecx,ebp\n00AF1D8A    50              push eax\n00AF1D8B    8D15 B81DAF00   lea edx,dword ptr ds:[0xAF1DB8]\n00AF1D91    E8 19F3FFFF     call TestCode.00AF10AF\n00AF1D96    58              pop eax\n00AF1D97    5A              pop edx\n00AF1D98    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00AF1D9B    64:890D 0000000>mov dword ptr fs:[0],ecx\n00AF1DA2    59              pop ecx\n00AF1DA3    5F              pop edi\n00AF1DA4    5E              pop esi\n00AF1DA5    5B              pop ebx\n00AF1DA6    81C4 E8000000   add esp,0xE8\n00AF1DAC    3BEC            cmp ebp,esp\n00AF1DAE    E8 D3F3FFFF     call TestCode.00AF1186\n00AF1DB3    8BE5            mov esp,ebp\n00AF1DB5    5D              pop ebp\n00AF1DB6    C3              retn\n构造函数\n00AF1500 >  55              push ebp\n00AF1501    8BEC            mov ebp,esp\n00AF1503    81EC CC000000   sub esp,0xCC\n00AF1509    53              push ebx\n00AF150A    56              push esi\n00AF150B    57              push edi\n00AF150C    51              push ecx\n00AF150D    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00AF1513    B9 33000000     mov ecx,0x33\n00AF1518    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00AF151D    F3:AB           rep stos dword ptr es:[edi]\n00AF151F    59              pop ecx //还原this指针\n00AF1520    894D F8         mov dword ptr ss:[ebp-0x8],ecx\n00AF1523    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8] //this指针给ecx \n00AF1526    E8 6FFCFFFF     call TestCode.00AF119A //调用父类构造函数\n00AF152B    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00AF152E    5F              pop edi\n00AF152F    5E              pop esi\n00AF1530    5B              pop ebx\n00AF1531    81C4 CC000000   add esp,0xCC\n00AF1537    3BEC            cmp ebp,esp\n00AF1539    E8 48FCFFFF     call TestCode.00AF1186\n00AF153E    8BE5            mov esp,ebp\n00AF1540    5D              pop ebp\n00AF1541    C3              retn\n析构函数\n00AF16D0 >  55              push ebp\n00AF16D1    8BEC            mov ebp,esp\n00AF16D3    81EC CC000000   sub esp,0xCC\n00AF16D9    53              push ebx\n00AF16DA    56              push esi\n00AF16DB    57              push edi\n00AF16DC    51              push ecx\n00AF16DD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00AF16E3    B9 33000000     mov ecx,0x33\n00AF16E8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00AF16ED    F3:AB           rep stos dword ptr es:[edi]\n00AF16EF    59              pop ecx\n00AF16F0    894D F8         mov dword ptr ss:[ebp-0x8],ecx\n00AF16F3    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8]//this指针给ecx \n00AF16F6    E8 32F9FFFF     call TestCode.00AF102D //调用父类析构函数\n00AF16FB    5F              pop edi\n00AF16FC    5E              pop esi\n00AF16FD    5B              pop ebx\n00AF16FE    81C4 CC000000   add esp,0xCC\n00AF1704    3BEC            cmp ebp,esp\n00AF1706    E8 7BFAFFFF     call TestCode.00AF1186\n00AF170B    8BE5            mov esp,ebp\n00AF170D    5D              pop ebp\n00AF170E    C3              retn\n```\n\n由此可以看出当子类中没有构造函数或析构函数，而其父类却需要构造函数与析构函数时，编译器会为该父类的子类提供默认的构造函数与析构函数。还可以看出子类对象在内存中的数据排列方式，先安排父类的数据，然后安排子类新定义的数据。\n\n接着来看一下当类中定义了其他对象作为成员，并在初始化列表中指定了某个成员的初始化值时构造的顺序。\n\n\nC代码：\n\n```c\nclass CBase\n{\npublic:\n    CBase()\n        {\n            printf(\"CBase\\n\");\n        }\n        ~CBase()\n        {\n            printf(\"~CBase\\n\");\n        }\n        \n    void SetNum(int nNum)\n    {\n        m_nBase = nNum;\n    }\n    int GetNum()\n    {\n        return m_nBase;\n    }\n    int m_nBase;\n};\nclass CInit\n{\npublic:\n    CInit()\n    {\n        m_nNum = 0;\n    }\n    int m_nNum;\n};\nclass CDervie : public CBase\n{\npublic:\nCDervie() : m_nDervie(1)//初始化列表\n    {\n        printf(\"CDervie\\n\");\n    }\n    CInit m_Init;\n    int m_nDervie;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CDervie obj;\n    obj.ShowNum(argc);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n子类构造函数\n00051C90 >  55              push ebp\n00051C91    8BEC            mov ebp,esp\n00051C93    6A FF           push -0x1\n00051C95    68 78550500     push TestCode.00055578\n00051C9A    64:A1 00000000  mov eax,dword ptr fs:[0]\n00051CA0    50              push eax\n00051CA1    81EC CC000000   sub esp,0xCC\n00051CA7    53              push ebx\n00051CA8    56              push esi\n00051CA9    57              push edi\n00051CAA    51              push ecx\n00051CAB    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00051CB1    B9 33000000     mov ecx,0x33\n00051CB6    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00051CBB    F3:AB           rep stos dword ptr es:[edi]\n00051CBD    59              pop ecx  //还原this指针\n00051CBE    A1 04A00500     mov eax,dword ptr ds:[__security_cookie]\n00051CC3    33C5            xor eax,ebp\n00051CC5    50              push eax\n00051CC6    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00051CC9    64:A3 00000000  mov dword ptr fs:[0],eax\n00051CCF    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n00051CD2    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14] //this指针给ecx\n00051CD5    E8 74F5FFFF     call TestCode.0005124E //调用父类构造函数\n00051CDA    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n00051CE1    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14] //this指针给ecx\n00051CE4    83C1 04         add ecx,0x4 //ecx + 4\n00051CE7    E8 58F5FFFF     call TestCode.00051244 //调用CInit构造函数\n00051CEC    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00051CEF    C740 08 0100000>mov dword ptr ds:[eax+0x8],0x1 //初始化数据成员\n00051CF6    8BF4            mov esi,esp\n00051CF8    68 98780500     push TestCode.00057898                   ; ASCII \"CDervie\\n\"\n00051CFD    FF15 1CB10500   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00051D03    83C4 04         add esp,0x4\n00051D06    3BF4            cmp esi,esp\n00051D08    E8 79F4FFFF     call TestCode.00051186\n00051D0D    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00051D14    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00051D17    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00051D1A    64:890D 0000000>mov dword ptr fs:[0],ecx\n00051D21    59              pop ecx\n00051D22    5F              pop edi\n00051D23    5E              pop esi\n00051D24    5B              pop ebx\n00051D25    81C4 D8000000   add esp,0xD8\n00051D2B    3BEC            cmp ebp,esp\n00051D2D    E8 54F4FFFF     call TestCode.00051186\n00051D32    8BE5            mov esp,ebp\n00051D34    5D              pop ebp\n00051D35    C3              retn\n```\n\n由此可以看出在有初始化列表的情况下，将会优先执行初始化列表中的操作，其次才是自身的构造函数。构造的顺序为：先构造父类，然后按声明顺序构造成员对象和初始化列表中的指定成员，最后才是自身的构造函数。\n\n因为有虚表指针，调用虚函数的方式改为查表并间接调用，在虚表中得到函数首地址并跳转到此地址处执行代码。利用此特性即可通过父类指针访问不同的派生类。在调用父类中定义的虚函数时，根据指针所指向的对象中的虚表指针，可得到虚表信息，间接调用虚函数，即构成多态。具体看个例子吧。\n\n```c\nC代码：\nclass CPerson\n{\npublic:\n    CPerson(){}\n    virtual ~CPerson(){}\n    virtual void ShowSpeak(){}\n};\nclass CChinese : public CPerson\n{\npublic:\n    CChinese(){}\n    virtual ~CChinese(){}\n    virtual void ShowSpeak()\n    {\n        printf(\"chinese\\n\");\n    }\n};\nclass CAmerican : public CPerson\n{\npublic:\n    CAmerican(){}\n    virtual ~CAmerican(){}\n    virtual void ShowSpeak()\n    {\n        printf(\"CAmerican\\n\");\n    }\n};\nvoid Speak(CPerson *obj)\n{\n    obj->ShowSpeak();\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CChinese chinese;\n    CAmerican american;\n    Speak(&chinese);\n    Speak(&american);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nSpeak入口\n00A61FF8    8D45 EC         lea eax,dword ptr ss:[ebp-0x14] //取对象首地址\n00A61FFB    50              push eax //压栈\n00A61FFC    E8 26F1FFFF     call TestCode.00A61127 //调用\n00A62001    83C4 04         add esp,0x4 //堆栈平衡\nSpeak函数实现\n00A61F40 >  55              push ebp\n00A61F41    8BEC            mov ebp,esp\n00A61F43    81EC C0000000   sub esp,0xC0\n00A61F49    53              push ebx\n00A61F4A    56              push esi\n00A61F4B    57              push edi\n00A61F4C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n00A61F52    B9 30000000     mov ecx,0x30\n00A61F57    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00A61F5C    F3:AB           rep stos dword ptr es:[edi]\n00A61F5E    8B45 08         mov eax,dword ptr ss:[ebp+0x8] //参数给eax\n00A61F61    8B10            mov edx,dword ptr ds:[eax] //取eax内容给edx，也就是虚表首地址\n00A61F63    8BF4            mov esi,esp\n00A61F65    8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]\n00A61F68    8B42 04         mov eax,dword ptr ds:[edx+0x4] //寻址虚表第二项\n00A61F6B    FFD0            call eax //调用speak\n00A61F6D    3BF4            cmp esi,esp\n00A61F6F    E8 49F2FFFF     call TestCode.00A611BD\n00A61F74    5F              pop edi\n00A61F75    5E              pop esi\n00A61F76    5B              pop ebx\n00A61F77    81C4 C0000000   add esp,0xC0\n00A61F7D    3BEC            cmp ebp,esp\n00A61F7F    E8 39F2FFFF     call TestCode.00A611BD\n00A61F84    8BE5            mov esp,ebp\n00A61F86    5D              pop ebp\n00A61F87    C3              retn\n```\n\n由此可以看出虚函数的调用过程使用了间接寻找方式 。还有要将析构函数定义为虚函数，因为父类指针保存子类对象的首地址，因此当使用父类指针指向子类堆对象时会出问题。当使用delete释放对象空间时，如果析构函数没有被定义为虚函数，编译器将会按指针的类型调用父类析构函数也会出问题。而使用虚析构函数后会访问虚表并调用对象的析构函数。\n\n## 多重继承\n\n直接看例子。\n\n\nC代码：\n\n```c\nclass CSofa\n{\npublic:\n    CSofa()\n    {\n        m_nColor = 2;\n    }\n    virtual ~CSofa()\n    {\n        printf(\"virtual ~CSofa\\n\");\n    }\n    virtual int GetColor()\n    {\n        return m_nColor;\n    }\n    virtual int SitDowm()\n    {\n        return printf(\"SitDowm\\n\");\n    }\n    int m_nColor;\n};\nclass CBed\n{\npublic:\n    CBed()\n    {\n        m_nLength = 4;\n        m_nWidth = 5;\n    }\n    virtual ~CBed()\n    {\n        printf(\"virtual ~CBed\\n\");\n    }\n    virtual int GetArea()\n    {\n        return m_nLength * m_nWidth;\n    }\n    virtual int Sleep()\n    {\n        return printf(\"goto sleep\\n\");\n    }\n    int m_nLength;\n    int m_nWidth;\n};\nclass CSofaBed : public CSofa,public CBed\n{\npublic:\n    CSofaBed()\n    {\n        m_nHeight = 6;\n    }\n    virtual ~CSofaBed()\n    {\n        printf(\"virtual ~CSofaBed\\n\");\n    }\n    virtual int SitDowm()\n    {\n        return printf(\"SitDowm\\n\");\n    }\n    virtual int Sleep()\n    {\n        return printf(\"goto sleep\\n\");\n    }\n    virtual int GetHeight()\n    {\n        return m_nHeight;\n    }\n    int m_nHeight;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CSofaBed obj;\n    int n = sizeof(obj); \n    return 0;\n}\n```\n\n这里对象大小为24,内存布局如下\n\n\n由此可以看出数据成员的排列顺序由继承父类的先后顺序决定，从左向右依次排列。此外内存中的两个地址是虚表指针。\n\n\n对应反汇编Debug：\n\n```\nCSofaBed构造函数\n00C149E0 >  55              push ebp\n00C149E1    8BEC            mov ebp,esp\n00C149E3    6A FF           push -0x1\n00C149E5    68 A85AC100     push TestCode.00C15AA8\n00C149EA    64:A1 00000000  mov eax,dword ptr fs:[0]\n00C149F0    50              push eax\n00C149F1    81EC CC000000   sub esp,0xCC\n00C149F7    53              push ebx\n00C149F8    56              push esi\n00C149F9    57              push edi\n00C149FA    51              push ecx\n00C149FB    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00C14A01    B9 33000000     mov ecx,0x33\n00C14A06    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00C14A0B    F3:AB           rep stos dword ptr es:[edi]\n00C14A0D    59              pop ecx //还原this指针\n00C14A0E    A1 04A0C100     mov eax,dword ptr ds:[__security_cookie]\n00C14A13    33C5            xor eax,ebp\n00C14A15    50              push eax\n00C14A16    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00C14A19    64:A3 00000000  mov dword ptr fs:[0],eax\n00C14A1F    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n00C14A22    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n00C14A25    E8 ABC8FFFF     call TestCode.00C112D5 //调用父类CSofa构造函数\n00C14A2A    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n00C14A31    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n00C14A34    83C1 08         add ecx,0x8 //调整this指针到第二个虚表指针地址处\n00C14A37    E8 B2C8FFFF     call TestCode.00C112EE //调用父类CBed构造函数\n00C14A3C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14] //this指针给eax\n00C14A3F    C700 507AC100   mov dword ptr ds:[eax],offset TestCode.CSofaBed::`vftable' //写入虚表指针\n00C14A45    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C14A48    C740 08 A479C10>mov dword ptr ds:[eax+0x8],offset TestCode.CSofaBed::`vftable' //写入虚表指针\n00C14A4F    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C14A52    C740 14 0600000>mov dword ptr ds:[eax+0x14],0x6\n00C14A59    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00C14A60    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C14A63    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00C14A66    64:890D 0000000>mov dword ptr fs:[0],ecx\n00C14A6D    59              pop ecx\n00C14A6E    5F              pop edi\n00C14A6F    5E              pop esi\n00C14A70    5B              pop ebx\n00C14A71    81C4 D8000000   add esp,0xD8\n00C14A77    3BEC            cmp ebp,esp\n00C14A79    E8 3FC7FFFF     call TestCode.00C111BD\n00C14A7E    8BE5            mov esp,ebp\n00C14A80    5D              pop ebp\n00C14A81    C3              retn\n```\n\n由此可以看出根据继承关系的顺序首先调用父类CSofa构造函数，在调用另一个父类CBed时，并不是直接将对象首地址做this指针传递，而是向后调整父类CSofa大小，用调整后的值做this指针调用构造。由于有两个父类，因此子类在继承时也将他们的虚表指针一起继承过来，也就有了两个虚表指针。可见，在多重继承中，子类虚表指针的个数取决于所继承父类的个数。\n\n再来看看析构过程。\n\n\n对应反汇编Debug：\n\n```\n00C11E70 >  55              push ebp\n00C11E71    8BEC            mov ebp,esp\n00C11E73    6A FF           push -0x1\n00C11E75    68 085BC100     push TestCode.00C15B08\n00C11E7A    64:A1 00000000  mov eax,dword ptr fs:[0]\n00C11E80    50              push eax\n00C11E81    81EC CC000000   sub esp,0xCC\n00C11E87    53              push ebx\n00C11E88    56              push esi\n00C11E89    57              push edi\n00C11E8A    51              push ecx\n00C11E8B    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00C11E91    B9 33000000     mov ecx,0x33\n00C11E96    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00C11E9B    F3:AB           rep stos dword ptr es:[edi]\n00C11E9D    59              pop ecx //还原this指针\n00C11E9E    A1 04A0C100     mov eax,dword ptr ds:[__security_cookie]\n00C11EA3    33C5            xor eax,ebp\n00C11EA5    50              push eax\n00C11EA6    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00C11EA9    64:A3 00000000  mov dword ptr fs:[0],eax\n00C11EAF    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n00C11EB2    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C11EB5    C700 507AC100   mov dword ptr ds:[eax],offset TestCode.CSofaBed::`vftable' \n00C11EBB    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C11EBE    C740 08 A479C10>mov dword ptr ds:[eax+0x8],offset TestCode.CSofaBed::`vftable' //将两个虚表指针设置为各个父类的虚表首地址\n00C11EC5    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n00C11ECC    8BF4            mov esi,esp\n00C11ECE    68 507BC100     push TestCode.00C17B50                                                          ; ASCII \"virtual ~CSofaBed\\n\"\n00C11ED3    FF15 20B1C100   call dword ptr ds:[<&MSVCR120D.printf>]                                         ; MSVCR120.printf\n00C11ED9    83C4 04         add esp,0x4\n00C11EDC    3BF4            cmp esi,esp\n00C11EDE    E8 DAF2FFFF     call TestCode.00C111BD\n00C11EE3    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n00C11EE6    83C1 08         add ecx,0x8 //调整this指针\n00C11EE9    E8 D3F3FFFF     call TestCode.00C112C1 //调用CBed析构\n00C11EEE    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00C11EF5    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n00C11EF8    E8 ECF3FFFF     call TestCode.00C112E9 //调用CSofa析构\n00C11EFD    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00C11F00    64:890D 0000000>mov dword ptr fs:[0],ecx\n00C11F07    59              pop ecx\n00C11F08    5F              pop edi\n00C11F09    5E              pop esi\n00C11F0A    5B              pop ebx\n00C11F0B    81C4 D8000000   add esp,0xD8\n00C11F11    3BEC            cmp ebp,esp\n00C11F13    E8 A5F2FFFF     call TestCode.00C111BD\n00C11F18    8BE5            mov esp,ebp\n00C11F1A    5D              pop ebp\n00C11F1B    C3              retn\n```\n\n由此可以看出具有多个同级父类，因此在子类中产生多个虚表指针。在对父类进行析构时，需要设置this指针用于调用父类析构函数。由于具有多个父类，当在析构的过程中调用哥哥父类的析构函数时，传递的首地址将有所不同，编译器会根据每个父类在对象中占用的空间位置，对应传入各个父类部分的首地址作为this指针。\n\n## 单继承类与多继承类特征总结：\n\n单继承类\n在类对象占用的内存空间中，只保存一份虚表指针\n由于只有一个虚表指针，对应的只有一个虚表\n虚表中各项保存了类中虚函数的首地址\n构造时先构造父类，在构造自身，并且只调用一次父类构造函数\n析构时先析构自身，在析构父类，并且只调用一次父类析构函数\n\n多重继承类\n在类对象所占用的内存空间中，根据继承父类的个数保存对应的虚表指针\n根据所保存的虚表指针个数，对应产生相应个数的虚表\n转换父类指针时，需要跳转到对象的首地址\n构造时需要调用多个父类构造函数\n构造时先构造继承列表中第一个父类，然后依次调用到最后一个继承的父类构造函数\n析构时先析构自身，然后以与构造函数相反的顺序调用所有父类的析构函数\n当对象作为成员时，整个类对象的内存结构和多重继承很相似。当类中无虚函数时，整个类 对象内存结构和多重继承完全一样，当父类或成员对象存在虚函数时，通过观察虚表指针的 位置和构造函数，析构函数中填写虚表指针的数目及目标地址，来还原继承或成员关系。\n\n虚基类\n虚基类也被称为抽象类。虚基类的定义需要配合虚函数使用，在虚函数的声明结尾处添加“=0”，这种虚函数被称为纯虚函数，纯虚函数是一个没有实现只有声明的函数，他的存在是为了让类具有虚基类的功能，让继承虚基类的子类都具有虚表以及虚表指针。\n\n直接看例子。\n\nC代码：\n\n```c\nclass CVirtualBase\n{\npublic:\n    virtual void Show() = 0;\n};\nclass CVirtualChild : public CVirtualBase\n{\npublic:\n    virtual void Show()\n    {\n        printf(\"CVirtualBase\");\n    }\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CVirtualChild obj;\n    obj.Show();\n    return 0;\n}\n```\n\n对应反汇编Debug：\n```\nCVirtualBase构造\n00CF15E0 >  55              push ebp\n00CF15E1    8BEC            mov ebp,esp\n00CF15E3    81EC CC000000   sub esp,0xCC\n00CF15E9    53              push ebx\n00CF15EA    56              push esi\n00CF15EB    57              push edi\n00CF15EC    51              push ecx\n00CF15ED    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00CF15F3    B9 33000000     mov ecx,0x33\n00CF15F8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00CF15FD    F3:AB           rep stos dword ptr es:[edi]\n00CF15FF    59              pop ecx\n00CF1600    894D F8         mov dword ptr ss:[ebp-0x8],ecx\n00CF1603    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00CF1606    C700 8878CF00   mov dword ptr ds:[eax],offset TestCode.CVirtualBase::`vftable' //设置虚表指针\n00CF160C    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00CF160F    5F              pop edi\n00CF1610    5E              pop esi\n00CF1611    5B              pop ebx\n00CF1612    8BE5            mov esp,ebp\n00CF1614    5D              pop ebp\n00CF1615    C3              retn\n\n```\n虚表中第一项所指向的函数地址\n\n\n由此可以看出在虚基类CVirtualBase的虚表信息中，由于虚函数没有实现代码，因此没有首地址，编译器为了防止误调用纯虚函数，将虚表中保存的纯虚函数首地址替换成函数_purecall，用于结束程序，并发出错误信息0x19。根据这个特性但凡在虚表中发现_purecall函数地址时，就可以高度怀疑此虚表对应的是一个虚基类。\n\n菱形继承\n菱形继承是最复杂的对象结构，菱形结构会将单一继承与多重继承进行组合，如下图所示\n\n\n直接看例子。\n\nC代码：\n```c\nclass CFurniture\n{\npublic:\n    CFurniture()\n    {\n        m_nPrice = 0;\n    }\n    virtual ~CFurniture()\n    {\n        printf(\"virtual ~CFurniture\\n\");\n    }\n    virtual int GetPrice()\n    {\n        return m_nPrice;\n    }\n    int m_nPrice;\n};\nclass CSofa : virtual public CFurniture\n{\npublic:\n    CSofa()\n    {\n        m_nPrice = 1;\n        m_nColor = 2;\n    }\n    virtual ~CSofa()\n    {\n        printf(\"virtual ~CSofa\\n\");\n    }\n    virtual int GetColor()\n    {\n        return m_nColor;\n    }\n    virtual int SitDowm()\n    {\n        return printf(\"SitDowm\\n\");\n    }\n    int m_nColor;\n};\nclass CBed : virtual public CFurniture\n{\npublic:\n    CBed()\n    {\n        m_nPrice = 3;\n        m_nLength = 4;\n        m_nWidth = 5;\n    }\n    virtual ~CBed()\n    {\n        printf(\"virtual ~CBed\\n\");\n    }\n    virtual int GetArea()\n    {\n        return m_nLength * m_nWidth;\n    }\n    virtual int Sleep()\n    {\n        return printf(\"goto sleep\\n\");\n    }\n    int m_nLength;\n    int m_nWidth;\n};\nclass CSofaBed : public CSofa,public CBed\n{\npublic:\n    CSofaBed()\n    {\n        m_nHeight = 6;\n    }\n    virtual ~CSofaBed()\n    {\n        printf(\"virtual ~CSofaBed\\n\");\n    }\n    virtual int SitDowm()\n    {\n        return printf(\"SitDowm\\n\");\n    }\n    virtual int Sleep()\n    {\n        return printf(\"goto sleep\\n\");\n    }\n    virtual int GetHeight()\n    {\n        return m_nHeight;\n    }\n    int m_nHeight;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CSofaBed obj;\n    return 0;\n}\n//加入父类指针转换后\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CSofaBed sofabed;\n    CFurniture *pFurniture = &sofabed;\n    CSofa *pSofa = &sofabed;\n    CBed *pBed = &sofabed;\n    return 0;\n}\n```\n\n首先看一下内存结构。\n\n\n依次为基类未定义的虚函数，基类定义虚函数偏移，数据成员，基类未定义的虚函数，基类定义虚函数偏移，数据成员，数据成员，数据成员，CFurniture定义，数据成员\n\n\n对应反汇编Debug：\n\n```\nMain函数\n01214D20 >  55              push ebp\n01214D21    8BEC            mov ebp,esp\n01214D23    81EC 24010000   sub esp,0x124\n01214D29    53              push ebx\n01214D2A    56              push esi\n01214D2B    57              push edi\n01214D2C    8DBD DCFEFFFF   lea edi,dword ptr ss:[ebp-0x124]\n01214D32    B9 49000000     mov ecx,0x49\n01214D37    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01214D3C    F3:AB           rep stos dword ptr es:[edi]\n01214D3E    6A 01           push 0x1 //是否构造祖父类的标志，true表示构造，false表示不构造\n01214D40    8D4D D4         lea ecx,dword ptr ss:[ebp-0x2C] //取对象首地址\n01214D43    E8 C9C5FFFF     call TestCode.01211311 //调用CSofaBed构造\n01214D48    8D45 D4         lea eax,dword ptr ss:[ebp-0x2C] //取对象首地址\n01214D4B    85C0            test eax,eax //检查\n01214D4D    75 0C           jnz short TestCode.01214D5B\n01214D4F    C785 DCFEFFFF 0>mov dword ptr ss:[ebp-0x124],0x0\n01214D59    EB 10           jmp short TestCode.01214D6B\n01214D5B    8B4D D8         mov ecx,dword ptr ss:[ebp-0x28] //取对象第二项数据vt_offset给ecx\n01214D5E    8B51 04         mov edx,dword ptr ds:[ecx+0x4] //取出偏移值给edx\n01214D61    8D4415 D8       lea eax,dword ptr ss:[ebp+edx-0x28] //得到祖父类数据所在地址\n01214D65    8985 DCFEFFFF   mov dword ptr ss:[ebp-0x124],eax //保存\n01214D6B    8B8D DCFEFFFF   mov ecx,dword ptr ss:[ebp-0x124] //赋值pFurniture\n01214D71    894D C8         mov dword ptr ss:[ebp-0x38],ecx\n01214D74    8D45 D4         lea eax,dword ptr ss:[ebp-0x2C] //直接转换SofaBed对象首地址为父类CSofa的指针\n01214D77    8945 BC         mov dword ptr ss:[ebp-0x44],eax\n01214D7A    8D45 D4         lea eax,dword ptr ss:[ebp-0x2C] //取对象首地址\n01214D7D    85C0            test eax,eax\n01214D7F    74 0E           je short TestCode.01214D8F\n01214D81    8D4D D4         lea ecx,dword ptr ss:[ebp-0x2C] //取第二个指针\n01214D84    83C1 0C         add ecx,0xC\n01214D87    898D DCFEFFFF   mov dword ptr ss:[ebp-0x124],ecx\n01214D8D    EB 0A           jmp short TestCode.01214D99\n01214D8F    C785 DCFEFFFF 0>mov dword ptr ss:[ebp-0x124],0x0\n01214D99    8B95 DCFEFFFF   mov edx,dword ptr ss:[ebp-0x124]\n01214D9F    8955 B0         mov dword ptr ss:[ebp-0x50],edx\n01214DA2    C785 E4FEFFFF 0>mov dword ptr ss:[ebp-0x11C],0x0\n01214DAC    8D4D D4         lea ecx,dword ptr ss:[ebp-0x2C]\n01214DAF    E8 62C5FFFF     call TestCode.01211316 //析构\n01214DB4    8B85 E4FEFFFF   mov eax,dword ptr ss:[ebp-0x11C]\n01214DBA    52              push edx\n01214DBB    8BCD            mov ecx,ebp\n01214DBD    50              push eax\n01214DBE    8D15 E04D2101   lea edx,dword ptr ds:[0x1214DE0]\n01214DC4    E8 EBC2FFFF     call TestCode.012110B4\n01214DC9    58              pop eax\n01214DCA    5A              pop edx\n01214DCB    5F              pop edi\n01214DCC    5E              pop esi\n01214DCD    5B              pop ebx\n01214DCE    81C4 24010000   add esp,0x124\n01214DD4    3BEC            cmp ebp,esp\n01214DD6    E8 E2C3FFFF     call TestCode.012111BD\n01214DDB    8BE5            mov esp,ebp\n01214DDD    5D              pop ebp\n01214DDE    C3              retn\nCSofaBed构造函数\n01211BF0 >  55              push ebp\n01211BF1    8BEC            mov ebp,esp\n01211BF3    6A FF           push -0x1\n01211BF5    68 CD5A2101     push TestCode.01215ACD\n01211BFA    64:A1 00000000  mov eax,dword ptr fs:[0]\n01211C00    50              push eax\n01211C01    81EC D8000000   sub esp,0xD8\n01211C07    53              push ebx\n01211C08    56              push esi\n01211C09    57              push edi\n01211C0A    51              push ecx\n01211C0B    8DBD 1CFFFFFF   lea edi,dword ptr ss:[ebp-0xE4]\n01211C11    B9 36000000     mov ecx,0x36\n01211C16    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01211C1B    F3:AB           rep stos dword ptr es:[edi]\n01211C1D    59              pop ecx //还原this指针\n01211C1E    A1 04A02101     mov eax,dword ptr ds:[__security_cookie]\n01211C23    33C5            xor eax,ebp\n01211C25    50              push eax\n01211C26    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01211C29    64:A3 00000000  mov dword ptr fs:[0],eax\n01211C2F    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n01211C32    C785 20FFFFFF 0>mov dword ptr ss:[ebp-0xE0],0x0 //传入构造标记\n01211C3C    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0 //检查参数，防止重复构造\n01211C40    74 35           je short TestCode.01211C77\n01211C42    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211C45    C740 04 AC7C210>mov dword ptr ds:[eax+0x4],offset TestCode.CSofaBed::`vbtable' //设置CSofa中的vt_offset\n01211C4C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211C4F    C740 10 B47C210>mov dword ptr ds:[eax+0x10],offset TestCode.CSofaBed::`vbtable'//设置CBed中的vt_offset\n01211C56    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n01211C59    83C1 20         add ecx,0x20 //调整this指针\n01211C5C    E8 D3F6FFFF     call TestCode.01211334 //调用CFurniture构造\n01211C61    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n01211C68    8B85 20FFFFFF   mov eax,dword ptr ss:[ebp-0xE0]//获取构造标志\n01211C6E    83C8 01         or eax,0x1 //标志置1\n01211C71    8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax //修改标志\n01211C77    6A 00           push 0x0\n01211C79    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n01211C7C    E8 EFF6FFFF     call TestCode.01211370 //调用CSofa构造\n01211C81    C745 FC 0100000>mov dword ptr ss:[ebp-0x4],0x1\n01211C88    6A 00           push 0x0\n01211C8A    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n01211C8D    83C1 0C         add ecx,0xC //调整this指针\n01211C90    E8 EFF6FFFF     call TestCode.01211384 //调用CBed构造\n01211C95    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211C98    C700 647B2101   mov dword ptr ds:[eax],offset TestCode.CSofaBed::`vftable' //CSofaBed对应CSofa的虚表指针\n01211C9E    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211CA1    C740 0C 747B210>mov dword ptr ds:[eax+0xC],offset TestCode.CSofaBed::`vftable'//CSofaBed对应CBed的虚表指针\n01211CA8    8B45 EC         mov eax,dword ptr ss:[ebp-0x14] //通过this指针和vt_offset定位到祖父类虚表指针\n01211CAB    8B48 04         mov ecx,dword ptr ds:[eax+0x4] //vt_offset给ecx\n01211CAE    8B51 04         mov edx,dword ptr ds:[ecx+0x4] //父类虚表指针相对于vt_offset的偏移给edx\n01211CB1    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211CB4    C74410 04 A47C2>mov dword ptr ds:[eax+edx+0x4],offset TestCode.CSofaBed::`vftable' //CSofaBed对应CFurniture的虚表指针\n01211CBC    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211CBF    C740 1C 0600000>mov dword ptr ds:[eax+0x1C],0x6\n01211CC6    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n01211CCD    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211CD0    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n01211CD3    64:890D 0000000>mov dword ptr fs:[0],ecx\n01211CDA    59              pop ecx\n01211CDB    5F              pop edi\n01211CDC    5E              pop esi\n01211CDD    5B              pop ebx\n01211CDE    81C4 E4000000   add esp,0xE4\n01211CE4    3BEC            cmp ebp,esp\n01211CE6    E8 D2F4FFFF     call TestCode.012111BD\n01211CEB    8BE5            mov esp,ebp\n01211CED    5D              pop ebp\n01211CEE    C2 0400         retn 0x4\n析构代理函数\n01211AD0 >  55              push ebp\n01211AD1    8BEC            mov ebp,esp\n01211AD3    81EC CC000000   sub esp,0xCC\n01211AD9    53              push ebx\n01211ADA    56              push esi\n01211ADB    57              push edi\n01211ADC    51              push ecx\n01211ADD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n01211AE3    B9 33000000     mov ecx,0x33\n01211AE8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01211AED    F3:AB           rep stos dword ptr es:[edi]\n01211AEF    59              pop ecx\n01211AF0    894D F8         mov dword ptr ss:[ebp-0x8],ecx\n01211AF3    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8]\n01211AF6    83C1 20         add ecx,0x20 //调整this指针\n01211AF9    E8 63F8FFFF     call TestCode.01211361 //调用CSofaBed的析构\n01211AFE    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8]\n01211B01    83C1 20         add ecx,0x20\n01211B04    E8 3AF8FFFF     call TestCode.01211343 //调用祖父类析构\n01211B09    5F              pop edi\n01211B0A    5E              pop esi\n01211B0B    5B              pop ebx\n01211B0C    81C4 CC000000   add esp,0xCC\n01211B12    3BEC            cmp ebp,esp\n01211B14    E8 A4F6FFFF     call TestCode.012111BD\n01211B19    8BE5            mov esp,ebp\n01211B1B    5D              pop ebp\n01211B1C    C3              retn\nCSofaBed的析构\n01211D00 >  55              push ebp\n01211D01    8BEC            mov ebp,esp\n01211D03    6A FF           push -0x1\n01211D05    68 FB5A2101     push TestCode.01215AFB\n01211D0A    64:A1 00000000  mov eax,dword ptr fs:[0]\n01211D10    50              push eax\n01211D11    81EC CC000000   sub esp,0xCC\n01211D17    53              push ebx\n01211D18    56              push esi\n01211D19    57              push edi\n01211D1A    51              push ecx\n01211D1B    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n01211D21    B9 33000000     mov ecx,0x33\n01211D26    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01211D2B    F3:AB           rep stos dword ptr es:[edi]\n01211D2D    59              pop ecx\n01211D2E    A1 04A02101     mov eax,dword ptr ds:[__security_cookie]\n01211D33    33C5            xor eax,ebp\n01211D35    50              push eax\n01211D36    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01211D39    64:A3 00000000  mov dword ptr fs:[0],eax\n01211D3F    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n01211D42    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211D45    C740 E0 647B210>mov dword ptr ds:[eax-0x20],offset TestCode.CSofaBed::`vftable' //设置虚表\n01211D4C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211D4F    C740 EC 747B210>mov dword ptr ds:[eax-0x14],offset TestCode.CSofaBed::`vftable'//设置虚表\n01211D56    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211D59    8B48 E4         mov ecx,dword ptr ds:[eax-0x1C]\n01211D5C    8B51 04         mov edx,dword ptr ds:[ecx+0x4]\n01211D5F    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n01211D62    C74410 E4 A47C2>mov dword ptr ds:[eax+edx-0x1C],offset TestCode.CSofaBed::`vftable' //设置虚表\n01211D6A    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n01211D71    8BF4            mov esi,esp\n01211D73    68 BC7C2101     push TestCode.01217CBC                                                          ; ASCII \"virtual ~CSofaBed\\n\"\n01211D78    FF15 20B12101   call dword ptr ds:[<&MSVCR120D.printf>]                                         ; MSVCR120.printf\n01211D7E    83C4 04         add esp,0x4\n01211D81    3BF4            cmp esi,esp\n01211D83    E8 35F4FFFF     call TestCode.012111BD\n01211D88    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n01211D8B    83E9 04         sub ecx,0x4\n01211D8E    E8 BFF5FFFF     call TestCode.01211352 //调用析构\n01211D93    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n01211D9A    8B4D EC         mov ecx,dword ptr ss:[ebp-0x14]\n01211D9D    83E9 14         sub ecx,0x14\n01211DA0    E8 DAF5FFFF     call TestCode.0121137F //调用析构\n01211DA5    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n01211DA8    64:890D 0000000>mov dword ptr fs:[0],ecx\n01211DAF    59              pop ecx\n01211DB0    5F              pop edi\n01211DB1    5E              pop esi\n01211DB2    5B              pop ebx\n01211DB3    81C4 D8000000   add esp,0xD8\n01211DB9    3BEC            cmp ebp,esp\n01211DBB    E8 FDF3FFFF     call TestCode.012111BD\n01211DC0    8BE5            mov esp,ebp\n01211DC2    5D              pop ebp\n01211DC3    C3              retn\n```\n\n由此可以看出vt_offset指向的内存地址中保存的数据为偏移数据。Vt_offset对应的数据有两项，vt_offset所属类对象的虚表指针相对于vt_offset的偏移值，父类虚表指针相对于vt_offset的偏移值。\n\nCSofaBed的构造过程中的特别之处是在调用时要传入一个参数，这个参数是标志信息。构造过程中要先构造父类，在构造自己。\n\n菱形结构中子类的析构函数执行流程并没有像构造函数那样使用标记来防止重复析构，而是将祖父类放在最后调用。先依次执行两个父类的析构，然后执行祖父类的析构。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(七)","url":"/2016/11/27/逆向笔记-七/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之构造函数和析构函数。\n\n构造函数用来完成对象生成时的数据初始化工作，而析构函数则用在对象销毁时释放对象中所申请的资源。当对象生成时，编译器会自动产生调用其构造函数的代码，在编码过程中可以为类中的数据成员赋予恰当的初值。当对象销毁时，编译器同样会产生调用其类析构函数的代码。\n\n构造函数与析构函数都是类中特殊的成员函数，构造函数支持函数重载，而析构函数只能是一个无参函数。他们不可定义返回值，调用构造函数后，返回值为对象首地址，也就是this指针。\n\n## 构造函数的出现时机\n\n不同作用域的对象生命周期不同，如局部对象，全局对象，静态对象等等的生命周期不相同，当对象作为函数参数与返回值时，构造函数的出现时机也会有所不同。虽然不同类型对象的构造函数被调用的时机不同，但都会遵循C++语法，定义的同时调用构造函数。因此要将对象进行分类。\n根据生命周期将对象可以分为如下几类：\n1）局部对象\n2）堆对象\n3）参数对象\n4）返回对象\n5）全局对象\n6）静态对象\n\n局部对象\n局部对象下的构造函数的出现时机比较容易识别。\n\n```c\nC代码：\nclass CNumber\n{\npublic:\n    CNumber()\n    {\n        m_nNum = 1;\n    }\n    int m_nNum;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber obj;\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n013E1630 >  55              push ebp\n013E1631    8BEC            mov ebp,esp\n013E1633    81EC CC000000   sub esp,0xCC\n013E1639    53              push ebx\n013E163A    56              push esi\n013E163B    57              push edi\n013E163C    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n013E1642    B9 33000000     mov ecx,0x33\n013E1647    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n013E164C    F3:AB           rep stos dword ptr es:[edi]\n013E164E    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8]//取对象首地址，this指针\n013E1651    E8 BCFBFFFF     call TestCode.013E1212 //调用构造函数\n013E1656    33C0            xor eax,eax\n013E1658    52              push edx\n013E1659    8BCD            mov ecx,ebp\n013E165B    50              push eax\n013E165C    8D15 80163E01   lea edx,dword ptr ds:[0x13E1680]\n013E1662    E8 2FFAFFFF     call TestCode.013E1096\n013E1667    58              pop eax\n构造函数\n013E1420 T>  55              push ebp\n013E1421     8BEC            mov ebp,esp\n013E1423     81EC CC000000   sub esp,0xCC\n013E1429     53              push ebx\n013E142A     56              push esi\n013E142B     57              push edi\n013E142C     51              push ecx\n013E142D     8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n013E1433     B9 33000000     mov ecx,0x33\n013E1438     B8 CCCCCCCC     mov eax,0xCCCCCCCC\n013E143D     F3:AB           rep stos dword ptr es:[edi]\n013E143F     59              pop ecx\n013E1440     894D F8         mov dword ptr ss:[ebp-0x8],ecx //this指针给ebp-0x8\n013E1443     8B45 F8         mov eax,dword ptr ss:[ebp-0x8] //this指针给eax\n013E1446     C700 01000000   mov dword ptr ds:[eax],0x1 //赋值\n013E144C     8B45 F8         mov eax,dword ptr ss:[ebp-0x8]//给eax作为返回值\n013E144F     5F              pop edi\n013E1450     5E              pop esi\n013E1451     5B              pop ebx\n013E1452     8BE5            mov esp,ebp\n013E1454     5D              pop ebp\n013E1455     C3              retn\n```\n\n由此可以看出，当在进入对象作用域时，编译器会产生调用构造函数的代码。由于构造函数属于成员函数，因此在调用过程中同样需要传递this指针。构造函数调用结束后，会将this指针作为返回值。返回this指针便是构造函数的特征之一。\n结合C++语法，可总结识别局部对象的构造函数的必要条件：\n1该成员函数是这个对象在作用域内调用的第一个成员函数，根据this指针即可区分每个对象。\n2这个函数返回this指针。\n\n堆对象\n堆对象的识别重点在于识别堆空间的申请与使用。堆空间申请需要使用malloc函数，new运算符或其他同类功能的函数。\n\n\nC代码：\n```c\nclass CNumber\n{\npublic:\n    CNumber()\n    {\n        m_nNum = 1;\n    }\n    int m_nNum;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber *obj = NULL;\n    obj = new CNumber;\n    return 0;\n}\n```\n对应反汇编Debug：\n\n```\n01163FF0 T>  55              push ebp\n01163FF1     8BEC            mov ebp,esp\n01163FF3     6A FF           push -0x1\n01163FF5     68 8E4F1601     push TestCode.01164F8E\n01163FFA     64:A1 00000000  mov eax,dword ptr fs:[0]\n01164000     50              push eax\n01164001     81EC E8000000   sub esp,0xE8\n01164007     53              push ebx\n01164008     56              push esi\n01164009     57              push edi\n0116400A     8DBD 0CFFFFFF   lea edi,dword ptr ss:[ebp-0xF4]\n01164010     B9 3A000000     mov ecx,0x3A\n01164015     B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0116401A     F3:AB           rep stos dword ptr es:[edi]\n0116401C     A1 04901601     mov eax,dword ptr ds:[__security_cookie]\n01164021     33C5            xor eax,ebp\n01164023     50              push eax\n01164024     8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01164027     64:A3 00000000  mov dword ptr fs:[0],eax\n0116402D     C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0 //指针初始化为Null\n01164034     6A 04           push 0x4 //压入类的大小\n01164036     E8 78D1FFFF     call TestCode.011611B3 //调用new\n0116403B     83C4 04         add esp,0x4 //堆栈平衡\n0116403E     8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax //返回值给ebp-0xe0\n01164044     C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0 //这里保存申请次数\n0116404B     83BD 20FFFFFF 0>cmp dword ptr ss:[ebp-0xE0],0x0 //比较结果\n01164052     74 13           je short TestCode.01164067 //申请空间失败结束\n01164054     8B8D 20FFFFFF   mov ecx,dword ptr ss:[ebp-0xE0] //对象首地址给ecx\n0116405A     E8 B3D1FFFF     call TestCode.01161212 //调用构造函数\n0116405F     8985 0CFFFFFF   mov dword ptr ss:[ebp-0xF4],eax //返回值给ebp-0xf4\n01164065     EB 0A           jmp short TestCode.01164071 \n01164067     C785 0CFFFFFF 0>mov dword ptr ss:[ebp-0xF4],0x0 //申请失败指针为null\n00204071     8B85 0CFFFFFF   mov eax,dword ptr ss:[ebp-0xF4]\n00204077     8985 14FFFFFF   mov dword ptr ss:[ebp-0xEC],eax //this指针给ebp-0xec\n0020407D     C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00204084     8B8D 14FFFFFF   mov ecx,dword ptr ss:[ebp-0xEC]\n0020408A     894D EC         mov dword ptr ss:[ebp-0x14],ecx //ecx为this指针\n0020408D     8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00204090     C700 02000000   mov dword ptr ds:[eax],0x2 //赋值\n00204096     8BF4            mov esi,esp\n00204098     8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n0020409B     8B08            mov ecx,dword ptr ds:[eax] //取内容给ecx，也就是第一个成员变量\n0020409D     51              push ecx //参数入栈\n0020409E     68 6C682000     push TestCode.0020686C                   ; ASCII \"&d\\n\"\n002040A3     FF15 18A12000   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n002040A9     83C4 08         add esp,0x8\n002040AC     3BF4            cmp esi,esp\n002040AE     E8 ABD0FFFF     call TestCode.0020115E\n002040B3     33C0            xor eax,eax\n002040B5     8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n002040B8     64:890D 0000000>mov dword ptr fs:[0],ecx\n002040BF     59              pop ecx\n002040C0     5F              pop edi\n002040C1     5E              pop esi\n002040C2     5B              pop ebx\n002040C3     81C4 F4000000   add esp,0xF4\n002040C9     3BEC            cmp ebp,esp\n002040CB     E8 8ED0FFFF     call TestCode.0020115E\n002040D0     8BE5            mov esp,ebp\n002040D2     5D              pop ebp\n002040D3     C3              retn\n```\n\n由此可以看出，在使用new申请了堆空间以后，需要调用构造函数，以完成对象的数据成员初始化过程。如果堆空间申请失败，则会避开构造函数的调用。因为在C++语法中，如果new运算执行成功，返回值为对象的首地址，否则为Null。因此需要编译器检查堆空间的申请结果，产生一个双分支结构，以决定是否触发构造函数。在识别堆对象的构造函数时，应重点分析双分支结构，找到new运算的调用后，可立即在下文寻找判定new返回值的代码，在判定成功（new的返回值非0）的分支处可迅速定位并得到构造函数。\nC中的malloc函数和C++中的new运算的区别很大，很重要的两点是malloc不负责出发构造函数，他也不是运算符，无法进行运算符重载。\n\n## 参数对象\n\n参数对象属于局部对象中的一种特殊情况。当对象作为函数参数时，调用一个特殊的构造函数—拷贝构造函数。该构造函数只有一个参数，类型为对象的引用。\n当对象为参数时，会触发此类对象的拷贝构造函数。如果在函数调用时传递参数对象，参数会进行复制，形参是实参的副本，相当于拷贝构造了一个全新的对象。由于定义了新对象，因此会触发拷贝构造函数，在这个特殊的构造函数中完成两个对象间数据的复制。如没有定义拷贝构造函数，编译器会对原对象与拷贝对象中的各数据成员直接进行数据复制，称为默认拷贝构造函数，这种拷贝方式属于浅拷贝。\n虽然使用编译的提供的默认拷贝构造函数很方便，但在某些特殊情况下，这种拷贝会导致程序错误，如前面的资源释放错误。当类中有资源申请，并以数据成员来保存这些资源时，就需要使用者自己提供一个拷贝构造函数。在拷贝构造函数中，要处理的不仅仅是资源对象的各数据成员，还有他们指向的资源数据。把这种源对象中的数据成员间接访问到其他资源并制作副本的拷贝构造函数称为深拷贝。\n\nC代码:\n\n```c\nclass CMyString\n{\npublic:\n    CMyString()\n    {\n        m_pString = NULL;\n    }\n    CMyString (CMyString &obj)\n    {\n        //如果在拷贝构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，浅拷贝\n        //this->m_pString = obj.m_pString;\n        //为实参对象中的指针指向的堆空间制作一份副本，深拷贝\n        int nLen = strlen(obj.m_pString);\n        this->m_pString = new char[nLen + sizeof(char)];\n        strcpy(this->m_pString, obj.m_pString);\n    }\n    ~CMyString()\n    {\n        if (m_pString != NULL)\n        {\n            delete[] m_pString;\n            m_pString = NULL;\n        }\n    }\n    void SetString(char *pString)\n    {\n        int nLen = strlen(pString);\n        if (m_pString != NULL)\n        {\n            delete[] m_pString;\n            m_pString = NULL;\n        }\n        m_pString = new char[nLen + sizeof(char)];\n        strcpy(m_pString, pString);\n    }\n    char *m_pString;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CMyString MyString;\n    MyString.SetString(\"hello\");\n    Show(MyString);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n01284050 >  55              push ebp\n01284051    8BEC            mov ebp,esp\n01284053    6A FF           push -0x1\n01284055    68 584F2801     push TestCode.01284F58\n0128405A    64:A1 00000000  mov eax,dword ptr fs:[0]\n01284060    50              push eax\n01284061    81EC E8000000   sub esp,0xE8\n01284067    53              push ebx\n01284068    56              push esi\n01284069    57              push edi\n0128406A    8DBD 0CFFFFFF   lea edi,dword ptr ss:[ebp-0xF4]\n01284070    B9 3A000000     mov ecx,0x3A\n01284075    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0128407A    F3:AB           rep stos dword ptr es:[edi]\n0128407C    A1 04902801     mov eax,dword ptr ds:[__security_cookie]\n01284081    33C5            xor eax,ebp\n01284083    50              push eax\n01284084    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01284087    64:A3 00000000  mov dword ptr fs:[0],eax\n0128408D    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14] //取对象首地址\n01284090    E8 8CD1FFFF     call TestCode.01281221 //调用构造函数\n01284095    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n0128409C    68 7C682801     push TestCode.0128687C                   ; ASCII \"hello\" //参数入栈\n012840A1    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14] //取对象首地址\n012840A4    E8 6ED1FFFF     call TestCode.01281217 //调用成员函数\n012840A9    51              push ecx //这里的push ecx等价于sub esp，4，但是原指令机器码更短，效率更高。\n012840AA    8BCC            mov ecx,esp //取参数对象地址，保存到ecx\n012840AC    89A5 14FFFFFF   mov dword ptr ss:[ebp-0xEC],esp\n012840B2    8D45 EC         lea eax,dword ptr ss:[ebp-0x14] //取对象首地址给eax\n012840B5    50              push eax //参数入栈\n012840B6    E8 6BD1FFFF     call TestCode.01281226 //调用拷贝构造函数\n012840BB    8985 0CFFFFFF   mov dword ptr ss:[ebp-0xF4],eax //返回值给ebp-0xf4\n012840C1    E8 CAD0FFFF     call TestCode.01281190 //调用Show函数\n012840C6    83C4 04         add esp,0x4\n012840C9    C785 20FFFFFF 0>mov dword ptr ss:[ebp-0xE0],0x0\n012840D3    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n012840DA    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14]\n012840DD    E8 95D0FFFF     call TestCode.01281177 //调用析构函数\n012840E2    8B85 20FFFFFF   mov eax,dword ptr ss:[ebp-0xE0]\n012840E8    52              push edx\n012840E9    8BCD            mov ecx,ebp\n012840EB    50              push eax\n012840EC    8D15 18412801   lea edx,dword ptr ds:[0x1284118]\n012840F2    E8 9FCFFFFF     call TestCode.01281096\n012840F7    58              pop eax\n012840F8    5A              pop edx\n012840F9    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n012840FC    64:890D 0000000>mov dword ptr fs:[0],ecx\n01284103    59              pop ecx\n01284104    5F              pop edi\n01284105    5E              pop esi\n01284106    5B              pop ebx\n01284107    81C4 F4000000   add esp,0xF4\n0128410D    3BEC            cmp ebp,esp\n0128410F    E8 4AD0FFFF     call TestCode.0128115E\n01284114    8BE5            mov esp,ebp\n01284116    5D              pop ebp\n01284117    C3              retn\n```\n\n由此可以看出，在执行Show函数之前，先执行拷贝构造函数。在拷贝构造中，使用深拷贝。\n这时两个数据成员保存地址不同，但内容相同。\n\n\n由于使用了深拷贝，对对象中的数据成员所指向的堆空间数据也进行了复制，因此当参数被销毁时，释放的堆空间数据是拷贝对象所制作的数据副本，对源对象没有影响。\n\n## 返回对象\n\n返回对象与参数对象相似，都是局部对象中的一种特殊情况。由于函数返回时需要对返回对象进行拷贝，因此同样会使用到拷贝构造函数。单数两者使用拷贝构造函数的时机不同，当对象为参数时，在进入函数前使用拷贝构造函数，而返回对象则在函数返回时使用拷贝构造函数。\n\n\nC代码：\n\n```c\nclass CMyString\n{\npublic:\n    CMyString()\n    {\n        m_pString = NULL;\n    }\n    CMyString(CMyString &obj)\n    {\n        //如果在拷贝构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，浅拷贝\n        //this->m_pString = obj.m_pString;\n        //为实参对象中的指针指向的堆空间制作一份副本，深拷贝\n        int nLen = strlen(obj.m_pString);\n        this->m_pString = new char[nLen + sizeof(char)];\n        strcpy(this->m_pString, obj.m_pString);\n    }\n    ~CMyString()\n    {\n        if (m_pString != NULL)\n        {\n            delete[] m_pString;\n            m_pString = NULL;\n        }\n    }\n    void SetString(char *pString)\n    {\n        int nLen = strlen(pString);\n        if (m_pString != NULL)\n        {\n            delete[] m_pString;\n            m_pString = NULL;\n        }\n        m_pString = new char[nLen + sizeof(char)];\n        strcpy(m_pString, pString);\n    }\n    char *m_pString;\n};\nvoid Show(CMyString obj)\n{\n    printf(obj.m_pString);\n}\nCMyString GetString()\n{\n    CMyString MyString;\n    MyString.SetString(\"Test\");\n    return MyString;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CMyString MyString = GetString();\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n00A21680 >  55              push ebp\n00A21681    8BEC            mov ebp,esp\n00A21683    81EC D8000000   sub esp,0xD8\n00A21689    53              push ebx\n00A2168A    56              push esi\n00A2168B    57              push edi\n00A2168C    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00A21692    B9 36000000     mov ecx,0x36\n00A21697    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00A2169C    F3:AB           rep stos dword ptr es:[edi]\n00A2169E    8D45 F8         lea eax,dword ptr ss:[ebp-0x8] //取对象首地址\n00A216A1    50              push eax //参数入栈\n00A216A2    E8 84FBFFFF     call TestCode.00A2122B //调用函数\n00A216A7    83C4 04         add esp,0x4\n00A216AA    C785 2CFFFFFF 0>mov dword ptr ss:[ebp-0xD4],0x0\n00A216B4    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8]\n00A216B7    E8 BBFAFFFF     call TestCode.00A21177\n00A216BC    8B85 2CFFFFFF   mov eax,dword ptr ss:[ebp-0xD4]\n00A216C2    52              push edx\n00A216C3    8BCD            mov ecx,ebp\n00A216C5    50              push eax\n00A216C6    8D15 E816A200   lea edx,dword ptr ds:[0xA216E8]\n00A216CC    E8 C5F9FFFF     call TestCode.00A21096\n00A216D1    58              pop eax\n00A216D2    5A              pop edx\n00A216D3    5F              pop edi\n00A216D4    5E              pop esi\n00A216D5    5B              pop ebx\n00A216D6    81C4 D8000000   add esp,0xD8\n00A216DC    3BEC            cmp ebp,esp\n00A216DE    E8 7BFAFFFF     call TestCode.00A2115E\n00A216E3    8BE5            mov esp,ebp\n00A216E5    5D              pop ebp\n00A216E6    C3              retn\nGetString函数\n00A215A0 >  55              push ebp\n00A215A1    8BEC            mov ebp,esp\n00A215A3    6A FF           push -0x1\n00A215A5    68 774FA200     push TestCode.00A24F77\n00A215AA    64:A1 00000000  mov eax,dword ptr fs:[0]\n00A215B0    50              push eax\n00A215B1    81EC D8000000   sub esp,0xD8\n00A215B7    53              push ebx\n00A215B8    56              push esi\n00A215B9    57              push edi\n00A215BA    8DBD 1CFFFFFF   lea edi,dword ptr ss:[ebp-0xE4]\n00A215C0    B9 36000000     mov ecx,0x36\n00A215C5    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00A215CA    F3:AB           rep stos dword ptr es:[edi]\n00A215CC    A1 0490A200     mov eax,dword ptr ds:[__security_cookie]\n00A215D1    33C5            xor eax,ebp\n00A215D3    50              push eax\n00A215D4    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00A215D7    64:A3 00000000  mov dword ptr fs:[0],eax\n00A215DD    C785 20FFFFFF 0>mov dword ptr ss:[ebp-0xE0],0x0\n00A215E7    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14] //取对象首地址给ecx\n00A215EA    E8 32FCFFFF     call TestCode.00A21221 //调用构造函数\n00A215EF    C745 FC 0100000>mov dword ptr ss:[ebp-0x4],0x1 //对象计数器\n00A215F6    68 7C68A200     push TestCode.00A2687C                   ; ASCII \"Test\"\n00A215FB    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14] //取对象首地址\n00A215FE    E8 14FCFFFF     call TestCode.00A21217//调用SetString函数\n00A21603    8D45 EC         lea eax,dword ptr ss:[ebp-0x14] //取对象首地址\n00A21606    50              push eax //参数入栈\n00A21607    8B4D 08         mov ecx,dword ptr ss:[ebp+0x8] //获取参数中的this（当对象作为返回值时，函数会隐式传递一个返回地址的this指针参数）\n00A2160A    E8 17FCFFFF     call TestCode.00A21226 //调用拷贝构造函数\n00A2160F    8B8D 20FFFFFF   mov ecx,dword ptr ss:[ebp-0xE0]\n00A21615    83C9 01         or ecx,0x1\n00A21618    898D 20FFFFFF   mov dword ptr ss:[ebp-0xE0],ecx\n00A2161E    C645 FC 00      mov byte ptr ss:[ebp-0x4],0x0\n00A21622    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14]\n00A21625    E8 4DFBFFFF     call TestCode.00A21177 //调用析构函数\n00A2162A    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00A2162D    52              push edx\n00A2162E    8BCD            mov ecx,ebp\n00A21630 >  50              push eax\n00A21631    8D15 6016A200   lea edx,dword ptr ds:[0xA21660]\n00A21637    E8 5AFAFFFF     call TestCode.00A21096\n00A2163C    58              pop eax\n00A2163D    5A              pop edx\n00A2163E    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00A21641    64:890D 0000000>mov dword ptr fs:[0],ecx\n00A21648    59              pop ecx\n00A21649    5F              pop edi\n00A2164A    5E              pop esi\n00A2164B    5B              pop ebx\n00A2164C    81C4 E4000000   add esp,0xE4\n00A21652    3BEC            cmp ebp,esp\n00A21654    E8 05FBFFFF     call TestCode.00A2115E\n00A21659    8BE5            mov esp,ebp\n00A2165B    5D              pop ebp\n00A2165C    C3              retn\n```\n\n由此可以看出，GetString将返回对象的地址作为函数参数。在函数返回之前，利用拷贝构造函数将函数中局部对象的数据复制到参数指向的对象中，起到了返回对象的作用。\n\n等价的函数声明\n\n\n## 全局对象和静态对象\n\n全局对象与静态对象的构造时机相同。全局对象的构造函数的初始化是在_cinit函数中实现的。\n\n全局对象构造函数识别的两种方法：\n1）直接定位初始化函数，先进入mainCRTStartup函数中，找到初始化函数_cinit，在_cinit函数的第二个_initterm处下段。运行程序后，进入_initterm的实现代码内，断点在(**pfbegin)()执行处，单步进入代理构造，即可得到全局对象的构造函数。\n2）利用栈回溯\n\n每个对象都有默认的构造函数吗？\n有两种情况编译器会提供默认的构造函数\n1）本类，本类中定义的成员对象或者父类中有虚函数存在。由于需要初始化虚表，且这个工作原理应在构造函数中隐式完成，因此没有定义构造函数的情况下，编译器会添加默认的构造函数用于隐式完成徐彪的初始化工作。\n2）父类或本类中定义的成员对象带有构造函数。在对象被定义时，由于对象本身为派生类，因此构造顺序是先构造父类在构造自身。当父类中带有构造函数时，将会调用父类构造函数，而这个调用过程需要在构造函数内完成，因此编译器添加了默认的构造函数来完成这个过程。成员对象带有构造函数的情况与此相同。\n\n析构函数的出现时机\n析构函数的触发时机也需要是情况而定，分为以下几种情况\n1）局部对象：作用域结束前调用析构函数\n2）堆对象：释放堆空间前调用析构函数\n3）参数对象：退出函数前，调用参数对象的析构函数\n4）返回对象：如无对象引用定义，退出函数后，调用返回对象的析构函数，否则与对象引用的作用域一致\n5）全局对象：main函数退出后调用析构函数\n6）静态对象：main函数退出后调用析构函数\n\n### 局部对象\n\n要考察局部对象的析构函数的出现时机，应重点考察其作用域的结束处。与构造函数相比较而言，析构函数的出现时机相对固定。对于局部对象，当对象所在作用域结束后，将销毁该作用域的所有变量的栈空间，此时便是析构函数的出现时机。\n\n\nC代码：\n\n```c\nclass CNumber\n{\npublic:\n    CNumber()\n    {\n        m_nNum = 1;\n    }\n    ~CNumber()\n    {\n        printf(\"~CNumber\");\n    }\n    int m_nNum;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber obj;\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n000515F0 >  55              push ebp\n000515F1    8BEC            mov ebp,esp\n000515F3    81EC D8000000   sub esp,0xD8\n000515F9    53              push ebx\n000515FA    56              push esi\n000515FB    57              push edi\n000515FC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00051602    B9 36000000     mov ecx,0x36\n00051607    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0005160C    F3:AB           rep stos dword ptr es:[edi]\n0005160E    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8] //获取对象首地址\n00051611    E8 1AFCFFFF     call TestCode.00051230 //调用构造函数\n00051616    C785 2CFFFFFF 0>mov dword ptr ss:[ebp-0xD4],0x0\n00051620    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8] //获取对象首地址\n00051623    E8 0DFCFFFF     call TestCode.00051235 //调用析构函数\n00051628    8B85 2CFFFFFF   mov eax,dword ptr ss:[ebp-0xD4]\n0005162E    52              push edx\n0005162F    8BCD            mov ecx,ebp\n00051631    50              push eax\n00051632    8D15 54160500   lea edx,dword ptr ds:[0x51654]\n00051638    E8 59FAFFFF     call TestCode.00051096\n0005163D    58              pop eax\n0005163E    5A              pop edx\n0005163F    5F              pop edi\n00051640    5E              pop esi\n00051641    5B              pop ebx\n00051642    81C4 D8000000   add esp,0xD8\n00051648    3BEC            cmp ebp,esp\n0005164A    E8 0FFBFFFF     call TestCode.0005115E\n0005164F    8BE5            mov esp,ebp\n00051651    5D              pop ebp\n00051652    C3              retn\n析构函数\n000515A0 >  55              push ebp\n000515A1    8BEC            mov ebp,esp\n000515A3    81EC CC000000   sub esp,0xCC\n000515A9    53              push ebx\n000515AA    56              push esi\n000515AB    57              push edi\n000515AC    51              push ecx\n000515AD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n000515B3    B9 33000000     mov ecx,0x33\n000515B8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n000515BD    F3:AB           rep stos dword ptr es:[edi]\n000515BF    59              pop ecx //还原this指针到ecx\n000515C0    894D F8         mov dword ptr ss:[ebp-0x8],ecx //保存this指针到ebp-0x8\n000515C3    8BF4            mov esi,esp\n000515C5    68 D8680500     push TestCode.000568D8                   ; ASCII \"~CNumber\"\n000515CA    FF15 18A10500   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n000515D0    83C4 04         add esp,0x4\n000515D3    3BF4            cmp esi,esp\n000515D5    E8 84FBFFFF     call TestCode.0005115E\n000515DA    5F              pop edi\n000515DB    5E              pop esi\n000515DC    5B              pop ebx\n000515DD    81C4 CC000000   add esp,0xCC\n000515E3    3BEC            cmp ebp,esp\n000515E5    E8 74FBFFFF     call TestCode.0005115E\n000515EA    8BE5            mov esp,ebp\n000515EC    5D              pop ebp\n000515ED    C3              retn\n```\n\n由此可以看出在对象的作用域结束处调用了析构函数。析构函数同样属于成员函数，因此在调用过程中也需要传递this指针。\n析构函数与构造函数略有不同，析构函数不支持函数重载，且只有一个参数，就是this指针，且编译器隐藏了这个参数的传递过程。\n\n## 堆对象\n\n堆对象比较特殊。使用new对象申请堆对象空间后，可以看在那里调用了delete函数释放。Delete的使用便是找到堆对象调用析构函数的关键。\n\nC代码：\n\n```c\nclass CNumber\n{\npublic:\n    CNumber()\n    {\n        m_nNum = 1;\n    }\n    ~CNumber()\n    {\n        printf(\"~CNumber\");\n    }\n    int m_nNum;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber *pObj = NULL;\n    pObj = new CNumber;\n    pObj->m_nNum = 2;\n    printf(\"%d\\n\", pObj->m_nNum);\n    if (pObj != NULL)\n    {\n        delete pObj;\n        pObj = NULL;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n000243B0 >  55              push ebp\n000243B1    8BEC            mov ebp,esp\n000243B3    6A FF           push -0x1\n000243B5    68 AE4F0200     push TestCode.00024FAE\n000243BA    64:A1 00000000  mov eax,dword ptr fs:[0]\n000243C0    50              push eax\n000243C1    81EC 00010000   sub esp,0x100\n000243C7    53              push ebx\n000243C8    56              push esi\n000243C9    57              push edi\n000243CA    8DBD F4FEFFFF   lea edi,dword ptr ss:[ebp-0x10C]\n000243D0    B9 40000000     mov ecx,0x40\n000243D5    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n000243DA    F3:AB           rep stos dword ptr es:[edi]\n000243DC    A1 04900200     mov eax,dword ptr ds:[__security_cookie]\n000243E1    33C5            xor eax,ebp\n000243E3    50              push eax\n000243E4    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n000243E7    64:A3 00000000  mov dword ptr fs:[0],eax\n000243ED    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0 //指针\n000243F4    6A 04           push 0x4\n000243F6    E8 B8CDFFFF     call TestCode.000211B3 //调用new函数\n000243FB    83C4 04         add esp,0x4\n000243FE    8985 08FFFFFF   mov dword ptr ss:[ebp-0xF8],eax\n00024404    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n0002440B    83BD 08FFFFFF 0>cmp dword ptr ss:[ebp-0xF8],0x0\n00024412    74 13           je short TestCode.00024427 //判断是否分配空间成功\n00024414    8B8D 08FFFFFF   mov ecx,dword ptr ss:[ebp-0xF8]\n0002441A    E8 11CEFFFF     call TestCode.00021230 //调用构造函数\n0002441F    8985 F4FEFFFF   mov dword ptr ss:[ebp-0x10C],eax\n00024425    EB 0A           jmp short TestCode.00024431\n00024427    C785 F4FEFFFF 0>mov dword ptr ss:[ebp-0x10C],0x0\n00024431    8B85 F4FEFFFF   mov eax,dword ptr ss:[ebp-0x10C]\n00024437    8985 FCFEFFFF   mov dword ptr ss:[ebp-0x104],eax\n0002443D    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00024444    8B8D FCFEFFFF   mov ecx,dword ptr ss:[ebp-0x104]\n0002444A    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n0002444D    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00024450    C700 02000000   mov dword ptr ds:[eax],0x2\n00024456    8BF4            mov esi,esp\n00024458    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n0002445B    8B08            mov ecx,dword ptr ds:[eax]\n0002445D    51              push ecx\n0002445E    68 6C680200     push TestCode.0002686C                   ; ASCII \"%d\\n\"\n00024463    FF15 18A10200   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00024469    83C4 08         add esp,0x8\n0002446C    3BF4            cmp esi,esp\n0002446E    E8 EBCCFFFF     call TestCode.0002115E\n00024473    837D EC 00      cmp dword ptr ss:[ebp-0x14],0x0 //判断this指针是否为空\n00024477    74 44           je short TestCode.000244BD\n00024479    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n0002447C    8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax\n00024482    8B8D 20FFFFFF   mov ecx,dword ptr ss:[ebp-0xE0]\n00024488    898D 14FFFFFF   mov dword ptr ss:[ebp-0xEC],ecx //把this指针给ebp-0xec\n0002448E    83BD 14FFFFFF 0>cmp dword ptr ss:[ebp-0xEC],0x0\n00024495    74 15           je short TestCode.000244AC //如果为空则跳过析构函数\n00024497    6A 01           push 0x1 //标记\n00024499    8B8D 14FFFFFF   mov ecx,dword ptr ss:[ebp-0xEC] //this指针\n0002449F    E8 96CDFFFF     call TestCode.0002123A //调用析构函数\n000244A4    8985 F4FEFFFF   mov dword ptr ss:[ebp-0x10C],eax\n000244AA    EB 0A           jmp short TestCode.000244B6\n000244AC    C785 F4FEFFFF 0>mov dword ptr ss:[ebp-0x10C],0x0\n000244B6    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0\n000244BD    33C0            xor eax,eax\n000244BF    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n000244C2    64:890D 0000000>mov dword ptr fs:[0],ecx\n000244C9    59              pop ecx\n000244CA    5F              pop edi\n000244CB    5E              pop esi\n000244CC    5B              pop ebx\n000244CD    81C4 0C010000   add esp,0x10C\n000244D3    3BEC            cmp ebp,esp\n000244D5    E8 84CCFFFF     call TestCode.0002115E\n000244DA    8BE5            mov esp,ebp\n000244DC    5D              pop ebp\n000244DD    C3              retn\n析构代理函数\n00024140 >  55              push ebp\n00024141    8BEC            mov ebp,esp\n00024143    81EC CC000000   sub esp,0xCC\n00024149    53              push ebx\n0002414A    56              push esi\n0002414B    57              push edi\n0002414C    51              push ecx\n0002414D    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00024153    B9 33000000     mov ecx,0x33\n00024158    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0002415D    F3:AB           rep stos dword ptr es:[edi]\n0002415F    59              pop ecx //还原this指针\n00024160    894D F8         mov dword ptr ss:[ebp-0x8],ecx \n00024163    8B4D F8         mov ecx,dword ptr ss:[ebp-0x8] //this指针给ecx\n00024166    E8 CAD0FFFF     call TestCode.00021235//调用析构函数\n0002416B    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n0002416E    83E0 01         and eax,0x1 //检查析构函数标记\n00024171    74 0C           je short TestCode.0002417F\n00024173    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00024176    50              push eax //压入堆空间首地址\n00024177    E8 1FCFFFFF     call TestCode.0002109B //调用delete函数\n0002417C    83C4 04         add esp,0x4\n0002417F    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00024182    5F              pop edi\n00024183    5E              pop esi\n00024184    5B              pop ebx\n00024185    81C4 CC000000   add esp,0xCC\n0002418B    3BEC            cmp ebp,esp\n0002418D    E8 CCCFFFFF     call TestCode.0002115E\n00024192    8BE5            mov esp,ebp\n00024194    5D              pop ebp\n00024195    C2 0400         retn 0x4\n```\n\n由此可以看出，析构函数比较特殊，在释放过程中，需要使用析构代理函数间接调用析构函数。原因是在某些情况下，需要释放的对象不止一个，如果直接调用析构函数，则无法完成多对象的析构。\n\n这里体现的是有两个对象的一个例子。\n\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber *pObj = NULL;\n    pObj = new CNumber[2];\n    if (pObj != NULL)\n    {\n        delete pObj;\n        pObj = NULL;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n00924410 >  55              push ebp\n00924411    8BEC            mov ebp,esp\n00924413    6A FF           push -0x1\n00924415    68 AE4F9200     push TestCode.00924FAE\n0092441A    64:A1 00000000  mov eax,dword ptr fs:[0]\n00924420    50              push eax\n00924421    81EC 00010000   sub esp,0x100\n00924427    53              push ebx\n00924428    56              push esi\n00924429    57              push edi\n0092442A    8DBD F4FEFFFF   lea edi,dword ptr ss:[ebp-0x10C]\n00924430    B9 40000000     mov ecx,0x40\n00924435    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0092443A    F3:AB           rep stos dword ptr es:[edi]\n0092443C    A1 04909200     mov eax,dword ptr ds:[__security_cookie]\n00924441    33C5            xor eax,ebp\n00924443    50              push eax\n00924444    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00924447    64:A3 00000000  mov dword ptr fs:[0],eax\n0092444D    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0\n00924454    6A 0C           push 0xC //这里申请12字节大小，每个对象占四字节，多出的四字节是堆空间首地址处保存的对象对象总个数\n00924456    E8 58CDFFFF     call TestCode.009211B3\n0092445B    83C4 04         add esp,0x4\n0092445E    8985 08FFFFFF   mov dword ptr ss:[ebp-0xF8],eax //堆空间的首地址\n00924464    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n0092446B    83BD 08FFFFFF 0>cmp dword ptr ss:[ebp-0xF8],0x0 //检查是否成功\n00924472    74 3A           je short TestCode.009244AE\n00924474    8B85 08FFFFFF   mov eax,dword ptr ss:[ebp-0xF8]\n0092447A    C700 02000000   mov dword ptr ds:[eax],0x2\n00924480    68 35129200     push TestCode.00921235 //压入析构函数地址\n00924485    68 30129200     push TestCode.00921230 //压入构造函数地址\n0092448A    6A 02           push 0x2 //压入对象个数\n0092448C    6A 04           push 0x4 //压入对象大小\n0092448E    8B8D 08FFFFFF   mov ecx,dword ptr ss:[ebp-0xF8] //对象首地址\n00924494    83C1 04         add ecx,0x4 //首地址+4，跳过保存个数的空间\n00924497    51              push ecx //压入第一个对象地址\n00924498    E8 A7CDFFFF     call TestCode.00921244 //调用析构代理函数\n0092449D    8B95 08FFFFFF   mov edx,dword ptr ss:[ebp-0xF8]//对象首地址\n009244A3    83C2 04         add edx,0x4//首地址+4，跳过保存个数的空间\n009244A6    8995 F4FEFFFF   mov dword ptr ss:[ebp-0x10C],edx \n009244AC    EB 0A           jmp short TestCode.009244B8\n009244AE    C785 F4FEFFFF 0>mov dword ptr ss:[ebp-0x10C],0x0\n009244B8    8B85 F4FEFFFF   mov eax,dword ptr ss:[ebp-0x10C] //对象首地址给eax\n009244BE    8985 FCFEFFFF   mov dword ptr ss:[ebp-0x104],eax\n009244C4    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n009244CB    8B8D FCFEFFFF   mov ecx,dword ptr ss:[ebp-0x104]\n009244D1    894D EC         mov dword ptr ss:[ebp-0x14],ecx\n009244D4    837D EC 00      cmp dword ptr ss:[ebp-0x14],0x0 //检测对象首地址是否为空\n009244D8    74 44           je short TestCode.0092451E\n009244DA    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n009244DD    8985 20FFFFFF   mov dword ptr ss:[ebp-0xE0],eax\n009244E3    8B8D 20FFFFFF   mov ecx,dword ptr ss:[ebp-0xE0]\n009244E9    898D 14FFFFFF   mov dword ptr ss:[ebp-0xEC],ecx\n009244EF    83BD 14FFFFFF 0>cmp dword ptr ss:[ebp-0xEC],0x0\n009244F6    74 15           je short TestCode.0092450D\n009244F8    6A 01           push 0x1 //压入对象释放标志，1为单个对象，3为释放对象数组，0表示只执行析构函数\n009244FA    8B8D 14FFFFFF   mov ecx,dword ptr ss:[ebp-0xEC]\n00924500    E8 35CDFFFF     call TestCode.0092123A //调用析构代理函数\n00924505    8985 F4FEFFFF   mov dword ptr ss:[ebp-0x10C],eax\n0092450B    EB 0A           jmp short TestCode.00924517\n0092450D    C785 F4FEFFFF 0>mov dword ptr ss:[ebp-0x10C],0x0\n00924517    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0\n0092451E    33C0            xor eax,eax\n00924520    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n00924523    64:890D 0000000>mov dword ptr fs:[0],ecx\n0092452A    59              pop ecx\n0092452B    5F              pop edi\n0092452C    5E              pop esi\n0092452D    5B              pop ebx\n0092452E    81C4 0C010000   add esp,0x10C\n00924534    3BEC            cmp ebp,esp\n00924536    E8 23CCFFFF     call TestCode.0092115E\n0092453B    8BE5            mov esp,ebp\n0092453D    5D              pop ebp\n0092453E    C3              retn\n```\n\n由此可以看出，在申请对象数组时，由于对象都在同一个堆空间中，编译器使用了堆空间的前4字节数据来保存对象的总个数。注意：这样释放空间时需要delete[]。\n\n## 参数和返回对象\n\n参数对象与返回对象会在不同的时机触发拷贝构造函数，他们的析构时机与所在作用域相关。只要函数的参数为对象类型，就会在函数调用结束后调用他的析构函数，然后释放掉参数对象所在内存空间。当返回值为对象是会有不同，返回对象时有赋值。\n\n## 全局对象与静态对象\n\n全局对象与静态对象相同，其构造函数在_cinit的第二个_initterm调用中被构造。他们的析构函数的调用时机是在main函数执行完毕之后。对应来说析构函数就应在main函数结束后。Main函数结束后，会调用exit终止程序，全局对象的析构函数也在其中。由exit函数内的doexit实现。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(六)","url":"/2016/11/26/逆向笔记-六/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之结构体和类。\n\n在C++中，结构体和类都具有构造函数，析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制为private。对于C++中的结构体而言，public，private，protected的访问控制都是在编译器进行检查，当越权访问时，编译过程中会检查出此类错误并给予提示。编译成功后，程序在执行过程中不会在访问控制方面做任何检查和限制。因此在反汇编中，C++中的结构体和类没有区别。\n\n## 对象的内存布局\n\nC代码：\n\n```c\nclass CNumber\n{\npublic:\n    //构造函数\n    CNumber()\n    {\n        m_nOne = 1;\n        m_nTwo = 2;\n    }\n    //成员函数\n    int GetOne()\n    {\n        return m_nOne;\n    }\n    int GetTwo()\n    {\n        return m_nTwo;\n    }\nprivate:\n    int m_nOne;\n    int m_nTwo;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CNumber obj;\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n00EE29E0 >  55              push ebp\n00EE29E1    8BEC            mov ebp,esp\n00EE29E3    81EC D0000000   sub esp,0xD0\n00EE29E9    53              push ebx\n00EE29EA    56              push esi\n00EE29EB    57              push edi\n00EE29EC    8DBD 30FFFFFF   lea edi,dword ptr ss:[ebp-0xD0]\n00EE29F2    B9 34000000     mov ecx,0x34\n00EE29F7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EE29FC    F3:AB           rep stos dword ptr es:[edi]\n00EE29FE    8D4D F4         lea ecx,dword ptr ss:[ebp-0xC] //取对象地址给ecx\n00EE2A01    E8 5CE8FFFF     call TestCode.00EE1262 //调用构造函数\n00EE2A06    33C0            xor eax,eax\n00EE2A08    52              push edx\n00EE2A09    8BCD            mov ecx,ebp\n00EE2A0B    50              push eax\n00EE2A0C    8D15 302AEE00   lea edx,dword ptr ds:[0xEE2A30]\n00EE2A12    E8 B5E7FFFF     call TestCode.00EE11CC\n00EE2A17    58              pop eax\n00EE2A18    5A              pop edx\n00EE2A19    5F              pop edi\n00EE2A1A    5E              pop esi\n00EE2A1B    5B              pop ebx\n00EE2A1C    81C4 D0000000   add esp,0xD0\n00EE2A22    3BEC            cmp ebp,esp\n00EE2A24    E8 B2E7FFFF     call TestCode.00EE11DB\n00EE2A29    8BE5            mov esp,ebp\n00EE2A2B    5D              pop ebp\n00EE2A2C    C3              retn\n构造函数：\n00EE3CB0 >  55              push ebp\n00EE3CB1    8BEC            mov ebp,esp\n00EE3CB3    81EC CC000000   sub esp,0xCC\n00EE3CB9    53              push ebx\n00EE3CBA    56              push esi\n00EE3CBB    57              push edi\n00EE3CBC    51              push ecx\n00EE3CBD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00EE3CC3    B9 33000000     mov ecx,0x33\n00EE3CC8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EE3CCD    F3:AB           rep stos dword ptr es:[edi]\n00EE3CCF    59              pop ecx\n00EE3CD0    894D F8         mov dword ptr ss:[ebp-0x8],ecx //this指针\n00EE3CD3    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00EE3CD6    C700 00000000   mov dword ptr ds:[eax],0x1 //初始化\n00EE3CDC    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00EE3CDF    C740 04 0000000>mov dword ptr ds:[eax+0x4],0x2 //初始化\n00EE3CE6    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00EE3CE9    5F              pop edi\n00EE3CEA    5E              pop esi\n00EE3CEB    5B              pop ebx\n00EE3CEC    8BE5            mov esp,ebp\n00EE3CEE    5D              pop ebp\n00EE3CEF    C3              retn\n```\n\n再来看一下内存中的表现形式\n\n对象首地址就是this指针，这里的八个字节被初始化为1，2，这里就是成员变量所在的地址，所以obj对象在内存中占8个字节大小的空间。先定义的数据成员在低地址处，后定义的在高地址，依次排列。对象的大小只包含数据成员，类成员函数属于执行代码，不属于类对象数据。\n\n是不是所有的类的大小都是所有的成员变量的大小之和呢？显然这是不对的，有以下三种情况：\n1）空类：空类中没有任何数据成员，按理说对象长度应为0字节，而实际情况是空类的长度为1字节。如果对象完全不占用内存空间，那么空类就无法取得实例对象地址，this指针失效，因此不能被实例化。而类的定义是由数据成员和成员函数组成，在没有数据成员的情况下，还可以有成员函数，因此仍然需要实例化，分配了1字节空间用于累的实例化，这1字节数据没有被使用。\n2）内存对齐：类和结构体中的数据成员是根据他们在类或结构体中出现的顺序来依次申请内存空间的，由于内存对齐的原因，他们并不一定会像数组那样连续的排列。由于数据类型不同，因此占用的内存大小也会不同。\n在申请内存时，会遵守一定规则：在为结构体和类中的数据成员分配内存时，结构体中的当前数据成员类型长度为M，指定的对齐值为N，那么实际对齐值为q=min(M,N)，其成员的地址安排在q的倍数上。\nC代码：\n\n```c\nstruct tagTest\n{\n    short sShort; //两字节\n    int nInt; //四字节\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    tagTest test;\n    test.sShort = 3;\n    test.nInt = 2;\n    printf(\"%d\\n\", sizeof( test ) );\n    return 0;\n}\n```\n\n由此可以看出0x0003后有两个字节是为使用的，这就是为了内存对齐。默认对齐值是8，这里int为4字节，所以对齐值为4字节。\n\n当结构体这样定义：\n\n```c\nstruct tagTest\n{\n    double dDouble; //8字节\n    short sShort;//2字节\n    int nInt;//4字节\n};\n```\n\n因为默认对齐值为8，这里总长度为14，所以只需在short后补两字节即可对齐。\n\n当结构体这样定义：\n```c\nstruct tagTest\n{\nchar cChar;//1字节    \n    short sShort;//2字节\n    int nInt;//4字节\n};\n```\n这里short应补齐6字节，但编译器检查发现结构体中最大的类型为int，占四个字节，于是调整对齐值为4，这样只需补充2字节即可实现对齐。\n\n同时我们还可以使用预编译指令#progma pack(N)来调整对齐大小。\n\n```c\n#progma pack(1)\nstruct tagTest\n{\nchar cChar;//1字节    \n    short sShort;//2字节\n    int nInt;//4字节\n};\n```\n\n这样调整后，结构体大小为1的倍数即可，所以这里结构体大小就为7。\n\n使用pack修改对齐值也并非一定生效，与默认对齐值一样，都需要参考结构体中的数据成员类型。当设定的对齐值大小结构体中的数据成员类型大小时，此对齐值同样也是无效的。对齐值的计算流程其实就是，将设定的对齐值与结构体中最大的基本数据类型数据成员的长度进行比较，取两者之间的较小者。\n\n当结构体中以数组作为成员时，将根据数组元素的长度计算对齐值，而不是按数组的整体去计算大小。\nC代码：\n\n```c\nstruct tagTest\n{\nchar cChar;//1字节    \nchar cArr[4];//4字节  \n    short sShort;//2字节\n};\n```\n\n根据结构体中各类数组成员类型得到最大为short占2字节，其余类型为1字节大小，因此只需在数组后填一字节即可对齐。\n\n\n当结构体中出现结构体类型的数据成员时，不会将嵌套的结构体类型的整体长度参与到对齐值计算中，而是以嵌套定义的结构体所使用的对齐值进行对齐。\n\nC代码：\n\n```c\nstruct tagTest\n{\nchar cChar;//1字节    \nchar cArr[4];//4字节  \n    short sShort;//2字节\n};\nstruct tagTest1\n{\nint nInt;\ntagTest test;\n}\n```\n\n在以上结构中，虽然tagTest结构占8字节，但由于其对齐值为2，因此取tagTest1结构中最大类型int，以4作为对齐值。所以结构大小应为12。\n\n\n当结构体中静态数据成员时，计算又会发生变化，后面会有详细说明。\n\n## This 指针\n\nThis指针其实就是对象的首地址。\n\n```c\nC代码：\nclass CTest\n{\npublic:\n    void SetNum(int nNum)\n    {\n        m_nInt = nNum;\n    }\n    int m_nInt;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CTest obj;\n    obj.SetNum(1);\n    \n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n00BC2FA0 >  55              push ebp\n00BC2FA1    8BEC            mov ebp,esp\n00BC2FA3    81EC CC000000   sub esp,0xCC\n00BC2FA9    53              push ebx\n00BC2FAA    56              push esi\n00BC2FAB    57              push edi\n00BC2FAC    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00BC2FB2    B9 33000000     mov ecx,0x33\n00BC2FB7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00BC2FBC    F3:AB           rep stos dword ptr es:[edi]\n00BC2FBE    6A 01           push 0x1//参数压栈\n00BC2FC0    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8] //取对象首地址，this指针\n00BC2FC3    E8 9FE2FFFF     call TestCode.00BC1267 //调用函数\n00BC2FC8    8BF4            mov esi,esp\n00BC2FCA    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]//取对象首地址给eax\n00BC2FCD    50              push eax//参数入栈\n00BC2FCE    68 A858BC00     push TestCode.00BC58A8                   ; ASCII \"CTest %d\\n\"\n00BC2FD3    FF15 1491BC00   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00BC2FD9    83C4 08         add esp,0x8\n00BC2FDC    3BF4            cmp esi,esp\n00BC2FDE    E8 F8E1FFFF     call TestCode.00BC11DB\n00BC2FE3    33C0            xor eax,eax\n00BC2FE5    52              push edx\n00BC2FE6    8BCD            mov ecx,ebp\n00BC2FE8    50              push eax\n00BC2FE9    8D15 0C30BC00   lea edx,dword ptr ds:[0xBC300C]\n00BC2FEF    E8 D8E1FFFF     call TestCode.00BC11CC\n00BC2FF4    58              pop eax\n00BC2FF5    5A              pop edx\n00BC2FF6    5F              pop edi\n00BC2FF7    5E              pop esi\n00BC2FF8    5B              pop ebx\n00BC2FF9    81C4 CC000000   add esp,0xCC\n00BC2FFF    3BEC            cmp ebp,esp\n00BC3001    E8 D5E1FFFF     call TestCode.00BC11DB\n00BC3006    8BE5            mov esp,ebp\n00BC3008    5D              pop ebp\n00BC3009    C3              retn\nSetNum函数\n00C33CB0 >  55              push ebp\n00C33CB1    8BEC            mov ebp,esp\n00C33CB3    81EC CC000000   sub esp,0xCC\n00C33CB9    53              push ebx\n00C33CBA    56              push esi\n00C33CBB    57              push edi\n00C33CBC    51              push ecx\n00C33CBD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00C33CC3    B9 33000000     mov ecx,0x33\n00C33CC8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00C33CCD    F3:AB           rep stos dword ptr es:[edi]\n00C33CCF    59              pop ecx\n00C33CD0    894D F8         mov dword ptr ss:[ebp-0x8],ecx //this指针\n00C33CD3    8B45 F8         mov eax,dword ptr ss:[ebp-0x8] \n00C33CD6    8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]\n00C33CD9    8908            mov dword ptr ds:[eax],ecx //对nInt赋值\n00C33CDB    5F              pop edi\n00C33CDC    5E              pop esi\n00C33CDD    5B              pop ebx\n00C33CDE    8BE5            mov esp,ebp\n00C33CE0    5D              pop ebp\n00C33CE1    C2 0400         retn 0x4\n```\n\n以上代码便是对象调用成员函数，这里通过寄存器ecx传递对象的首地址的方法便是this指针的由来，传递给ecx之后，编译器会将首地址复制到栈的指定位置作为this指针的值。所有的成员函数都有一个隐藏的参数，就是自身类型的对象的指针this，这样的默认调用约定就是thiscall。同样，在成员函数中访问数据成员也是需要通过this指针的。\n\n```c\nclass CTest\n{\npublic:\n    void SetNum(int nNum)\n    {\n        m_nInt = nNum;\n    }\n    int GetNum()\n    {\n//实际上是这样的，隐藏了this指针的传递而已\n        return this->m_nInt;\n    }\n    int m_nInt;\n};\n```\n\nThiscall的栈平衡方式与__stdcall一样，都是被调用方平衡，但传参过程不一样，声明为thiscall的函数第一个参数使用ecx传递，不通过栈传递。\n\n当成员函数的调用方式为__stdcall时，this指针将不会使用寄存器ecx传递，而是使用栈传递。\n\nC代码：\n\n```c\nclass CTest\n{\npublic:\n    void __stdcall SetNum(int nNum)\n    {\n        m_nInt = nNum;\n    }\n    int m_nInt;\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CTest obj;\n    obj.SetNum(1);\n    printf(\"CTest %d\\n\", obj.m_nInt);\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n010C2FA0 >  55              push ebp\n010C2FA1    8BEC            mov ebp,esp\n010C2FA3    81EC CC000000   sub esp,0xCC\n010C2FA9    53              push ebx\n010C2FAA    56              push esi\n010C2FAB    57              push edi\n010C2FAC    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n010C2FB2    B9 33000000     mov ecx,0x33\n010C2FB7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n010C2FBC    F3:AB           rep stos dword ptr es:[edi]\n010C2FBE    6A 01           push 0x1 //参数压栈\n010C2FC0    8D45 F8         lea eax,dword ptr ss:[ebp-0x8] //取对象首地址，this指针\n010C2FC3    50              push eax //压栈\n010C2FC4    E8 A3E2FFFF     call TestCode.010C126C //调用函数\n010C2FC9    8BF4            mov esi,esp\n010C2FCB    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n010C2FCE    50              push eax\n010C2FCF    68 A8580C01     push TestCode.010C58A8                   ; ASCII \"CTest %d\\n\"\n010C2FD4    FF15 14910C01   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n010C2FDA    83C4 08         add esp,0x8\nSetNum函数\n010C3CB0 >  55              push ebp\n010C3CB1    8BEC            mov ebp,esp\n010C3CB3    81EC C0000000   sub esp,0xC0\n010C3CB9    53              push ebx\n010C3CBA    56              push esi\n010C3CBB    57              push edi\n010C3CBC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n010C3CC2    B9 30000000     mov ecx,0x30\n010C3CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n010C3CCC    F3:AB           rep stos dword ptr es:[edi]\n010C3CCE    8B45 08         mov eax,dword ptr ss:[ebp+0x8]//取出this指针给eax\n010C3CD1    8B4D 0C         mov ecx,dword ptr ss:[ebp+0xC]//取出参数1给ecx\n010C3CD4    8908            mov dword ptr ds:[eax],ecx//赋值\n010C3CD6    5F              pop edi\n010C3CD7    5E              pop esi\n010C3CD8    5B              pop ebx\n010C3CD9    8BE5            mov esp,ebp\n010C3CDB    5D              pop ebp\n010C3CDC    C2 0800         retn 0x8\n```\n\n总结：\n使用thiscall调用方式的成员函数要点分析：\nLea ecx,[mem] //取对象首地址给ecx\nCall Fuc_Addr //调用成员函数\n\n函数调用内，ecx尚未重新赋值之前\nMov XXX，ecx //发现函数内使用ecx的数据，说明函数调用前对ecx赋值\n//其后ecx中的内容会传递给其他寄存器\nMov [reg+i],xxx//发现寄存器相对间接寻址方式，如果能排除数组访问，就能说明reg中保存的是结构体或者类对象的首地址\n\n使用stdcall和cdecl调用方式的成员函数分析：\nLea reg,[mem] //取出对象首地址放入寄存器\nPush reg //对象首地址作为参数入栈\nCall Func_Addr //调用成员函数\n函数调用内，将第一个参数作为指针变量，以寄存器相对间接寻址方式访问\n\n## 静态数据成员\n\nC代码：\n\n```c\nclass CStatic\n{\npublic:\n    static int m_snInt;\n    int m_nInt;\n};\nint CStatic::m_snInt = 0;\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CStatic obj;\n    printf(\"CStatic %d\\n\", sizeof(obj));\n    return 0;\n}\n```\n\n这里获取的对象内存大小为4.说明静态数据成员m_snInt并没有参与对象obj的长度计算。\n\n在成员函数中使用静态数据成员与普通数据成员分析\n\nC代码：\n\n```c\nclass CStatic\n{\npublic:\n    void Show();\n    static int m_snInt;\n    int m_nInt;\n};\nvoid CStatic::Show()\n{\n    printf(\"m_sInt:%d,m_Int:%d\\n\", m_snInt, m_nInt);\n}\nint CStatic::m_snInt = 2;\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CStatic obj;\n    obj.m_nInt = 1;\n    obj.Show();\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n003A1440 >  55              push ebp\n003A1441    8BEC            mov ebp,esp\n003A1443    81EC CC000000   sub esp,0xCC\n003A1449    53              push ebx\n003A144A    56              push esi\n003A144B    57              push edi\n003A144C    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n003A1452    B9 33000000     mov ecx,0x33\n003A1457    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003A145C    F3:AB           rep stos dword ptr es:[edi]\n003A145E    C745 F8 0100000>mov dword ptr ss:[ebp-0x8],0x1 //普通数据成员赋值\n003A1465    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8] //取对象首地址，this指针\n003A1468    E8 83FCFFFF     call TestCode.003A10F0 //调用函数\n003A146D    33C0            xor eax,eax\n003A146F    52              push edx\n003A1470    8BCD            mov ecx,ebp\n003A1472    50              push eax\n003A1473    8D15 94143A00   lea edx,dword ptr ds:[0x3A1494]\n003A1479    E8 0EFCFFFF     call TestCode.003A108C\n003A147E    58              pop eax\n003A147F    5A              pop edx\n003A1480    5F              pop edi\n003A1481    5E              pop esi\n003A1482    5B              pop ebx\n003A1483    81C4 CC000000   add esp,0xCC\n003A1489    3BEC            cmp ebp,esp\n003A148B    E8 B5FCFFFF     call TestCode.003A1145\n003A1490    8BE5            mov esp,ebp\n003A1492    5D              pop ebp\n003A1493    C3              retn\nShow函数\n003A13C0 >  55              push ebp\n003A13C1    8BEC            mov ebp,esp\n003A13C3    81EC CC000000   sub esp,0xCC\n003A13C9    53              push ebx\n003A13CA    56              push esi\n003A13CB    57              push edi\n003A13CC    51              push ecx\n003A13CD    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n003A13D3    B9 33000000     mov ecx,0x33\n003A13D8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003A13DD    F3:AB           rep stos dword ptr es:[edi]\n003A13DF    59              pop ecx\n003A13E0    894D F8         mov dword ptr ss:[ebp-0x8],ecx //this指针\n003A13E3    8BF4            mov esi,esp\n003A13E5    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n003A13E8    8B08            mov ecx,dword ptr ds:[eax]//取对象首地址内容给ecx\n003A13EA    51              push ecx //压栈\n003A13EB    8B15 00803A00   mov edx,dword ptr ds:[CStatic::m_snInt]//静态数据成员赋值\n003A13F1    52              push edx //压栈\n003A13F2    68 58583A00     push TestCode.003A5858                   ; ASCII \"m_sInt:%d,m_Int:%d\\n\"\n003A13F7    FF15 14913A00   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n003A13FD    83C4 0C         add esp,0xC\n```\n\n由此可以看出静态数据成员在反汇编代码中很难被识别，因为其展示形态与全局变量相同，很难被还原成对应高级代码。\n\n### 对象作为函数参数\n\n对象作为函数的参数时，其传递过程比较复杂，传递方式比较独特。传参过程与数组不同：数组名代表数组的首地址，而对象的变量名称却不能代表对象的首地址。传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份（复制），将复制的数据作为形参传递到调用函数中使用。在基本的数据类型中，除双精度浮点类型外，其他所有数据类型都不超过4字节大小，使用一个栈元素即可完成数据的复制和传递。但是各个对象的长度不定，所以必须采取合适的传参方式才能顺利地将对象传进函数。\n\nC代码：\n\n```c\nclass CFunTest\n{\npublic:\n    int m_nOne;\n    int m_nTwo;\n};\nvoid ShowFuncTest(CFunTest FunTest)\n{\n    printf(\"%d %d\\n\", FunTest.m_nOne, FunTest.m_nTwo);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CFunTest FunTest;\n    FunTest.m_nOne = 1;\n    FunTest.m_nTwo = 2;\n    ShowFuncTest(FunTest);\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n003E1A90 >  55              push ebp\n003E1A91    8BEC            mov ebp,esp\n003E1A93    81EC D0000000   sub esp,0xD0\n003E1A99    53              push ebx\n003E1A9A    56              push esi\n003E1A9B    57              push edi\n003E1A9C    8DBD 30FFFFFF   lea edi,dword ptr ss:[ebp-0xD0]\n003E1AA2    B9 34000000     mov ecx,0x34\n003E1AA7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003E1AAC    F3:AB           rep stos dword ptr es:[edi]\n003E1AAE    C745 F4 0100000>mov dword ptr ss:[ebp-0xC],0x1 //赋值\n003E1AB5    C745 F8 0200000>mov dword ptr ss:[ebp-0x8],0x2 //赋值\n003E1ABC    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n003E1ABF    50              push eax //参数压栈\n003E1AC0    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n003E1AC3    51              push ecx //参数压栈\n003E1AC4    E8 17F7FFFF     call TestCode.003E11E0 //调用函数\n003E1AC9    83C4 08         add esp,0x8 //堆栈平衡\nShowFuncTest函数\n003E1440 >  55              push ebp\n003E1441    8BEC            mov ebp,esp\n003E1443    81EC C0000000   sub esp,0xC0\n003E1449    53              push ebx\n003E144A    56              push esi\n003E144B    57              push edi\n003E144C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n003E1452    B9 30000000     mov ecx,0x30\n003E1457    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003E145C    F3:AB           rep stos dword ptr es:[edi]\n003E145E    8BF4            mov esi,esp\n003E1460    8B45 0C         mov eax,dword ptr ss:[ebp+0xC] //参数给eax\n003E1463    50              push eax//入栈\n003E1464    8B4D 08         mov ecx,dword ptr ss:[ebp+0x8] //参数给ecx\n003E1467    51              push ecx //入栈\n003E1468    68 C0583E00     push TestCode.003E58C0                   ; ASCII \"%d %d\\n\"\n003E146D    FF15 14913E00   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n003E1473    83C4 0C         add esp,0xC\n003E1476    3BF4            cmp esi,esp\n003E1478    E8 C8FCFFFF     call TestCode.003E1145\n003E147D    5F              pop edi\n003E147E    5E              pop esi\n003E147F    5B              pop ebx\n003E1480    81C4 C0000000   add esp,0xC0\n003E1486    3BEC            cmp ebp,esp\n003E1488    E8 B8FCFFFF     call TestCode.003E1145\n003E148D    8BE5            mov esp,ebp\n003E148F    5D              pop ebp\n003E1490    C3              retn\n```\n\n由此可以看出CFunTest类比较小，只有两个int型参数，所以它作为参数时只需要两次入栈即可。同时也可以看到类对象中的数据成员的入栈顺序：先定义的后入栈，后定义的先入栈。\n\n但是当类的体积过大或者其中定义有数组时，情况会有变化。\n\nC代码：\n\n```c\nclass CFunTest\n{\npublic:\n    int m_nOne;\n    int m_nTwo;\n    char m_szBuf[32];\n};\nvoid ShowFuncTest(CFunTest FunTest)\n{\n    printf(\"%d %d %s\\n\", FunTest.m_nOne, FunTest.m_nTwo,FunTest.m_szBuf);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CFunTest FunTest;\n    FunTest.m_nOne = 1;\n    FunTest.m_nTwo = 2;\n    strcpy(FunTest.m_szBuf, \"Test\");\n    ShowFuncTest(FunTest);\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n00EC36A0 >  55              push ebp\n00EC36A1    8BEC            mov ebp,esp\n00EC36A3    81EC F4000000   sub esp,0xF4\n00EC36A9    53              push ebx\n00EC36AA    56              push esi\n00EC36AB    57              push edi\n00EC36AC    8DBD 0CFFFFFF   lea edi,dword ptr ss:[ebp-0xF4]\n00EC36B2    B9 3D000000     mov ecx,0x3D\n00EC36B7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EC36BC    F3:AB           rep stos dword ptr es:[edi]\n00EC36BE    A1 2880EC00     mov eax,dword ptr ds:[__security_cookie]\n00EC36C3    33C5            xor eax,ebp\n00EC36C5    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n00EC36C8    C745 D0 0100000>mov dword ptr ss:[ebp-0x30],0x1 //赋值\n00EC36CF    C745 D4 0200000>mov dword ptr ss:[ebp-0x2C],0x2 //赋值\n00EC36D6    68 3059EC00     push TestCode.00EC5930                                         ; ASCII \"Test\"\n00EC36DB    8D45 D8         lea eax,dword ptr ss:[ebp-0x28] //取数组首地址\n00EC36DE    50              push eax\n00EC36DF    E8 01DBFFFF     call TestCode.00EC11E5 //strcpy\n00EC36E4    83C4 08         add esp,0x8 //堆栈平衡\n00EC36E7    83EC 28         sub esp,0x28 //太高栈顶\n00EC36EA    B9 0A000000     mov ecx,0xA //给计数器赋值\n00EC36EF    8D75 D0         lea esi,dword ptr ss:[ebp-0x30] //取对象首地址给esi\n00EC36F2    8BFC            mov edi,esp //设置edi为当前栈顶\n00EC36F4    F3:A5           rep movs dword ptr es:[edi],dword ptr ds:[esi]//以四字节拷贝0xa次\n00EC36F6    E8 E5DAFFFF     call TestCode.00EC11E0 //调用函数\n00EC36FB    83C4 28         add esp,0x28 //平衡堆栈\nShowFuncTest函数\n00EC1440 >  55              push ebp\n00EC1441    8BEC            mov ebp,esp\n00EC1443    81EC C0000000   sub esp,0xC0\n00EC1449    53              push ebx\n00EC144A    56              push esi\n00EC144B    57              push edi\n00EC144C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n00EC1452    B9 30000000     mov ecx,0x30\n00EC1457    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EC145C    F3:AB           rep stos dword ptr es:[edi]\n00EC145E    8BF4            mov esi,esp\n00EC1460    8D45 10         lea eax,dword ptr ss:[ebp+0x10] //取数组首地址\n00EC1463    50              push eax //入栈\n00EC1464    8B4D 0C         mov ecx,dword ptr ss:[ebp+0xC] //参数给ecx\n00EC1467    51              push ecx //入栈\n00EC1468    8B55 08         mov edx,dword ptr ss:[ebp+0x8] //参数给edx\n00EC146B    52              push edx //入栈\n00EC146C    68 C058EC00     push TestCode.00EC58C0                                         ; ASCII \"%d %d %s\\n\"\n00EC1471    FF15 1491EC00   call dword ptr ds:[<&MSVCR120D.printf>]                        ; MSVCR120.printf\n00EC1477    83C4 10         add esp,0x10 //堆栈平衡\n```\n\n由此可见main函数调用类成员函数的代码可以看到，由于传递的参数是类的对象，并且对象中还有数组的存在，所以不能简单的直接入栈，而是需要将栈顶指针太高，以便拥有足够的空间存储下较大的数据。这里太高栈顶使用的语句是sub esp,28h，但是书上使用的语句是add esp，FFFFFFE0h，这是一样的。加上FFFFFFE0h相当于减去20h，但是还有8字节空间呢，这里书上在调用完strcpy函数之后并没有进行栈平衡，而是继续利用之前的8字节空间，这样可以增加代码的效率，就这里有些许不一样。\n\n以上这种情况是没有定义构造函数和析构函数的情况，现在再看看定义之后的。\n\nC代码：\n\n```c\nclass CMyString\n{\npublic:\n    CMyString()\n    {\n        m_pString = new char[10];\n        if (m_pString == NULL)\n        {\n            return;\n        }\n        strcpy(m_pString, \"Test\");\n    }\n    ~CMyString()\n    {\n        if (m_pString != NULL)\n        {\n            delete m_pString;\n            m_pString = NULL;\n        }\n    }\n    char *GetString()\n    {\n        return m_pString;\n    }\nprivate:\n    char *m_pString;\n};\nvoid Show(CMyString obj)\n{\n    printf(obj.GetString());\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CMyString obj;\n    Show(obj);\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n003D1720 >  55              push ebp\n003D1721    8BEC            mov ebp,esp\n003D1723    6A FF           push -0x1\n003D1725    68 884F3D00     push TestCode.003D4F88\n003D172A    64:A1 00000000  mov eax,dword ptr fs:[0]\n003D1730    50              push eax\n003D1731    81EC D8000000   sub esp,0xD8\n003D1737    53              push ebx\n003D1738    56              push esi\n003D1739    57              push edi\n003D173A    8DBD 1CFFFFFF   lea edi,dword ptr ss:[ebp-0xE4]\n003D1740    B9 36000000     mov ecx,0x36\n003D1745    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003D174A    F3:AB           rep stos dword ptr es:[edi]\n003D174C    A1 04903D00     mov eax,dword ptr ds:[__security_cookie]\n003D1751    33C5            xor eax,ebp\n003D1753    50              push eax\n003D1754    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n003D1757    64:A3 00000000  mov dword ptr fs:[0],eax\n003D175D    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14] //取对象首地址\n003D1760    E8 7CF9FFFF     call TestCode.003D10E1 //调用构造函数\n003D1765    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0 //记录对象个数\n003D176C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14] \n003D176F    50              push eax //对象首地址做参数压栈\n003D1770    E8 1BFAFFFF     call TestCode.003D1190\n003D1775    83C4 04         add esp,0x4\n003D1778    C785 20FFFFFF 0>mov dword ptr ss:[ebp-0xE0],0x0\n003D1782    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n003D1789    8D4D EC         lea ecx,dword ptr ss:[ebp-0x14]//取对象首地址\n003D178C    E8 E6F9FFFF     call TestCode.003D1177 //调用析构函数\n003D1791    8B85 20FFFFFF   mov eax,dword ptr ss:[ebp-0xE0]\n003D1797    52              push edx\n003D1798    8BCD            mov ecx,ebp\n003D179A    50              push eax\n003D179B    8D15 C8173D00   lea edx,dword ptr ds:[0x3D17C8]\n003D17A1    E8 F0F8FFFF     call TestCode.003D1096\n003D17A6    58              pop eax\n003D17A7    5A              pop edx\n003D17A8    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC]\n003D17AB    64:890D 0000000>mov dword ptr fs:[0],ecx\n003D17B2    59              pop ecx\n003D17B3    5F              pop edi\n003D17B4    5E              pop esi\n003D17B5    5B              pop ebx\n003D17B6    81C4 E4000000   add esp,0xE4\n003D17BC    3BEC            cmp ebp,esp\n003D17BE    E8 9BF9FFFF     call TestCode.003D115E\n003D17C3    8BE5            mov esp,ebp\n003D17C5    5D              pop ebp\n003D17C6    C3              retn\nShow函数\n003D1570 >  55              push ebp\n003D1571    8BEC            mov ebp,esp\n003D1573    6A FF           push -0x1\n003D1575    68 584F3D00     push TestCode.003D4F58\n003D157A    64:A1 00000000  mov eax,dword ptr fs:[0]\n003D1580    50              push eax\n003D1581    81EC C0000000   sub esp,0xC0\n003D1587    53              push ebx\n003D1588    56              push esi\n003D1589    57              push edi\n003D158A    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n003D1590    B9 30000000     mov ecx,0x30\n003D1595    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n003D159A    F3:AB           rep stos dword ptr es:[edi]\n003D159C    A1 04903D00     mov eax,dword ptr ds:[__security_cookie]\n003D15A1    33C5            xor eax,ebp\n003D15A3    50              push eax\n003D15A4    8D45 F4         lea eax,dword ptr ss:[ebp-0xC] \n003D15A7    64:A3 00000000  mov dword ptr fs:[0],eax\n003D15AD    C745 FC 0000000>mov dword ptr ss:[ebp-0x4],0x0\n003D15B4    8D4D 08         lea ecx,dword ptr ss:[ebp+0x8] //取参数1的地址，也就是this指针\n003D15B7    E8 6CFAFFFF     call TestCode.003D1028 //调用GetString函数\n003D15BC    8BF4            mov esi,esp\n003D15BE    50              push eax //返回值压栈\n003D15BF    FF15 18A13D00   call dword ptr ds:[<&MSVCR120D.printf>]                        ; MSVCR120.printf\n003D15C5    83C4 04         add esp,0x4\n003D15C8    3BF4          cmp esi,esp\n003D15CA    E8 8FFBFFFF   call TestCode.003D115E\n003D15CF    C745 FC FFFFF>mov dword ptr ss:[ebp-0x4],-0x1 //由于对象被释放，修改对象个数\n003D15D6    8D4D 08       lea ecx,dword ptr ss:[ebp+0x8]\n003D15D9    E8 99FBFFFF   call TestCode.003D1177 //调用析构函数\n003D15DE    8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n003D15E1    64:890D 00000>mov dword ptr fs:[0],ecx\n003D15E8    59            pop ecx\n003D15E9    5F            pop edi\n003D15EA    5E            pop esi\n003D15EB    5B            pop ebx\n003D15EC    81C4 CC000000 add esp,0xCC\n003D15F2    3BEC          cmp ebp,esp\n003D15F4    E8 65FBFFFF   call TestCode.003D115E\n003D15F9    8BE5          mov esp,ebp\n003D15FB    5D            pop ebp\n003D15FC    C3            retn\n```\n\n由此可看出当对象作为参数被传递时，参数obj复制了该对象MyString中的数据成员m_pString，产生了两个CMyString对象。由于没有编写拷贝构造函数，隐藏在传参时没有被调用，这时候编译器以浅拷贝处理，m_pString指向同一个地址。这样当Show函数调用结束后会调用析构函数，释放内存。但对象obj是MyString的复制品，MyString还存在，而数据成员m_pString所保存的堆空间首地址被释放，这样会产生错误。\n\n有两种解决方法可以解决这个错误：深拷贝和设置引用计数，这两种方法都需要拷贝构造函数配合。\n深拷贝：在复制对象时，编译器会调用一次该类的深拷贝构造函数。深拷贝会将原对象的数据在保存一份，这样，当销毁复制对象时，销毁的资源是复制对象在拷贝构造函数中制作的副本，而非原对象中保存的信息。\n设置引用计数：在进入深拷贝构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0，如果是，则释放掉申请的资源，否则引用计数减1.\n\n当参数为对象的指针类型时，则不存在这种错误。传递的数据是指针类型，在函数内的操作都是针对原对象的，不存在被复制的问题。由于没有副本，因此在函数进入和退出时不会调用构造和析构函数，也就不会存在这样的隐患。因此在使用类对象作为参数时，无特殊需求，尽量使用指针或引用，不但能避免错误还能提高效率。\n\n## 对象作为返回值\n\n对象作为返回值与对象作为参数的处理方式非常类似。对象作为参数时，进入函数前预先将对象使用的栈空间保留出来，并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，再退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。\n\nC代码：\n\n```c\nclass CReturn\n{\npublic:\n    int m_nInt;\n    int m_nArr[10];\n};\nCReturn GetCReturn()\n{\n    CReturn RetObj;\n    RetObj.m_nInt = 0;\n    for (int i = 0; i < 10; i++)\n    {\n        RetObj.m_nArr[i] = i + 1;\n    }\n    return RetObj;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CReturn obj;\n    obj = GetCReturn();\n    printf(\"%d %d %d\", obj.m_nInt, obj.m_nArr[0], obj.m_nArr[9]);\n    return 0;\n}\n```\n\n对应反汇编Debug:\nMain函数\n\n```\n001E1720 >  55            push ebp\n001E1721    8BEC          mov ebp,esp\n001E1723    81EC 60010000 sub esp,0x160\n001E1729    53            push ebx\n001E172A    56            push esi\n001E172B    57            push edi\n001E172C    8DBD A0FEFFFF lea edi,dword ptr ss:[ebp-0x160]\n001E1732    B9 58000000   mov ecx,0x58\n001E1737    B8 CCCCCCCC   mov eax,0xCCCCCCCC\n001E173C    F3:AB         rep stos dword ptr es:[edi]\n001E173E    A1 04901E00   mov eax,dword ptr ds:[__security_cookie]\n001E1743    33C5          xor eax,ebp\n001E1745    8945 FC       mov dword ptr ss:[ebp-0x4],eax\n001E1748    8D85 D8FEFFFF lea eax,dword ptr ss:[ebp-0x128] //取返回对象栈空间首地址\n001E174E    50            push eax//压栈\n001E174F    E8 B9FAFFFF   call TestCode.001E120D //调用函数\n001E1754    83C4 04       add esp,0x4\n001E1757    B9 0B000000   mov ecx,0xB //设置计数器次数\n001E175C    8BF0          mov esi,eax //把返回对象首地址给esi\n001E175E    8DBD A4FEFFFF lea edi,dword ptr ss:[ebp-0x15C] //取临时对象首地址\n001E1764    F3:A5         rep movs dword ptr es:[edi],dword ptr ds:[esi] //以四字节方式拷贝0xb次\n001E1766    B9 0B000000   mov ecx,0xB //重新设置计数器\n001E176B    8DB5 A4FEFFFF lea esi,dword ptr ss:[ebp-0x15C] //取临时对象首地址\n001E1771    8D7D CC       lea edi,dword ptr ss:[ebp-0x34] //获取obj对象首地址\n001E1774    F3:A5         rep movs dword ptr es:[edi],dword ptr ds:[esi] //把数据复制到obj对象中\n001E1776    B8 04000000   mov eax,0x4\n001E177B    6BC8 09       imul ecx,eax,0x9\n001E177E    8BF4          mov esi,esp\n001E1780    8B540D D0     mov edx,dword ptr ss:[ebp+ecx-0x30]\n001E1784    52            push edx\n001E1785    B8 04000000   mov eax,0x4\n001E178A    6BC8 00       imul ecx,eax,0x0\n001E178D    8B540D D0     mov edx,dword ptr ss:[ebp+ecx-0x30]\n001E1791    52            push edx\n001E1792    8B45 CC       mov eax,dword ptr ss:[ebp-0x34]\n001E1795    50            push eax\n001E1796    68 7C681E00   push TestCode.001E687C                                         ; ASCII \"%d %d %d\"\n001E179B    FF15 18A11E00 call dword ptr ds:[<&MSVCR120D.printf>]                        ; MSVCR120.printf\n001E17A1    83C4 10       add esp,0x10\nGetCReturn函数\n001E3E60 >  55            push ebp\n001E3E61    8BEC          mov ebp,esp\n001E3E63    81EC 04010000 sub esp,0x104 //开辟栈空间，预留临时返回对象与局部对象的内存空间\n001E3E69    53            push ebx\n001E3E6A    56            push esi\n001E3E6B    57            push edi\n001E3E6C    8DBD FCFEFFFF lea edi,dword ptr ss:[ebp-0x104]\n001E3E72    B9 41000000   mov ecx,0x41\n001E3E77    B8 CCCCCCCC   mov eax,0xCCCCCCCC\n001E3E7C    F3:AB         rep stos dword ptr es:[edi]\n001E3E7E    A1 04901E00   mov eax,dword ptr ds:[__security_cookie]\n001E3E83    33C5          xor eax,ebp\n001E3E85    8945 FC       mov dword ptr ss:[ebp-0x4],eax\n001E3E88    C745 CC 00000>mov dword ptr ss:[ebp-0x34],0x0 //初始化参数\n001E3E8F    C745 C0 00000>mov dword ptr ss:[ebp-0x40],0x0 //初始化i\n001E3E96    EB 09         jmp short TestCode.001E3EA1\n001E3E98    8B45 C0       mov eax,dword ptr ss:[ebp-0x40]\n001E3E9B    83C0 01       add eax,0x1\n001E3E9E    8945 C0       mov dword ptr ss:[ebp-0x40],eax\n001E3EA1    837D C0 0A    cmp dword ptr ss:[ebp-0x40],0xA //与0xa比较\n001E3EA5    7D 0F         jge short TestCode.001E3EB6\n001E3EA7    8B45 C0       mov eax,dword ptr ss:[ebp-0x40]\n001E3EAA    83C0 01       add eax,0x1\n001E3EAD    8B4D C0       mov ecx,dword ptr ss:[ebp-0x40] //计算下标\n001E3EB0    89448D D0     mov dword ptr ss:[ebp+ecx*4-0x30],eax //根据下标寻址\n001E3EB4  ^ EB E2         jmp short TestCode.001E3E98\n001E3EB6    B9 0B000000   mov ecx,0xB //设置计数器\n001E3EBB    8D75 CC       lea esi,dword ptr ss:[ebp-0x34] //取局部对象首地址\n001E3EBE    8B7D 08       mov edi,dword ptr ss:[ebp+0x8] //取返回对象首地址\n001E3EC1    F3:A5         rep movs dword ptr es:[edi],dword ptr ds:[esi] //把局部对象数据复制到返回对象中\n001E3EC3    8B45 08       mov eax,dword ptr ss:[ebp+0x8] //保存返回结果\n001E3EC6    52            push edx\n001E3EC7    8BCD          mov ecx,ebp\n001E3EC9    50            push eax\n001E3ECA    8D15 E83E1E00 lea edx,dword ptr ds:[0x1E3EE8]\n001E3ED0    E8 C1D1FFFF   call TestCode.001E1096\n001E3ED5    58            pop eax\n001E3ED6    5A            pop edx\n001E3ED7    5F            pop edi\n001E3ED8    5E            pop esi\n001E3ED9    5B            pop ebx\n001E3EDA    8B4D FC       mov ecx,dword ptr ss:[ebp-0x4]\n001E3EDD    33CD          xor ecx,ebp\n001E3EDF    E8 3AD1FFFF   call TestCode.001E101E\n001E3EE4    8BE5          mov esp,ebp\n001E3EE6    5D            pop ebp\n001E3EE7    C3            retn\n```\n\n由此可以看出，调用GetCReturn函数前，编译器在main函数中申请的返回对象首地址作为参数入栈，在函数GetCReturn调用结束后进行了数据复制，将GetCReturn函数中定义的局部对象RetObj的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象obj，从而达到返回对象的目的。\n\n\n编译器在处理简单的结构体和类结构时，当两者经过编译器优化后，将难以识别出他们很局部变量之间的区别，但仍可根据数据的访问过程来还原相应的数据。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(五)","url":"/2016/11/23/逆向笔记-五/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之数组和指针的寻址。\n\n## 数组和指针的寻址\n\n数组在函数内\n当在函数内定义数组时，如果无其他声明，该数组即为局部变量，拥有局部变量的所有特性。数组中的数据在内存中的存储是线性连续的，其数据排列顺序由低地址到高地址，数组名表示数组首地址，如int nArr[5] = {1,2,3,4,5};此数组为5个int类型数据的集合，其占用的内存大小为sizeof(数据类型)数组元素个数，也就是45 = 20字节。\n\nC代码\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nArr[5] = { 1, 2, 3, 4, 5 };\n    int n1 = 1;\n    int n2 = 2;\n    int n3 = 3;\n    int n4 = 4;\n    int n5 = 5;\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00A63CB0 >  55              push ebp\n00A63CB1    8BEC            mov ebp,esp\n00A63CB3    81EC 18010000   sub esp,0x118\n00A63CB9    53              push ebx\n00A63CBA    56              push esi\n00A63CBB    57              push edi\n00A63CBC    8DBD E8FEFFFF   lea edi,dword ptr ss:[ebp-0x118]\n00A63CC2    B9 46000000     mov ecx,0x46\n00A63CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00A63CCC    F3:AB           rep stos dword ptr es:[edi]\n00A63CCE    C745 E8 0100000>mov dword ptr ss:[ebp-0x18],0x1\n00A63CD5    C745 EC 0200000>mov dword ptr ss:[ebp-0x14],0x2\n00A63CDC    C745 F0 0300000>mov dword ptr ss:[ebp-0x10],0x3\n00A63CE3    C745 F4 0400000>mov dword ptr ss:[ebp-0xC],0x4\n00A63CEA    C745 F8 0500000>mov dword ptr ss:[ebp-0x8],0x5 //初始化数组\n00A63CF1    C745 DC 0100000>mov dword ptr ss:[ebp-0x24],0x1 //初始化局部变量\n00A63CF8    C745 D0 0200000>mov dword ptr ss:[ebp-0x30],0x2\n00A63CFF    C745 C4 0300000>mov dword ptr ss:[ebp-0x3C],0x3\n00A63D06    C745 B8 0400000>mov dword ptr ss:[ebp-0x48],0x4\n00A63D0D    C745 AC 0500000>mov dword ptr ss:[ebp-0x54],0x5\n00A63D14    33C0            xor eax,eax\n00A63D16    52              push edx\n00A63D17    8BCD            mov ecx,ebp\n00A63D19    50              push eax\n00A63D1A    8D15 303DA600   lea edx,dword ptr ds:[0xA63D30]\n00A63D20    E8 A7D4FFFF     call TestCode.00A611CC\n00A63D25    58              pop eax\n00A63D26    5A              pop edx\n00A63D27    5F              pop edi\n00A63D28    5E              pop esi\n00A63D29    5B              pop ebx\n00A63D2A    8BE5            mov esp,ebp\n00A63D2C    5D              pop ebp\n00A63D2D    C3              retn\n```\n\n对于数组的识别，应判断数据在内存中是否是连续且类型是否一致，均符合即可将此段数据视为数组。\nIda对数组的识别（ida下的标号var_18为常量-18，这里地址值最小，因此为数据的首地址，双击标号“var_18”定位到标号定义处，单击此标号，按*键，以标号“var_18”所标示的地址为数组首地址，每个元素4字节大小向后解释五个数据作为数组元素）：\n现在再来看一下字符串，其实字符串就是字符数组，只是最后一个元素为‘\\0’作为字符串结束标志而已。书上说在Vc++6.0编译器下，为字符类型的数组赋值（初始化）其实是复制字符串的过程。\n这里并不是单字节复制，而是每次复制4字节的数据。\nC代码：\n\n```c\nChar szBuf = “Hello World”;\n```\n\n对应反汇编Debug：\n\n```\n01173D14    A1 A8581701     mov eax,dword ptr ds:[0x11758A8]\n01173D19    8945 98         mov dword ptr ss:[ebp-0x68],eax\n01173D1C    8B0D AC581701   mov ecx,dword ptr ds:[0x11758AC]\n01173D22    894D 9C         mov dword ptr ss:[ebp-0x64],ecx\n01173D25    8B15 B0581701   mov edx,dword ptr ds:[0x11758B0]\n01173D2B    8955 A0         mov dword ptr ss:[ebp-0x60],edx\n```\n\n由此可以看出，这里使用了eax，ecx，edx三个寄存器，将字符串分为三段每次四字节复制到szBuf中。这里字符串长度恰巧为4的倍数。当长度不为4的倍数时候，会在最后一次不等于4字节的数据过程中按照或者2字节的方式复制。\nC代码：\n\n```c\nChar szBuf = “Hello World 12”; //长度不为4的倍数\n```\n\n对应反汇编Debug：\n\n```\n003D3D14    A1 A8583D00     mov eax,dword ptr ds:[0x3D58A8]\n003D3D19    8945 94         mov dword ptr ss:[ebp-0x6C],eax\n003D3D1C    8B0D AC583D00   mov ecx,dword ptr ds:[0x3D58AC]\n003D3D22    894D 98         mov dword ptr ss:[ebp-0x68],ecx\n003D3D25    8B15 B0583D00   mov edx,dword ptr ds:[0x3D58B0]\n003D3D2B    8955 9C         mov dword ptr ss:[ebp-0x64],edx\n003D3D2E    66:A1 B4583D00  mov ax,word ptr ds:[0x3D58B4]\n003D3D34    66:8945 A0      mov word ptr ss:[ebp-0x60],ax\n003D3D38    8A0D B6583D00   mov cl,byte ptr ds:[0x3D58B6]\n003D3D3E    884D A2         mov byte ptr ss:[ebp-0x5E],cl\n```\n\n由此可以看出前面的复制过程没有改变，最后的三字节先复制两字节，最后复制一字节。\n\n## 数组作为参数\n\nC代码：\n\n```c\nvoid Show(char szBuf[])\n{\n    strcpy(szBuf,\"Hello World\");\n    printf(szBuf);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char szBuf[20] = { 0 };\n    Show(szBuf);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n00EC33F0 >  55              push ebp\n00EC33F1    8BEC            mov ebp,esp\n00EC33F3    81EC E0000000   sub esp,0xE0\n00EC33F9    53              push ebx\n00EC33FA    56              push esi\n00EC33FB    57              push edi\n00EC33FC    8DBD 20FFFFFF   lea edi,dword ptr ss:[ebp-0xE0]\n00EC3402    B9 38000000     mov ecx,0x38\n00EC3407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EC340C    F3:AB           rep stos dword ptr es:[edi]\n00EC340E    A1 0C80EC00     mov eax,dword ptr ds:[__security_cookie]\n00EC3413    33C5            xor eax,ebp\n00EC3415    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n00EC3418    C645 E4 00      mov byte ptr ss:[ebp-0x1C],0x0 //初始化数组，ebp-0x1c为数组首地址\n00EC341C    33C0            xor eax,eax\n00EC341E    8945 E5         mov dword ptr ss:[ebp-0x1B],eax\n00EC3421    8945 E9         mov dword ptr ss:[ebp-0x17],eax\n00EC3424    8945 ED         mov dword ptr ss:[ebp-0x13],eax\n00EC3427    8945 F1         mov dword ptr ss:[ebp-0xF],eax\n00EC342A    66:8945 F5      mov word ptr ss:[ebp-0xB],ax\n00EC342E    8845 F7         mov byte ptr ss:[ebp-0x9],al\n00EC3431    8D45 E4         lea eax,dword ptr ss:[ebp-0x1C] //取地址\n00EC3434    50              push eax //参数入栈\n00EC3435    E8 00DEFFFF     call TestCode.00EC123A //调用Show函数\n00EC343A    83C4 04         add esp,0x4 //平衡堆栈\n00EC343D    33C0            xor eax,eax\n00EC343F    52              push edx\n00EC3440    8BCD            mov ecx,ebp\n00EC3442    50              push eax\n00EC3443    8D15 7034EC00   lea edx,dword ptr ds:[0xEC3470]\n00EC3449    E8 7EDDFFFF     call TestCode.00EC11CC\n00EC344E    58              pop eax\n00EC344F    5A              pop edx\n00EC3450    5F              pop edi\n00EC3451    5E              pop esi\n00EC3452    5B              pop ebx\n00EC3453    8B4D FC         mov ecx,dword ptr ss:[ebp-0x4]\n00EC3456    33CD            xor ecx,ebp\n00EC3458    E8 C1DBFFFF     call TestCode.00EC101E\n00EC345D    81C4 E0000000   add esp,0xE0\n00EC3463    3BEC            cmp ebp,esp\n00EC3465    E8 71DDFFFF     call TestCode.00EC11DB\n00EC346A    8BE5            mov esp,ebp\n00EC346C    5D              pop ebp\n00EC346D    C3              retn\nShow函数\n00EC3CB0 >  55              push ebp\n00EC3CB1    8BEC            mov ebp,esp\n00EC3CB3    81EC C0000000   sub esp,0xC0\n00EC3CB9    53              push ebx\n00EC3CBA    56              push esi\n00EC3CBB    57              push edi\n00EC3CBC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n00EC3CC2    B9 30000000     mov ecx,0x30\n00EC3CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00EC3CCC    F3:AB           rep stos dword ptr es:[edi]\n00EC3CCE    68 A858EC00     push TestCode.00EC58A8                   ; ASCII \"Hello World\" //压入字符串\n00EC3CD3    8B45 08         mov eax,dword ptr ss:[ebp+0x8] //参数1给eax\n00EC3CD6    50              push eax //参数1入栈\n00EC3CD7    E8 68D5FFFF     call TestCode.00EC1244 //调用strcpy函数\n00EC3CDC    83C4 08         add esp,0x8 //平衡堆栈\n00EC3CDF    8BF4            mov esi,esp\n00EC3CE1    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00EC3CE4    50              push eax \n00EC3CE5    FF15 1491EC00   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00EC3CEB    83C4 04         add esp,0x4\n00EC3CEE    3BF4            cmp esi,esp\n00EC3CF0    E8 E6D4FFFF     call TestCode.00EC11DB\n00EC3CF5    5F              pop edi\n00EC3CF6    5E              pop esi\n00EC3CF7    5B              pop ebx\n00EC3CF8    81C4 C0000000   add esp,0xC0\n00EC3CFE    3BEC            cmp ebp,esp\n00EC3D00    E8 D6D4FFFF     call TestCode.00EC11DB\n00EC3D05    8BE5            mov esp,ebp\n00EC3D07    5D              pop ebp\n00EC3D08    C3              retn\n```\n\n从这里可以看出，当数组作为参数时，数组下标被省略了。因为当数组作为函数参数时，函数参数中保存的是数组的首地址，是一个指针变量。虽然是指针变量，但需要特别注意的是，实参数组名为常量值，而指针或形参数组为变量。使用sizeof(数组名)可以获取数组的总大小，而对指针或者形参中保存的数组名使用sizeof只能得到指针长度。\n\n再来看看Release下的字符串处理函数\n这里我用的编译器是vs2013\n\n代码都优化掉了。\n\nVc6编译后的反汇编Release：\n\n```\ntext:00401000 sub_401000      proc near               ; CODE XREF: _main+F\n.text:00401000\n.text:00401000 arg_0           = dword ptr  4\n.text:00401000\n.text:00401000                 push    edi\n.text:00401001                 mov     edi, [esp+4+arg_0] //把字符串首地址给edi \n.text:00401005                 or      ecx, 0FFFFFFFFh //ecx置为-1配合使用  repne scasb指令\n.text:00401008                 xor     eax, eax //清零eax\n.text:0040100A                 repne scasb\n//repne/repnz与scas指令结合使用，表示串未结束（ecx!=0）\n//当eax与串元素不相同（zf = 0）时，继续重复执行串搜索指令\n//可用来在字符串中查找和eax值相同的数据位置\n.text:0040100C                 not     ecx //对ecx取反\n.text:0040100E                 dec     ecx //对取反后的值-1得到字符串长度\n.text:0040100F                 pop     edi\n.text:00401010                 mov     eax, ecx\n.text:00401012                 retn\n.text:00401012 sub_401000      endp\n```\n\n优化后的strlen函数被编译为内联函数，其实现过程为，先将eax清零，然后通过repne scasb指令遍历字符串，寻找与eax匹配的字符。由于指令repne scasb中的前缀repne是用来考察ecx的值，因此在ecx不为0且zf标志为0时才重复操作，在操作过程中自动对ecx减一。可见不适合将ecx作为从0开始的字符计数器。由于目标字符串的长度未知，所以置为-1，可满足最大需求。\n统计完成后可根据ecx的值推算出字符串长度，推算过程如下：\nEcx的初始值为0xffffffff（-1），repne前缀每次执行时-1，如果edi指向内容为字符串结束符，则结束操作。注意，ecx的计数包含了字符串末尾的0.假设字符串长度为Len，可得到等式\nEcx（终值） = Ecx（初值） - （Len + 1）\n将Ecx初值-1带入得\nEcx（终值） = -1 - （Len + 1） = -（Len + 2）\n定义neg为求补运算，则\nNeg（Ecx（终值）） = Len + 2\n求补运算等价于取反加一，定义not为取反运算，则\nNeg（Ecx（终值）） + 1 = Len + 2\n解方程求Len\nLen = not（Ecx（终值）） - 1\n至此对strlen的分析完毕。\n\n## Strcpy分析\n\nVc6编译后的反汇编Release：\n\n```\n.text:00401000 sub_401000      proc near               ; CODE XREF: _main+32\n.text:00401000\n.text:00401000 arg_0           = dword ptr  4\n.text:00401000\n.text:00401000                 push    esi\n.text:00401001                 push    edi\n.text:00401002                 mov     edi, offset aHello ; \"Hello\" //把字符串给edi\n.text:00401007                 or      ecx, 0FFFFFFFFh //ecx置为-1\n.text:0040100A                 xor     eax, eax //清零eax\n.text:0040100C                 repne scasb\n.text:0040100E                 mov     eax, [esp+8+arg_0] //字符串首地址给eax\n.text:00401012                 not     ecx //对ecx取反，得到字符串长度\n.text:00401014                 sub     edi, ecx //执行repne scasb指令后edi指向字符串末尾，减去ecx重新指向字符串首地址\n.text:00401016                 push    eax             ; char * //参数入栈\n.text:00401017                 mov     edx, ecx //把字符串长度给edx\n.text:00401019                 mov     esi, edi //把字符串首地址给esi\n.text:0040101B                 mov     edi, eax //参数给edi\n.text:0040101D                 shr     ecx, 2 //右移两位相当于/4\n.text:00401020                 rep movsd //拷贝字符串，每次复制4字节，根据ecx数值决定复制多少次\n.text:00401022                 mov     ecx, edx //把字符串长度给ecx\n.text:00401024                 and     ecx, 3 //ecx与3进行与运算，等价于ecx对4求余\n.text:00401027                 rep movsb //拷贝字符串，单字节拷贝\n.text:00401029                 call    _printf\n.text:0040102E                 add     esp, 4\n.text:00401031                 pop     edi\n.text:00401032                 pop     esi\n.text:00401033                 retn\n.text:00401033 sub_401000      endp\n```\n\n## 局部数组作为返回值\n\n局部变量可以作为返回值，这是因为局部变量虽然也在函数的栈中，但是他会在函数结束之前将值存入某个寄存器中（一般是eax与edx），但是局部数组作为返回值往往只会将他的首地址存入某个寄存器，这样一来当寄存器存储的地址内的区域里面的内容发生改变时便会造成原数据的改变。\n\nC代码：\n\n```c\nchar *RetArr()\n{\n    char szBuf[] = { \"Hello World\" };\n    return szBuf;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    printf(\"%s\", RetArr());\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n00871790 >  55              push ebp\n00871791    8BEC            mov ebp,esp\n00871793    81EC C0000000   sub esp,0xC0\n00871799    53              push ebx\n0087179A    56              push esi\n0087179B    57              push edi\n0087179C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n008717A2    B9 30000000     mov ecx,0x30\n008717A7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n008717AC    F3:AB           rep stos dword ptr es:[edi]\n008717AE    E8 9BFAFFFF     call TestCode.0087124E //调用RetArr函数\n008717B3    8BF4            mov esi,esp\n008717B5    50              push eax\n008717B6    68 B4588700     push TestCode.008758B4                   ; ASCII \"%s\"\n008717BB    FF15 14918700   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n008717C1    83C4 08         add esp,0x8\n008717C4    3BF4            cmp esi,esp\n008717C6    E8 10FAFFFF     call TestCode.008711DB\n008717CB    33C0            xor eax,eax\n008717CD    5F              pop edi\n008717CE    5E              pop esi\n008717CF    5B              pop ebx\n008717D0    81C4 C0000000   add esp,0xC0\n008717D6    3BEC            cmp ebp,esp\n008717D8    E8 FEF9FFFF     call TestCode.008711DB\n008717DD    8BE5            mov esp,ebp\n008717DF    5D              pop ebp\n008717E0    C3              retn\nRetArr函数\n008733F0 >  55              push ebp\n008733F1    8BEC            mov ebp,esp\n008733F3    81EC D8000000   sub esp,0xD8\n008733F9    53              push ebx\n008733FA    56              push esi\n008733FB    57              push edi\n008733FC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00873402    B9 36000000     mov ecx,0x36\n00873407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0087340C    F3:AB           rep stos dword ptr es:[edi]\n0087340E    A1 0C808700     mov eax,dword ptr ds:[__security_cookie]\n00873413    33C5            xor eax,ebp\n00873415    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n00873418    A1 A8588700     mov eax,dword ptr ds:[0x8758A8] \n0087341D    8945 EC         mov dword ptr ss:[ebp-0x14],eax \n00873420    8B0D AC588700   mov ecx,dword ptr ds:[0x8758AC]\n00873426    894D F0         mov dword ptr ss:[ebp-0x10],ecx\n00873429    8B15 B0588700   mov edx,dword ptr ds:[0x8758B0]\n0087342F    8955 F4         mov dword ptr ss:[ebp-0xC],edx\n00873432    8D45 EC         lea eax,dword ptr ss:[ebp-0x14] //将数组的首地址存入寄存器作为返回值\n00873435    52              push edx\n00873436    8BCD            mov ecx,ebp\n00873438    50              push eax\n00873439    8D15 58348700   lea edx,dword ptr ds:[0x873458]\n0087343F    E8 88DDFFFF     call TestCode.008711CC\n00873444    58              pop eax\n00873445    5A              pop edx\n00873446    5F              pop edi\n00873447    5E              pop esi\n00873448    5B              pop ebx\n00873449    8B4D FC         mov ecx,dword ptr ss:[ebp-0x4]\n0087344C    33CD            xor ecx,ebp\n0087344E    E8 CBDBFFFF     call TestCode.0087101E\n00873453    8BE5            mov esp,ebp\n00873455    5D              pop ebp\n00873456    C3              retn\n```\n\n由此来看好像并不会出现什么问题，在调用printf函数之前将eax的值作为参数入栈，然后将其所在的内存空间中的内容以字符串的形式输出。eax是安全的，但是以eax的值作为地址的内存空间并不安全。\n如果想使用数组作为返回值，又想避免如上错误，可以使用全局数组，静态数组或是上层调用函数中定义的局部数组。\n\n全局数组与静态数组都属于变量，他们的特征与全局变量，静态变量相同，看上去就是连续定义的多个同类型变量。\n\nC代码：\n\n```c\nint g_nArry[5] = { 1, 2, 3, 4, 5 };\nint _tmain(int argc, _TCHAR* argv[])\n{\n    for (int i = 0; i < 5; i++)\n    {\n        printf(\"%d\", g_nArry[i]);\n    }\n    //printf(\"%s\", RetArr());\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n.text:00412FA0 ; int __cdecl main(int argc, const char **argv, const char **envp)\n.text:00412FA0 main            proc near               ; CODE XREF: j_main\n.text:00412FA0                                         ; .text:004111C2\n.text:00412FA0\n.text:00412FA0 var_CC          = byte ptr -0CCh\n.text:00412FA0 var_8           = dword ptr -8\n.text:00412FA0 argc            = dword ptr  8\n.text:00412FA0 argv            = dword ptr  0Ch\n.text:00412FA0 envp            = dword ptr  10h\n.text:00412FA0\n.text:00412FA0                 push    ebp\n.text:00412FA1                 mov     ebp, esp\n.text:00412FA3                 sub     esp, 0CCh\n.text:00412FA9                 push    ebx\n.text:00412FAA                 push    esi\n.text:00412FAB                 push    edi\n.text:00412FAC                 lea     edi, [ebp+var_CC]\n.text:00412FB2                 mov     ecx, 33h\n.text:00412FB7                 mov     eax, 0CCCCCCCCh\n.text:00412FBC                 rep stosd\n.text:00412FBE                 mov     [ebp+var_8], 0 //i赋初值\n.text:00412FC5                 jmp     short loc_412FD0\n.text:00412FC7 ; ---------------------------------------------------------------------------\n.text:00412FC7\n.text:00412FC7 loc_412FC7:                             ; CODE XREF: main+58\n.text:00412FC7                 mov     eax, [ebp+var_8] \n.text:00412FCA                 add     eax, 1 //i++\n.text:00412FCD                 mov     [ebp+var_8], eax\n.text:00412FD0\n.text:00412FD0 loc_412FD0:                             ; CODE XREF: main+25\n.text:00412FD0                 cmp     [ebp+var_8], 5 //与5比较，循环最大值\n.text:00412FD4                 jge     short loc_412FFA //大于则跳出循环\n.text:00412FD6                 mov     esi, esp\n.text:00412FD8                 mov     eax, [ebp+var_8]\n.text:00412FDB                 mov     ecx, dword_418028[eax*4] //dword_418028为全局数组，利用下标寻址到相应数据\n.text:00412FE2                 push    ecx\n.text:00412FE3                 push    offset Format   ; \"%d\"\n.text:00412FE8                 call    ds:printf //调用printf\n.text:00412FEE                 add     esp, 8 //堆栈平衡\n.text:00412FF1                 cmp     esi, esp\n.text:00412FF3                 call    sub_4111DB\n.text:00412FF8                 jmp     short loc_412FC7\n.text:00412FFA ; ---------------------------------------------------------------------------\n.text:00412FFA\n.text:00412FFA loc_412FFA:                             ; CODE XREF: main+34\n.text:00412FFA                 xor     eax, eax\n.text:00412FFC                 pop     edi\n.text:00412FFD                 pop     esi\n.text:00412FFE                 pop     ebx\n.text:00412FFF                 add     esp, 0CCh\n.text:00413005                 cmp     ebp, esp\n.text:00413007                 call    sub_4111DB\n.text:0041300C                 mov     esp, ebp\n.text:0041300E                 pop     ebp\n.text:0041300F                 retn\n.text:0041300F main            endp\n```\n\n*键对数据进行编辑，\n\n再来看看静态全局数组，静态数组在全局情况下和全局数组相同。作为局部作用域定义时，则同样会检查相应的标志位，并对局部静态数组元素赋值。与局部静态变量有些不同，无论局部静态数组有多少个元素，也只会检查一次初始化标志位。\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int n1;\n    int n2;\n    scanf(\"%d%d\", &n1, &n2);\n    static int g_snArr[5] = { n1, n2, 0 };\n    return 0;\n}\n```\n\n对应反汇编代码Debug：\n\n```\n00913AC0 >  55              push ebp\n00913AC1    8BEC            mov ebp,esp\n00913AC3    81EC D8000000   sub esp,0xD8\n00913AC9    53              push ebx\n00913ACA    56              push esi\n00913ACB    57              push edi\n00913ACC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00913AD2    B9 36000000     mov ecx,0x36\n00913AD7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00913ADC    F3:AB           rep stos dword ptr es:[edi]\n00913ADE    8BF4            mov esi,esp\n00913AE0    8D45 EC         lea eax,dword ptr ss:[ebp-0x14] //n2\n00913AE3    50              push eax\n00913AE4    8D4D F8         lea ecx,dword ptr ss:[ebp-0x8] //n1\n00913AE7    51              push ecx\n00913AE8    68 18599100     push TestCode.00915918                   ; ASCII \"%d%d\"\n00913AED    FF15 3C919100   call dword ptr ds:[<&MSVCR120D.scanf>]   ; MSVCR120.scanf //调用scanf\n00913AF3    83C4 0C         add esp,0xC //堆栈平衡\n00913AF6    3BF4            cmp esi,esp\n00913AF8    E8 DED6FFFF     call TestCode.009111DB\n00913AFD    A1 BC849100     mov eax,dword ptr ds:[$S1]\n00913B02    83E0 01         and eax,0x1 //检查标准位是否为1，初始化了则跳过下面代码\n00913B05    75 33           jnz short TestCode.00913B3A\n00913B07    A1 BC849100     mov eax,dword ptr ds:[$S1]\n00913B0C    83C8 01         or eax,0x1 //将标志位置为1\n00913B0F    A3 BC849100     mov dword ptr ds:[$S1],eax //写回标志位\n00913B14    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]\n00913B17    A3 A8849100     mov dword ptr ds:[g_snArr],eax\n00913B1C    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00913B1F    A3 AC849100     mov dword ptr ds:[0x9184AC],eax\n00913B24    C705 B0849100 0>mov dword ptr ds:[0x9184B0],0x0\n00913B2E    33C0            xor eax,eax\n00913B30    A3 B4849100     mov dword ptr ds:[0x9184B4],eax\n00913B35    A3 B8849100     mov dword ptr ds:[0x9184B8],eax\n00913B3A    33C0            xor eax,eax\n00913B3C    52              push edx\n00913B3D    8BCD            mov ecx,ebp\n00913B3F    50              push eax\n00913B40    8D15 643B9100   lea edx,dword ptr ds:[0x913B64]\n00913B46    E8 81D6FFFF     call TestCode.009111CC\n00913B4B    58              pop eax\n00913B4C    5A              pop edx\n00913B4D    5F              pop edi\n00913B4E    5E              pop esi\n00913B4F    5B              pop ebx\n00913B50    81C4 D8000000   add esp,0xD8\n00913B56    3BEC            cmp ebp,esp\n00913B58    E8 7ED6FFFF     call TestCode.009111DB\n00913B5D    8BE5            mov esp,ebp\n00913B5F    5D              pop ebp\n00913B60    C3              retn\n```\n\n由此可以看出无论静态局部数组有多少个元素，都只进行一次初始化。\n\n## 下标寻址和指针寻址\n\n访问数组的方法有两种：通过下标访问（寻址）和通过指针访问（寻址）。因为使用方便，通过下标访问的方式比较常用，其格式为“数组名[标号]”。指针寻址的方式不但没有下标寻址的方式便利，而且效率也比下标寻址低。由于指针是存放地址数据的变量类型，因此在数据访问的过程中需要先取出指针变量中的数据，然后在针对此数据进行地址偏移计算，从而寻址到目标数据。数组名本身就是常量地址，可直接针对数组名所代替的地址值进行偏移计算。\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char *pChar = NULL;\n    char szBuf[] = \"Hello\";\n    pChar = szBuf;\n    printf(\"%c\\n\", *pChar);\n    printf(\"%c\\n\", szBuf[0]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n01143CB0 >  55              push ebp\n01143CB1    8BEC            mov ebp,esp\n01143CB3    81EC E0000000   sub esp,0xE0\n01143CB9    53              push ebx\n01143CBA    56              push esi\n01143CBB    57              push edi\n01143CBC    8DBD 20FFFFFF   lea edi,dword ptr ss:[ebp-0xE0]\n01143CC2    B9 38000000     mov ecx,0x38\n01143CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n01143CCC    F3:AB           rep stos dword ptr es:[edi]\n01143CCE    A1 0C801401     mov eax,dword ptr ds:[__security_cookie]\n01143CD3    33C5            xor eax,ebp\n01143CD5    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n01143CD8    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0 //初始化指针\n01143CDF    A1 A8581401     mov eax,dword ptr ds:[0x11458A8]\n01143CE4    8945 E4         mov dword ptr ss:[ebp-0x1C],eax\n01143CE7    66:8B0D AC58140>mov cx,word ptr ds:[0x11458AC]\n01143CEE    66:894D E8      mov word ptr ss:[ebp-0x18],cx //初始化字符串数组\n01143CF2    8D45 E4         lea eax,dword ptr ss:[ebp-0x1C] //取数组首地址\n01143CF5    8945 F4         mov dword ptr ss:[ebp-0xC],eax //把地址给指针\n01143CF8    8B45 F4         mov eax,dword ptr ss:[ebp-0xC]\n01143CFB    0FBE08          movsx ecx,byte ptr ds:[eax] //取内容给ecx\n01143CFE    8BF4            mov esi,esp\n01143D00    51              push ecx\n01143D01    68 B0581401     push TestCode.011458B0                   ; ASCII \"%c\\n\"\n01143D06    FF15 14911401   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf //调用printf\n01143D0C    83C4 08         add esp,0x8 //堆栈平衡\n01143D0F    3BF4            cmp esi,esp\n01143D11    E8 C5D4FFFF     call TestCode.011411DB\n01143D16    B8 01000000     mov eax,0x1 //eax == 1\n01143D1B    6BC8 00         imul ecx,eax,0x0 //计算下标\n01143D1E    0FBE540D E4     movsx edx,byte ptr ss:[ebp+ecx-0x1C]//通过下标访问数组\n01143D23    8BF4            mov esi,esp\n01143D25    52              push edx\n01143D26    68 B0581401     push TestCode.011458B0                   ; ASCII \"%c\\n\"\n01143D2B    FF15 14911401   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf //调用printf\n01143D31    83C4 08         add esp,0x8 //堆栈平衡\n01143D34    3BF4            cmp esi,esp\n01143D36    E8 A0D4FFFF     call TestCode.011411DB\n01143D3B    33C0            xor eax,eax\n01143D3D    52              push edx\n01143D3E    8BCD            mov ecx,ebp\n01143D40    50              push eax\n01143D41    8D15 6C3D1401   lea edx,dword ptr ds:[0x1143D6C]\n01143D47    E8 80D4FFFF     call TestCode.011411CC\n01143D4C    58              pop eax\n01143D4D    5A              pop edx\n01143D4E    5F              pop edi\n01143D4F    5E              pop esi\n01143D50    5B              pop ebx\n01143D51    8B4D FC         mov ecx,dword ptr ss:[ebp-0x4]\n01143D54    33CD            xor ecx,ebp\n01143D56    E8 C3D2FFFF     call TestCode.0114101E\n01143D5B    81C4 E0000000   add esp,0xE0\n01143D61    3BEC            cmp ebp,esp\n01143D63    E8 73D4FFFF     call TestCode.011411DB\n01143D68    8BE5            mov esp,ebp\n01143D6A    5D              pop ebp\n01143D6B    C3              retn\n```\n\n书上说指针和下标寻址有着很明显的区别，指针需要进行两次寻址，而下标只需要一次，所以下标寻址的效率比较高，虽然使用指针效率低，但是更为灵活，可以改变指针变量中的地址来访问其他内存，而数组下标在不越界的情况下是无法访问到数组以外的数据的。\n数组下标寻址公式：设首地址为aryAddr，数组元素的类型为type，元素个数为M个，下标为N\n\n```\ntype Ary[M];\n&Ary[n] == (type )((int)aryAddr + sizeof(type)n)\n```\n\n## 下标值为整形常量\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nArr[5] = { 1, 2, 3, 4, 5 };\n    printf(\"%d\\n\", nArr[0]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00043CD8    C745 E4 0100000>mov dword ptr ss:[ebp-0x1C],0x1\n00043CDF    C745 E8 0200000>mov dword ptr ss:[ebp-0x18],0x2\n00043CE6    C745 EC 0300000>mov dword ptr ss:[ebp-0x14],0x3\n00043CED    C745 F0 0400000>mov dword ptr ss:[ebp-0x10],0x4\n00043CF4    C745 F4 0500000>mov dword ptr ss:[ebp-0xC],0x5 //数组初始化\n00043CFB    B8 04000000     mov eax,0x4 \n00043D00    D1E0            shl eax,1 //计算下标\n00043D02    8BF4            mov esi,esp\n00043D04    8B4C05 E4       mov ecx,dword ptr ss:[ebp+eax-0x1C] //取数组对应下标内容\n00043D08    51              push ecx\n00043D09    68 A8580400     push TestCode.000458A8                   ; ASCII \"%d\\n\"\n00043D0E    FF15 14910400   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n```\n\n套用公式计算：\n&Ary[2] ==（int）（（int）ebp-0x1C + sizeof（int）2）\n在下标值为常量的情况下，由于类型大小为已知数，编译器可以直接计算出数据所在的地址。\n\n## 下标值为为整形变量\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nArr[5] = { 1, 2, 3, 4, 5 };\n    printf(\"%d\\n\", nArr[argc]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00A43CD8    C745 E4 0100000>mov dword ptr ss:[ebp-0x1C],0x1\n00A43CDF    C745 E8 0200000>mov dword ptr ss:[ebp-0x18],0x2\n00A43CE6    C745 EC 0300000>mov dword ptr ss:[ebp-0x14],0x3\n00A43CED    C745 F0 0400000>mov dword ptr ss:[ebp-0x10],0x4\n00A43CF4    C745 F4 0500000>mov dword ptr ss:[ebp-0xC],0x5 //数组初始化\n00A43CFB    8BF4            mov esi,esp\n00A43CFD    8B45 08         mov eax,dword ptr ss:[ebp+0x8] //把参数一的值给eax\n00A43D00    8B4C85 E4       mov ecx,dword ptr ss:[ebp+eax*4-0x1C] //寻址计算\n00A43D04    51              push ecx\n00A43D05    68 A858A400     push TestCode.00A458A8                   ; ASCII \"%d\\n\"\n00A43D0A    FF15 1491A400   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00A43D10    83C4 08         add esp,0x8\n```\n\n## 下标值为整形表达式\n\n当下标值为表达式时，会先计算出表达式的结果，然后将其结果作为下标值。当整形表达式的计算结果可以计算出来时，编译器会选择常量折叠，将表达式用常量代替。\n\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nArr[5] = { 1, 2, 3, 4, 5 };\n    printf(\"%d\\n\", nArr[argc * 2]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00C03CD8    C745 E4 0100000>mov dword ptr ss:[ebp-0x1C],0x1\n00C03CDF    C745 E8 0200000>mov dword ptr ss:[ebp-0x18],0x2\n00C03CE6    C745 EC 0300000>mov dword ptr ss:[ebp-0x14],0x3\n00C03CED    C745 F0 0400000>mov dword ptr ss:[ebp-0x10],0x4\n00C03CF4    C745 F4 0500000>mov dword ptr ss:[ebp-0xC],0x5 //数组初始化\n00C03CFB    8B45 08         mov eax,dword ptr ss:[ebp+0x8] //参数1给eax\n00C03CFE    D1E0            shl eax,1 //左移一位，相当于乘以2\n00C03D00    8BF4            mov esi,esp\n00C03D02    8B4C85 E4       mov ecx,dword ptr ss:[ebp+eax*4-0x1C]//根据下标寻址\n00C03D06    51              push ecx\n00C03D07    68 A858C000     push TestCode.00C058A8                   ; ASCII \"%d\\n\"\n00C03D0C    FF15 1491C000   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00C03D12    83C4 08         add esp,0x8\n```\n\n以上就是数组的三种寻址方式，数组下标寻址的使用方案和指针寻址公式很相似，都是利用首地址加偏移量，数组寻址方案同样也可应用在指针寻址中。\n4.4数组下标越界\nC代码：\n对应反汇编Debug：\n\n```\n00F13CD8    C745 E8 0100000>mov dword ptr ss:[ebp-0x18],0x1\n00F13CDF    C745 EC 0200000>mov dword ptr ss:[ebp-0x14],0x2\n00F13CE6    C745 F0 0300000>mov dword ptr ss:[ebp-0x10],0x3\n00F13CED    C745 F4 0400000>mov dword ptr ss:[ebp-0xC],0x4 //数组初始化\n00F13CF4    C745 DC 0500000>mov dword ptr ss:[ebp-0x24],0x5 //局部变量初始化\n00F13CFB    B8 04000000     mov eax,0x4 \n00F13D00    6BC8 FF         imul ecx,eax,-0x1 //计算下标\n00F13D03    8BF4            mov esi,esp\n00F13D05    8B540D E8       mov edx,dword ptr ss:[ebp+ecx-0x18] //根据下标寻址，这里内存中的值为0xCCCCCCCC\n00F13D09    52              push edx\n00F13D0A    68 A858F100     push TestCode.00F158A8                   ; ASCII \"%d\\n\"\n00F13D0F    FF15 1491F100   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00F13D15    83C4 08         add esp,0x8\n```\n\nC/C++中并不会对数组的越界访问进行检查，所以在使用下标时要时刻注意不要越界访问内存中的其他数据，从而造成程序崩溃甚至更严重的后果。越界下标的使用和正常下标一样，这里不再赘述。\n\n## 多维数组\n\n多维数组其实在内存中也是线性存储的，在内存中排列相同，只是在程序中编译器将其做了相应的处理而已。多维数组的出现只是为了方便开发者计算偏移地址，寻址数组数据。\n二维数组的大小计算：一维数组使用类型大小乘以下标值，得到一维数组占用内存大小。二维数组中的二维下标值为一维数组个数，因此只要将二维下标值乘以一维数组占用内存大小，即可求得。\n\n二维数组偏移计算：\n例子：int nArr[2][3]可拆分为三部分\n数组首地址：nArr\n一维元素类型：int[3]，此下标值记作j\n类型：int\n元素个数：[3]\n一维元素个数：[2]，此下标值记作i\n此二维数组的组成可以理解为两个以为整型数组的集合，而这两个一维数组又各自拥有三个整型数据。在地址偏移的计算过程中，先计算出首地址到一维数组间的偏移量，利用数组首地址加上偏移量，得到某一个一维数组所在地址。以此地址作为基地址，加上一维数组中数据地址偏移，寻址到二维数组中某个数据。\n寻址公式：数组首地址 + sizeof(type[j]) 二维下标值 + sizeof(type) 一维下标值\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int i = 0;\n    int j = 0;\n    int nArr1[4] = { 1, 2, 3, 4 };\n    int nArr2[2][2] = { { 1, 2 }, { 3, 4 } };\n    scanf(\"%d %d\", &i, &j);\n    printf(\"nArr1 = %d\\n\", nArr1[i]);\n    printf(\"nArr2 = %d\\n\", nArr2[i][j]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00833CD8    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0  //\n00833CDF    C745 E8 0000000>mov dword ptr ss:[ebp-0x18],0x0 //局部变量初始化\n00833CE6    C745 D0 0100000>mov dword ptr ss:[ebp-0x30],0x1\n00833CED    C745 D4 0200000>mov dword ptr ss:[ebp-0x2C],0x2\n00833CF4    C745 D8 0300000>mov dword ptr ss:[ebp-0x28],0x3\n00833CFB    C745 DC 0400000>mov dword ptr ss:[ebp-0x24],0x4 //数组初始化\n00833D02    C745 B8 0100000>mov dword ptr ss:[ebp-0x48],0x1\n00833D09    C745 BC 0200000>mov dword ptr ss:[ebp-0x44],0x2\n00833D10    C745 C0 0300000>mov dword ptr ss:[ebp-0x40],0x3\n00833D17    C745 C4 0400000>mov dword ptr ss:[ebp-0x3C],0x4 //数组初始化\n00833D1E    8BF4            mov esi,esp\n00833D20    8D45 E8         lea eax,dword ptr ss:[ebp-0x18]\n00833D23    50              push eax\n00833D24    8D4D F4         lea ecx,dword ptr ss:[ebp-0xC]\n00833D27    51              push ecx\n00833D28    68 A8588300     push TestCode.008358A8                   ; ASCII \"%d %d\"\n00833D2D    FF15 3C918300   call dword ptr ds:[<&MSVCR120D.scanf>]   ; MSVCR120.scanf\n00833D33    83C4 0C         add esp,0xC\n00833D36    3BF4            cmp esi,esp\n00833D38    E8 9ED4FFFF     call TestCode.008311DB\n00833D3D    8BF4            mov esi,esp\n00833D3F    8B45 F4         mov eax,dword ptr ss:[ebp-0xC] //取i的值\n00833D42    8B4C85 D0       mov ecx,dword ptr ss:[ebp+eax*4-0x30] //根据下标寻址\n00833D46    51              push ecx\n00833D47    68 18598300     push TestCode.00835918                   ; ASCII \"nArr1 = %d\\n\"\n00833D4C    FF15 14918300   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00833D52    83C4 08         add esp,0x8\n00833D55    3BF4            cmp esi,esp\n00833D57    E8 7FD4FFFF     call TestCode.008311DB\n00833D5C    8B45 F4         mov eax,dword ptr ss:[ebp-0xC] //取i的值\n00833D5F    8D4CC5 B8       lea ecx,dword ptr ss:[ebp+eax*8-0x48]//8为每一个一维数组的大小，取第i个一维数组的首地址\n00833D63    8BF4            mov esi,esp\n00833D65    8B55 E8         mov edx,dword ptr ss:[ebp-0x18] //取j的值\n00833D68    8B0491          mov eax,dword ptr ds:[ecx+edx*4]//首地址+偏移进行寻址\n00833D6B    50              push eax\n00833D6C    68 E45A8300     push TestCode.00835AE4                   ; ASCII \"nArr2 = %d\\n\"\n00833D71    FF15 14918300   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00833D77    83C4 08         add esp,0x8\n```\n\n由此可看出一维数组和二维数组有着明显的区别，一维数组直接根据偏移量取出数组中的元素，二维数组则需要先计算第i个一维数组的首地址然后根据j偏移量来得到元素\n\n## 使用常量寻址的二维数组\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int i = 0;\n    \n    int nArr2[2][2] = { { 1, 2 }, { 3, 4 } };\n    scanf(\"%d\", &i);\n    printf(\"nArr2 = %d\\n\", nArr2[1][i]);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n000F3CD8    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0 //局部变量初始化\n000F3CDF    C745 DC 0100000>mov dword ptr ss:[ebp-0x24],0x1\n000F3CE6    C745 E0 0200000>mov dword ptr ss:[ebp-0x20],0x2\n000F3CED    C745 E4 0300000>mov dword ptr ss:[ebp-0x1C],0x3\n000F3CF4    C745 E8 0400000>mov dword ptr ss:[ebp-0x18],0x4 //数组初始化\n000F3CFB    8BF4            mov esi,esp\n000F3CFD    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n000F3D00    50              push eax\n000F3D01    68 A8580F00     push TestCode.000F58A8                   ; ASCII \"%d\"\n000F3D06    FF15 3C910F00   call dword ptr ds:[<&MSVCR120D.scanf>]   ; MSVCR120.scanf\n000F3D0C    83C4 08         add esp,0x8\n000F3D0F    3BF4            cmp esi,esp\n000F3D11    E8 C5D4FFFF     call TestCode.000F11DB\n000F3D16    B8 08000000     mov eax,0x8 //eax == 8\n000F3D1B    C1E0 00         shl eax,0x0 //左移0位，相当于乘以1\n000F3D1E    8D4C05 DC       lea ecx,dword ptr ss:[ebp+eax-0x24] //取一维数组的首地址\n000F3D22    8BF4            mov esi,esp\n000F3D24    8B55 F4         mov edx,dword ptr ss:[ebp-0xC] //取i的值\n000F3D27    8B0491          mov eax,dword ptr ds:[ecx+edx*4] //根据首地址+偏移寻址\n000F3D2A    50              push eax\n000F3D2B    68 18590F00     push TestCode.000F5918                   ; ASCII \"nArr2 = %d\\n\"\n000F3D30    FF15 14910F00   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n000F3D36    83C4 08         add esp,0x8\n对应反汇编Release：\n.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)\n.text:00401000 _main           proc near               ; CODE XREF: ___tmainCRTStartup+F8\n.text:00401000\n.text:00401000 var_18          = dword ptr -18h\n.text:00401000 var_14          = xmmword ptr -14h\n.text:00401000 var_4           = dword ptr -4\n.text:00401000 argc            = dword ptr  8\n.text:00401000 argv            = dword ptr  0Ch\n.text:00401000 envp            = dword ptr  10h\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 sub     esp, 18h\n.text:00401006                 mov     eax, ___security_cookie\n.text:0040100B                 xor     eax, ebp\n.text:0040100D                 mov     [ebp+var_4], eax\n.text:00401010                 movdqa  xmm0, ds:xmmword_402130\n.text:00401018                 lea     eax, [ebp+var_18]\n.text:0040101B                 paddd   xmm0, ds:xmmword_402110\n.text:00401023                 paddd   xmm0, ds:xmmword_402120\n.text:0040102B                 push    eax\n.text:0040102C                 push    offset Format   ; \"%d\"\n.text:00401031                 mov     [ebp+var_18], 0\n.text:00401038                 movdqu  [ebp+var_14], xmm0\n.text:0040103D                 call    ds:scanf\n.text:00401043                 mov     eax, [ebp+var_18]\n.text:00401046                 push    dword ptr [ebp+eax*4+var_14+8]\n.text:0040104A                 push    offset aNarr2D  ; \"nArr2 = %d\\n\"\n.text:0040104F                 call    ds:printf\n.text:00401055                 mov     ecx, [ebp+var_4]\n.text:00401058                 add     esp, 10h\n.text:0040105B                 xor     ecx, ebp\n.text:0040105D                 xor     eax, eax\n.text:0040105F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)\n.text:00401064                 mov     esp, ebp\n.text:00401066                 pop     ebp\n.text:00401067                 retn\n.text:00401067 _main           endp\n```\n\n这里编译器为2013，有一些变化。\n\n书上的说法\n1）使用数组首地址加二维数组下边i乘以一维数组大小，得到一维数组首地址\n2）通过第一步获取数组首地址后，加下标j乘以类型大小，得到数据如下\n二维数组type nArr[M][N]，使用i，j作为下标寻址\nnArr + i sizeof(type[N]) + j sizeof(type)= nArr + i N sizeof(type) + j sizeof(type) = nArr + sizeof(type) (i * N + j)\n转换后得到下标值，将二维数组的寻址过程转换为一维数组，节省一次寻址计算。\n\n三围数组下标值的转换过程也就是先把三围数组拆分为3个二维数组，然后套用二维数组下标值计算公式，得到二维数组下标值，然后乘以3得出三围数组的下标值。根据下标值的计算可以分析出数组维数，根据寻址公式中的类型长度可得出数组类型。\n\n## 指针数组\n\n存放指针类型数据的数组就是数组中各数据元素都是由相同类型的指针组成，称为指针数组。\n指针数组主要用于管理同种类型的指针，一般用于处理若干字符串（如二维字符数组）的操作。\n它和数组的区别就在于在取出数组中的元素之后还要进行一次间接寻址。\n\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char *pBuf[3] = { \"Hello\", \"World\", \"!!!\" };\n    for (int i = 0; i < 3; i++)\n    {\n        printf(pBuf[i]);\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00393CD5       8945 FC         mov dword ptr ss:[ebp-0x4],eax\n00393CD8       C745 EC A858390>mov dword ptr ss:[ebp-0x14],TestCode.003>; ASCII \"Hello\"\n00393CDF       C745 F0 1859390>mov dword ptr ss:[ebp-0x10],TestCode.003>; ASCII \"World\"\n00393CE6       C745 F4 B058390>mov dword ptr ss:[ebp-0xC],TestCode.0039>; ASCII \"!!!\" //字符串指针数组初始化\n00393CED       C745 E0 0000000>mov dword ptr ss:[ebp-0x20],0x0\n00393CF4       EB 09           jmp short TestCode.00393CFF\n00393CF6       8B45 E0         mov eax,dword ptr ss:[ebp-0x20]\n00393CF9       83C0 01         add eax,0x1\n00393CFC       8945 E0         mov dword ptr ss:[ebp-0x20],eax\n00393CFF       837D E0 03      cmp dword ptr ss:[ebp-0x20],0x3\n00393D03       7D 1C           jge short TestCode.00393D21\n00393D05       8BF4            mov esi,esp\n00393D07       8B45 E0         mov eax,dword ptr ss:[ebp-0x20]//把当前i的值给eax\n00393D0A       8B4C85 EC       mov ecx,dword ptr ss:[ebp+eax*4-0x14]//根据下标寻址\n00393D0E       51              push ecx\n00393D0F       FF15 14913900   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n00393D15       83C4 04         add esp,0x4\n```\n\n指针数组和二维字符数组有着很明显的区别，若是在初始化阶段，二维字符数组是将每个字符数据赋值，而指针数组仅仅是将字符串的首地址存入数组中。\n二维字符数组初始化\n\n```\n00873CD8       C745 80 A858870>mov dword ptr ss:[ebp-0x80],TestCode.008>; ASCII \"Hello\"\n00873CDF       33C0            xor eax,eax\n00873CE1       8945 84         mov dword ptr ss:[ebp-0x7C],eax\n00873CE4       8945 88         mov dword ptr ss:[ebp-0x78],eax\n00873CE7       8945 8C         mov dword ptr ss:[ebp-0x74],eax\n00873CEA       8945 90         mov dword ptr ss:[ebp-0x70],eax\n00873CED       8945 94         mov dword ptr ss:[ebp-0x6C],eax\n00873CF0       8945 98         mov dword ptr ss:[ebp-0x68],eax\n00873CF3       8945 9C         mov dword ptr ss:[ebp-0x64],eax\n00873CF6       8945 A0         mov dword ptr ss:[ebp-0x60],eax\n00873CF9       8945 A4         mov dword ptr ss:[ebp-0x5C],eax\n00873CFC       C745 A8 1859870>mov dword ptr ss:[ebp-0x58],TestCode.008>; ASCII \"World\"\n00873D03       33C0            xor eax,eax\n00873D05       8945 AC         mov dword ptr ss:[ebp-0x54],eax\n00873D08       8945 B0         mov dword ptr ss:[ebp-0x50],eax\n00873D0B       8945 B4         mov dword ptr ss:[ebp-0x4C],eax\n00873D0E       8945 B8         mov dword ptr ss:[ebp-0x48],eax\n00873D11       8945 BC         mov dword ptr ss:[ebp-0x44],eax\n00873D14       8945 C0         mov dword ptr ss:[ebp-0x40],eax\n00873D17       8945 C4         mov dword ptr ss:[ebp-0x3C],eax\n00873D1A       8945 C8         mov dword ptr ss:[ebp-0x38],eax\n00873D1D       8945 CC         mov dword ptr ss:[ebp-0x34],eax\n00873D20       C745 D0 B058870>mov dword ptr ss:[ebp-0x30],TestCode.008>; ASCII \"!!!\"\n00873D27       33C0            xor eax,eax\n00873D29       8945 D4         mov dword ptr ss:[ebp-0x2C],eax\n00873D2C       8945 D8         mov dword ptr ss:[ebp-0x28],eax\n00873D2F       8945 DC         mov dword ptr ss:[ebp-0x24],eax\n00873D32       8945 E0         mov dword ptr ss:[ebp-0x20],eax\n00873D35       8945 E4         mov dword ptr ss:[ebp-0x1C],eax\n00873D38       8945 E8         mov dword ptr ss:[ebp-0x18],eax\n00873D3B       8945 EC         mov dword ptr ss:[ebp-0x14],eax\n00873D3E       8945 F0         mov dword ptr ss:[ebp-0x10],eax\n00873D41       8945 F4         mov dword ptr ss:[ebp-0xC],eax\n00873D44       C785 74FFFFFF 0>mov dword ptr ss:[ebp-0x8C],0x0\n```\n\n## 指向数组的指针变量\n\n当指针变量保存的数据为数组的首地址，且将此地址解释为数组时，此指针变量被称为数组指针。\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char Buf[3][10] = { { \"Hello\" }, { \"World\" }, { \"!!!\" } };\n    char(*pBuf)[10] = Buf;\n    for (int i = 0; i < 3; i++)\n    {\n        printf(*pBuf);\n        pBuf++;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n01293CD5       8945 FC         mov dword ptr ss:[ebp-0x4],eax\n01293CD8       A1 A8582901     mov eax,dword ptr ds:[0x12958A8]\n01293CDD       8945 D8         mov dword ptr ss:[ebp-0x28],eax\n01293CE0       66:8B0D AC58290>mov cx,word ptr ds:[0x12958AC]\n01293CE7       66:894D DC      mov word ptr ss:[ebp-0x24],cx\n01293CEB       33C0            xor eax,eax\n01293CED       8945 DE         mov dword ptr ss:[ebp-0x22],eax\n01293CF0       A1 18592901     mov eax,dword ptr ds:[0x1295918]\n01293CF5       8945 E2         mov dword ptr ss:[ebp-0x1E],eax\n01293CF8       66:8B0D 1C59290>mov cx,word ptr ds:[0x129591C]\n01293CFF       66:894D E6      mov word ptr ss:[ebp-0x1A],cx\n01293D03       33C0            xor eax,eax\n01293D05       8945 E8         mov dword ptr ss:[ebp-0x18],eax\n01293D08       A1 B0582901     mov eax,dword ptr ds:[0x12958B0]\n01293D0D       8945 EC         mov dword ptr ss:[ebp-0x14],eax //以上都是二维字符数组初始化操作\n01293D10       33C0            xor eax,eax\n01293D12       8945 F0         mov dword ptr ss:[ebp-0x10],eax\n01293D15       66:8945 F4      mov word ptr ss:[ebp-0xC],ax\n01293D19       8D45 D8         lea eax,dword ptr ss:[ebp-0x28] //取数组首地址\n01293D1C       8945 CC         mov dword ptr ss:[ebp-0x34],eax //把首地址给ebp-0x34\n01293D1F       C745 C0 0000000>mov dword ptr ss:[ebp-0x40],0x0 //初始化变量i\n01293D26       EB 09           jmp short TestCode.01293D31\n01293D28       8B45 C0         mov eax,dword ptr ss:[ebp-0x40]\n01293D2B       83C0 01         add eax,0x1\n01293D2E       8945 C0         mov dword ptr ss:[ebp-0x40],eax\n01293D31       837D C0 03      cmp dword ptr ss:[ebp-0x40],0x3\n01293D35       7D 21           jge short TestCode.01293D58\n01293D37       8BF4            mov esi,esp\n01293D39       8B45 CC         mov eax,dword ptr ss:[ebp-0x34] //字符串首地址给eax\n01293D3C       50              push eax\n01293D3D       FF15 14912901   call dword ptr ds:[<&MSVCR120D.printf>]  ; MSVCR120.printf\n01293D43       83C4 04         add esp,0x4\n01293D46       3BF4            cmp esi,esp\n01293D48       E8 8ED4FFFF     call TestCode.012911DB\n01293D4D       8B45 CC         mov eax,dword ptr ss:[ebp-0x34] //首地址给eax\n01293D50       83C0 0A         add eax,0xA //eax += 0xa，因为pBuf的指针类型是长度为10的字符数组\n01293D53       8945 CC         mov dword ptr ss:[ebp-0x34],eax\n```\n\n指针加法公式：指针变量+=数值 <–>指针变量地址数据 += （sizeof（指针类型）+ 数值）\n\n## 函数指针\n\n用于保存函数首地址的指针变量被称为函数指针。\n定义：返回值类型（调用约定 *函数指针变量名称）（参数信息）\n\n### 无参函数指针\n\nC代码：\n\n```c\nvoid __cdecl Show()\n{\n    printf(\"Show\\n\");\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    void(__cdecl *pFun)() = Show;\n    pFun();\n    Show();\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00401790 Tes>  55              push ebp\n00401791       8BEC            mov ebp,esp\n00401793       81EC CC000000   sub esp,0xCC\n00401799       53              push ebx\n0040179A       56              push esi\n0040179B       57              push edi\n0040179C       8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n004017A2       B9 33000000     mov ecx,0x33\n004017A7       B8 CCCCCCCC     mov eax,0xCCCCCCCC\n004017AC       F3:AB           rep stos dword ptr es:[edi]\n004017AE       C745 F8 5812400>mov dword ptr ss:[ebp-0x8],TestCode.00401258 //初始化函数指针，函数名就为函数首地址\n004017B5       8BF4            mov esi,esp\n004017B7       FF55 F8         call dword ptr ss:[ebp-0x8] //间接调用函数\n004017BA       3BF4            cmp esi,esp\n004017BC       E8 1AFAFFFF     call TestCode.004011DB \n004017C1       E8 92FAFFFF     call TestCode.00401258 //直接调用函数\n004017C6       33C0            xor eax,eax\n004017C8       5F              pop edi\n004017C9       5E              pop esi\n004017CA       5B              pop ebx\n004017CB       81C4 CC000000   add esp,0xCC\n004017D1       3BEC            cmp ebp,esp\n004017D3       E8 03FAFFFF     call TestCode.004011DB\n004017D8       8BE5            mov esp,ebp\n004017DA       5D              pop ebp\n004017DB       C3              retn\n```\n\n### 带参函数指针\n\nC代码：\n\n```c\nint __stdcall Show(int n)\n{\n    printf(\"Show:%d\\n\",n);\n    return n;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int(__stdcall *pFun)(int) = Show;\n    pFun(1);\n    Show(1);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n010B17AE       C745 F8 5D120B0>mov dword ptr ss:[ebp-0x8],TestCode.010B125D //初始化函数指针\n010B17B5       8BF4            mov esi,esp\n010B17B7       6A 01           push 0x1 //压入参数\n010B17B9       FF55 F8         call dword ptr ss:[ebp-0x8] //间接调用\n010B17BC       3BF4            cmp esi,esp\n010B17BE       E8 18FAFFFF     call TestCode.010B11DB\n010B17C3       6A 01           push 0x1\n010B17C5       E8 93FAFFFF     call TestCode.010B125D\n```","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(四)","url":"/2016/11/23/逆向笔记-四/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之变量在内存中位置。\n\n变量的作用域：是指变量在源码中可以被访问到的范围。全局变量属于进程作用域，也就是说在整个进程中都可以访问到这个全局变量；静态变量属于文件作用域，在当前源码文件内可以访问到；局部变量属于函数作用域，在函数内可以访问到；在“{}”语句块内定义的变量，属于块作用域，只能在定义变量的“{}”块内访问到。\n变量的生命周期：是指变量所在的内存从分配到释放的这段时间。\n\n## 全局变量和局部变量的区别\n\n具有初始值的全局变量在源代码链接时就被写入所创建的PE文件，当该文件被执行时操作系统分析各个节中的数据填入对应的内存地址中，这时全局变量就已经存在了，等PE文件的分析和加载工作完成之后才执行入口点的代码。所以全局变量不受作用域的影响，程序的任何位置都可以访问。下面就来具体讲述不同点。\n全局变量和常量类似都是被写入文件中，因此生命周期和模块相同，而其与局部变量最大的不同之处便是生命周期。按照上面所说，全局变量在执行第一条代码前便存在，知道程序退出销毁，而局部变量的生命周期则仅限于函数作用域内，超出作用域便会由栈平衡操作来释放其空间。在访问方式上，局部变量是通过栈指针来访问的，但是全部变量不在栈中，就无法用栈指针访问。\n\nC代码：\n\n```c\nint g_Var = 1234567;\nint _tmain(int argc, _TCHAR* argv[])\n{\n    scanf_s(\"%d\",&g_Var);\n    printf(\"%d\\n\", g_Var);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n012D3CB0 >  55              push ebp\n012D3CB1    8BEC            mov ebp,esp\n012D3CB3    81EC C0000000   sub esp,0xC0\n012D3CB9    53              push ebx\n012D3CBA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n012D3CBB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n012D3CBC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n012D3CC2    B9 30000000     mov ecx,0x30\n012D3CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n012D3CCC    F3:AB           rep stos dword ptr es:[edi]\n012D3CCE    8BF4            mov esi,esp\n012D3CD0    68 28802D01     push offset TestCode.g_Var //将全局变量压入堆栈\n012D3CD5    68 A8582D01     push offset TestCode.??_C@_02DPKJAMEF@?$>\n012D3CDA    FF15 18912D01   call dword ptr ds:[<&MSVCR120D.scanf_s>] ; msvcr120.scanf_s\n012D3CE0    83C4 08         add esp,0x8\n012D3CE3    3BF4            cmp esi,esp\n012D3CE5    E8 F1D4FFFF     call TestCode.012D11DB\n012D3CEA    8BF4            mov esi,esp\n012D3CEC    A1 28802D01     mov eax,dword ptr ds:[g_Var] //取全局变量的内容给eax\n012D3CF1    50              push eax\n012D3CF2    68 E45A2D01     push offset TestCode.??_C@_03PMGGPEJJ@?$>; ASCII \"%d\\n\"\n012D3CF7    FF15 14912D01   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n012D3CFD    83C4 08         add esp,0x8 //平衡堆栈\n012D3D00    3BF4            cmp esi,esp\n012D3D02    E8 D4D4FFFF     call TestCode.012D11DB\n012D3D07    33C0            xor eax,eax\n012D3D09    5F              pop edi                                  ; kernel32.756A38F4\n012D3D0A    5E              pop esi                                  ; kernel32.756A38F4\n012D3D0B    5B              pop ebx                                  ; kernel32.756A38F4\n```\n\n由此可以很清楚的看到全局变量是用直接寻址来访问的，这是因为全局变量存储在文件中，加载至内存时也会随着文件加载到内存的固定偏移位置，所以编译器可以决定其用直接寻址找到它。而局部变量是存储在栈中的，无法确定其地址，故无法使用直接寻址方式，应采用相对寻址。\n\n再看看多个全局变量的情况\n\nC代码：\n\n```c\nint g_Var1 = 1234567;\nint g_Var2 = 7654321;\nint _tmain(int argc, _TCHAR* argv[])\n{\n    scanf_s(\"%d %d\",&g_Var1,&g_Var2);\n    printf(\"%d %d\\n\", g_Var1,g_Var2);\n    int n1 = 1, n2 = 2;\n    scanf_s(\"%d %d\", &n1, &n2);\n    printf(\"%d %d\\n\", n1, n2);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n012C3CB0 >  55              push ebp\n012C3CB1    8BEC            mov ebp,esp\n012C3CB3    81EC DC000000   sub esp,0xDC\n012C3CB9    53              push ebx\n012C3CBA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n012C3CBB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n012C3CBC    8DBD 24FFFFFF   lea edi,dword ptr ss:[ebp-0xDC]\n012C3CC2    B9 37000000     mov ecx,0x37\n012C3CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n012C3CCC    F3:AB           rep stos dword ptr es:[edi]\n012C3CCE    A1 0C802C01     mov eax,dword ptr ds:[__security_cookied>\n012C3CD3    33C5            xor eax,ebp\n012C3CD5    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n012C3CD8    8BF4            mov esi,esp\n012C3CDA    68 2C802C01     push offset TestCode.g_Var2amerReportFun> //全局变量2压入堆栈，push 0x12C802C\n012C3CDF    68 28802C01     push offset TestCode.g_Var1deorReportFun> //全局变量1压入堆栈，push 0x12C8028\n012C3CE4    68 A8582C01     push offset TestCode.??_C@_05OKMLJOMC@?$>; ASCII 25,\"d %d\"\n012C3CE9    FF15 18912C01   call dword ptr ds:[<&MSVCR120D.scanf_s>] ;  //调用msvcr120.scanf_s\n012C3CEF    83C4 0C         add esp,0xC //堆栈平衡\n012C3CF2    3BF4            cmp esi,esp\n012C3CF4    E8 E2D4FFFF     call TestCode.012C11DB\n012C3CF9    8BF4            mov esi,esp\n012C3CFB    A1 2C802C01     mov eax,dword ptr ds:[g_Var2amerReportFu> //全局变量2给eax\n012C3D00    50              push eax\n012C3D01    8B0D 28802C01   mov ecx,dword ptr ds:[g_Var1deorReportFu> //全局变量1给ecx\n012C3D07    51              push ecx                                 ; TestCode.<ModuleEntryPoint>\n012C3D08    68 E45A2C01     push offset TestCode.??_C@_06IPGPIAII@?$>; ASCII \"%d %d\\n\"\n012C3D0D    FF15 14912C01   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n012C3D13    83C4 0C         add esp,0xC\n012C3D16    3BF4            cmp esi,esp\n012C3D18    E8 BED4FFFF     call TestCode.012C11DB\n012C3D1D    C745 F4 0100000>mov dword ptr ss:[ebp-0xC],0x1 //初始化局部变量1\n012C3D24    C745 E8 0200000>mov dword ptr ss:[ebp-0x18],0x2 //初始化局部变量2\n012C3D2B    8BF4            mov esi,esp\n012C3D2D    8D45 E8         lea eax,dword ptr ss:[ebp-0x18] //取地址\n012C3D30    50              push eax\n012C3D31    8D4D F4         lea ecx,dword ptr ss:[ebp-0xC] //取地址\n012C3D34    51              push ecx                                 ; TestCode.<ModuleEntryPoint>\n012C3D35    68 A8582C01     push offset TestCode.??_C@_05OKMLJOMC@?$>; ASCII 25,\"d %d\"\n012C3D3A    FF15 18912C01   call dword ptr ds:[<&MSVCR120D.scanf_s>] ; //调用msvcr120.scanf_s\n012C3D40    83C4 0C         add esp,0xC\n012C3D43    3BF4            cmp esi,esp\n012C3D45    E8 91D4FFFF     call TestCode.012C11DB\n012C3D4A    8BF4            mov esi,esp\n012C3D4C    8B45 E8         mov eax,dword ptr ss:[ebp-0x18] //取局部变量2的内容给eax\n012C3D4F    50              push eax\n012C3D50    8B4D F4         mov ecx,dword ptr ss:[ebp-0xC] //取局部变量1的内容给ecx\n012C3D53    51              push ecx                                 ; TestCode.<ModuleEntryPoint>\n012C3D54    68 E45A2C01     push offset TestCode.??_C@_06IPGPIAII@?$>; ASCII \"%d %d\\n\"\n012C3D59    FF15 14912C01   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n012C3D5F    83C4 0C         add esp,0xC\n012C3D62    3BF4            cmp esi,esp\n012C3D64    E8 72D4FFFF     call TestCode.012C11DB\n012C3D69    33C0            xor eax,eax\n012C3D6B    52              push edx                                 ; TestCode.<ModuleEntryPoint>\n012C3D6C    8BCD            mov ecx,ebp\n012C3D6E    50              push eax\n012C3D6F    8D15 9C3D2C01   lea edx,dword ptr ds:[0x12C3D9C]\n012C3D75    E8 52D4FFFF     call TestCode.012C11CC\n012C3D7A    58              pop eax                                  ; kernel32.756A38F4\n012C3D7B    5A              pop edx                                  ; kernel32.756A38F4\n012C3D7C    5F              pop edi                                  ; kernel32.756A38F4\n012C3D7D    5E              pop esi                                  ; kernel32.756A38F4\n012C3D7E    5B              pop ebx                                  ; kernel32.756A38F4\n```\n\n由此可以看出全局变量在内存中的地址顺序是先定义的变量在低地址，后定义的变量在高地址。由此特性可以根据反汇编代码中全局变量所在的地址，还原出高级代码中被定义的先后顺序。\n全局变量的特征：\n1）所在的地址为数据区，生命周期与所在模块一致\n2）使用立即数间接访问（这里我认为是直接寻址一样，好像也没有什么区别）\n局部变量的特征：\n1）所在的地址为栈区，生命周期与所在的函数作用域一致\n2）使用ebp或者esp间接访问\n\n## 局部静态变量\n\n静态变量分为全局静态变量和局部静态变量，全局静态变量与全局变量类似，只是全局静态变量只能在本文件内使用。全局静态变量的访问及生命周期也和全局变量相同。反汇编代码中也无二样，因此这里不做介绍。\n局部静态变量的生命周期和全局变量相同，并且都是在编译链接时就写入文件之中，但是其作用域确是和局部变量相同。事实上，局部静态变量刚开始是作为全局变量处理，而它的初始化仅仅是对它进行赋值操作。\n\n\nC代码：\n\n```c\nvoid ShowStatic(int nNum)\n{\n    static int g_nNum = nNum;\n    printf(\"%d\\n\", g_nNum);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    for (int i = 0; i < 5;i++)\n    {\n        ShowStatic(i);\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n00121790 >  55              push ebp\n00121791    8BEC            mov ebp,esp\n00121793    81EC CC000000   sub esp,0xCC\n00121799    53              push ebx\n0012179A    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n0012179B    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n0012179C    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n001217A2    B9 33000000     mov ecx,0x33\n001217A7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n001217AC    F3:AB           rep stos dword ptr es:[edi]\n001217AE    C745 F8 0000000>mov dword ptr ss:[ebp-0x8],0x0\n001217B5    EB 09           jmp short TestCode.001217C0\n001217B7    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n001217BA    83C0 01         add eax,0x1\n001217BD    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n001217C0    837D F8 05      cmp dword ptr ss:[ebp-0x8],0x5\n001217C4    7D 0E           jge short TestCode.001217D4\n001217C6    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n001217C9    50              push eax\n001217CA    E8 48FAFFFF     call TestCode.00121217\n001217CF    83C4 04         add esp,0x4\n001217D2  ^ EB E3           jmp short TestCode.001217B7\n001217D4    33C0            xor eax,eax\n001217D6    5F              pop edi                                  ; kernel32.756A38F4\n001217D7    5E              pop esi                                  ; kernel32.756A38F4\n001217D8    5B              pop ebx                                  ; kernel32.756A38F4\n001217D9    81C4 CC000000   add esp,0xCC\nShowStatic函数\n00123CB0 >  55              push ebp\n00123CB1    8BEC            mov ebp,esp\n00123CB3    81EC C0000000   sub esp,0xC0\n00123CB9    53              push ebx\n00123CBA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n00123CBB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n00123CBC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n00123CC2    B9 30000000     mov ecx,0x30\n00123CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00123CCC    F3:AB           rep stos dword ptr es:[edi]\n00123CCE    A1 5C811200     mov eax,dword ptr ds:[0x12815C] //0x12815C这里为标志位\n00123CD3    83E0 01         and eax,0x1 //进行与运算判断标志中的第一位是否为1，为1则表示初始化\n00123CD6    75 15           jnz short TestCode.00123CED\n00123CD8    A1 5C811200     mov eax,dword ptr ds:[0x12815C]\n00123CDD    83C8 01         or eax,0x1 //进行或运算若标志位不为1则置1\n00123CE0    A3 5C811200     mov dword ptr ds:[0x12815C],eax //把标志位写回\n00123CE5    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00123CE8    A3 58811200     mov dword ptr ds:[g_nNumterListeningRIPT>,eax //初始化\n00123CED    8BF4            mov esi,esp\n00123CEF    A1 58811200     mov eax,dword ptr ds:[g_nNumterListening>\n00123CF4    50              push eax\n00123CF5    68 A8581200     push offset TestCode.??_C@_03PMGGPEJJ@?$>; ASCII 25,\"d\\n\"\n00123CFA    FF15 14911200   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n00123D00    83C4 08         add esp,0x8 //堆栈平衡\n00123D03    3BF4            cmp esi,esp\n00123D05    E8 D1D4FFFF     call TestCode.001211DB\n00123D0A    5F              pop edi                                  ; kernel32.756A38F4\n00123D0B    5E              pop esi                                  ; kernel32.756A38F4\n00123D0C    5B              pop ebx                                  ; kernel32.756A38F4\n00123D0D    81C4 C0000000   add esp,0xC0 //堆栈平衡\n00123D13    3BEC            cmp ebp,esp\n00123D15    E8 C1D4FFFF     call TestCode.001211DB\n00123D1A    8BE5            mov esp,ebp\n00123D1C    5D              pop ebp                                  ; kernel32.756A38F4\n00123D1D    C3              retn\n```\n\n多个局部静态变量对应反汇编Debug：\n\n```\n00273CB0 >  55              push ebp\n00273CB1    8BEC            mov ebp,esp\n00273CB3    81EC C0000000   sub esp,0xC0\n00273CB9    53              push ebx\n00273CBA    56              push esi                                                            ; TestCode.<ModuleEntryPoint>\n00273CBB    57              push edi\n00273CBC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n00273CC2    B9 30000000     mov ecx,0x30\n00273CC7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00273CCC    F3:AB           rep stos dword ptr es:[edi]\n00273CCE    A1 AC842700     mov eax,dword ptr ds:[0x2784AC]\n00273CD3    83E0 01         and eax,0x1//进行与运算判断标志中的第一位是否为1，为1则表示初始化\n00273CD6    75 15           jnz short TestCode.00273CED\n00273CD8    A1 AC842700     mov eax,dword ptr ds:[0x2784AC]\n00273CDD    83C8 01         or eax,0x1//进行或运算若标志位不为1则置1\n00273CE0    A3 AC842700     mov dword ptr ds:[0x2784AC],eax\n00273CE5    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00273CE8    A3 A8842700     mov dword ptr ds:[g_nNum2erListeningRIPTORW@12y?$AA@?5being?5used?5>\n00273CED    A1 AC842700     mov eax,dword ptr ds:[0x2784AC]\n00273CF2    83E0 02         and eax,0x2//进行与运算判断标志中的第二位是否为1，为1则表示初始化\n00273CF5    75 15           jnz short TestCode.00273D0C\n00273CF7    A1 AC842700     mov eax,dword ptr ds:[0x2784AC]\n00273CFC    83C8 02         or eax,0x2 //进行或运算若标志位不为1则置1\n00273CFF    A3 AC842700     mov dword ptr ds:[0x2784AC],eax\n00273D04    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00273D07    A3 B0842700     mov dword ptr ds:[g_nNum2erListeningRIPTORW@12y?$AA@?5being?5used?5>\n00273D0C    8BF4            mov esi,esp\n00273D0E    A1 A8842700     mov eax,dword ptr ds:[g_nNum2erListeningRIPTORW@12y?$AA@?5being?5us>\n00273D13    50              push eax\n00273D14    68 A8582700     push offset TestCode.??_C@_03PMGGPEJJ@?$CFd?6?$AA@s?$AA?$AA@?$CFld?>; ASCII 25,\"d\\n\"\n00273D19    FF15 14912700   call dword ptr ds:[<&MSVCR120D.printf>]                             ; msvcr120.printf\n00273D1F    83C4 08         add esp,0x8\n00273D22    3BF4            cmp esi,esp\n00273D24    E8 B2D4FFFF     call TestCode.002711DB\n00273D29    8BF4            mov esi,esp\n00273D2B    A1 B0842700     mov eax,dword ptr ds:[g_nNum2erListeningRIPTORW@12y?$AA@?5being?5us>\n00273D30    50              push eax\n00273D31    68 A8582700     push offset TestCode.??_C@_03PMGGPEJJ@?$CFd?6?$AA@s?$AA?$AA@?$CFld?>; ASCII 25,\"d\\n\"\n00273D36    FF15 14912700   call dword ptr ds:[<&MSVCR120D.printf>]                             ; msvcr120.printf\n00273D3C    83C4 08         add esp,0x8\n00273D3F    3BF4            cmp esi,esp\n00273D41    E8 95D4FFFF     call TestCode.002711DB\n00273D46    5F              pop edi                                                             ; 0018F8BC\n00273D47    5E              pop esi                                                             ; 0018F8BC\n00273D48    5B              pop ebx                                                             ; 0018F8BC\n00273D49    81C4 C0000000   add esp,0xC0\n00273D4F    3BEC            cmp ebp,esp\n00273D51    E8 85D4FFFF     call TestCode.002711DB\n00273D56    8BE5            mov esp,ebp\n00273D58    5D              pop ebp                                                             ; 0018F8BC\n00273D59    C3              retn\n```\n\n这里两个变量都初始化完成后标志位为3，也就是0x00000011，表示前两个静态局部变量均已被初始化。\n002784AC 03 00 00 00 \n\n为了区分全局变量和局部静态变量，这里采用了一个标志，这个标志占一个字节。通过位运算，将标志位中的一位数据置1，以此判断局部静态变量是否已经初始化。由于一个静态变量只使用一位，而一个字节占八位，因此这个标志可以同时表示8个局部静态变量的初始化状态。如果变量超过了8个，那么再定义一个标志字节，这个字节一般在第9个变量的附近。\n\n当局部静态变量被初始化一个常量时，这个局部变量在初始化过程中不会产生任何代码。\n\n由于初始化的数值为常量，即多次初始化不会产生变化。这样无需初始化标志，编译器才用了直接以全局变量方式处理。虽然转换为了全局变量，但仍然不可以超出作用域访问。编译器通过名称粉碎，在编译期间将静态变量重新命名。通过名称粉碎后，在原有名称中加入了所在作用域，以及类型等信息。\n\n总结：\nReg_flag 表示存放初始化标志的寄存器\nInit_flag 表示初始化标志\nMov Reg_flag,Init_flag\nReg_data 表示存放静态变量初值的寄存器\nMov Reg_data,mem\nAnd Reg_flag,1\nJxx Init_End\nOr Reg_flag,1\nMov Init_flag,Reg_flag\nStatic_Data 表示静态变量\nMov Static_Data,Reg_data\nInit_End\n注意：在分析过程中应注意对测试标志的操作，其立即数只能为1，2，8这样的2的幂。\n\n## 堆变量\n\n堆变量应该是最简单的了。C/C++中使用malloc/free或new/delete来分配和释放堆空间。在申请空间时会返回堆空间的首地址，若堆空间没有得到及时地释放，则会造成内存泄漏。只要在程序的反汇编代码中发现有如下特点的代码，那么就很容易识别出堆变量。\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    char *pMalloc = (char*)malloc(10);\n    char *pNew = new char[10];\n    free(pMalloc);\n    delete[] pNew;\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n\n了解了堆变量的申请及销毁，再来看看编译器是如何管理堆空间的。堆结构的每一次分配形成一个结点，每个节点都是使用双向链表存储的，结点的数据结构如下定义：\n\n```c\ntypedef struct _CrtMemBlockHeader\n{\n        struct_CrtMemBlockHeader * pBlockHeaderNext; //下一块堆空间首地址\n        struct_CrtMemBlockHeader * pBlockHeaderPrev; //上一块堆空间首地址\n        char*                      szFileName;\n        int                         nLine;\n#ifdef _WIN64\n        /* Theseitems are reversed on Win64 to eliminate gaps in the struct\n         * and ensure that sizeof(struct)%16 ==0, so 16-byte alignment is\n         * maintained in the debug heap.\n         */\n        int                         nBlockUse;\n        size_t                      nDataSize;\n#else  /* _WIN64 */\n        size_t                      nDataSize;//堆空间的数据大小\n        int                         nBlockUse;\n#endif  /* _WIN64 */\n        long                        lRequest;//堆空间的申请次数\n        unsignedchar               gap[nNoMansLandSize];//堆空间数据，第一个数据的指针就是//申请的变量的指针\n        /* followedby:\n         * unsigned char          data[nDataSize];\n         * unsigned char          anotherGap[nNoMansLandSize];\n         */\n}_CrtMemBlockHeader;\n```\n\n0xadefc0处为分配的数据。这段空间的前后都有0xfdfdfdfd数据，这是在Debug版本下的越界检查标志。往前八个字节是0x00000080表示的是堆的申请次数，0xadefb处的数据是堆空间的大小，这里是10所以为0x0a，0xadefa0为上一个的堆空间首地址，后面四字节为0表示没有下一个堆空间。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(三)","url":"/2016/11/22/逆向笔记-三/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之函数的工作原理。\n\n## 栈\n\n先来说说栈，栈是内存中一块特殊的区域，遵循先进后出的原则。栈结构在内存中占用一段连续的存储空间，通过esp和ebp这两个栈指针寄存器来保存当前栈的起始地址和结束地址（也称为栈顶和栈底）。在栈中，没4个字节的栈空间保存一个数据，像这样栈顶到栈底之间的存储空间被称为栈帧。\n栈帧的形成：当栈顶指针esp小于栈底指针ebp时，就形成了栈帧。通常在VC++中，栈帧可以寻址的数据有局部变量，函数返回地址，函数参数等。\n栈平衡：不同的两次函数调用，所形成的栈帧也不相同，当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需的栈空间，形成此函数的栈帧，当这个函数结束调用时，需要清除掉它所使用的栈空间，关闭栈帧，这一过程称为栈平衡。\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    //这是一个空函数\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00101790 >  55              push ebp //保存栈底指针ebp\n00101791    8BEC            mov ebp,esp //调整当前栈底指针位置到栈顶\n00101793    81EC C0000000   sub esp,0xC0 //抬高栈底esp，开辟0xc0空间，作为局部变量存储空间\n00101799    53              push ebx    //保存寄存器\n0010179A    56              push esi //保存寄存器                                ; TestCode.<ModuleEntryPoint>\n0010179B    57              push edi//保存寄存器                                 ; TestCode.<ModuleEntryPoint>\n0010179C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]//取出函数可用栈空间首地址\n001017A2    B9 30000000     mov ecx,0x30    //ecx赋值\n001017A7    B8 CCCCCCCC     mov eax,0xCCCCCCCC //初始化eax为0xcccccccc\n001017AC    F3:AB           rep stos dword ptr es:[edi] 根据ecx的值,向edi写入eax数据\n001017AE    33C0            xor eax,eax //清零eax\n001017B0    5F              pop edi                                  ; kernel32.762D38F4\n001017B1    5E              pop esi                                  ; kernel32.762D38F4\n001017B2    5B              pop ebx                                  ; kernel32.762D38F4\n001017B3    8BE5            mov esp,ebp //还原esp\n001017B5    5D              pop ebp                                  ; kernel32.762D38F4\n001017B6    C3              retn\n```\n\nVC++下有三种函数调用方式，分别是：cdecl 、 stdcall 、fastcal。第一种是C/C++默认的函数调用方式，如果不特殊指明用那种方式则默认使用cdecl，而且只有第一种可以在不定参数的函数下使用，后面的方式指明所使用的函数必须是确定参数的，包括参数的个数和类型。\n\n## _cdecl与_stdcall两种调用的区别：\n\nC代码：\n\n```c\n//stdcall调用方式，被调方平衡栈\nvoid _stdcall ShowStd(int nNumber)\n{\n    printf(\"%d\\n\", nNumber);\n}\n//cdecl调用方式，调用方平衡栈\nvoid _cdecl ShowCde(int nNumber)\n{\n    printf(\"%d\\n\", nNumber);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    ShowStd(1);\n    ShowCde(1);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n013E33F0 >  55              push ebp\n013E33F1    8BEC            mov ebp,esp\n013E33F3    81EC C0000000   sub esp,0xC0\n013E33F9    53              push ebx\n013E33FA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n013E33FB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n013E33FC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n013E3402    B9 30000000     mov ecx,0x30\n013E3407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n013E340C    F3:AB           rep stos dword ptr es:[edi]\n013E340E    6A 01           push 0x1\n013E3410    E8 DADDFFFF     call TestCode.013E11EF //_stdcall\n013E3415    6A 01           push 0x1\n013E3417    E8 D8DDFFFF     call TestCode.013E11F4 //_ceecl\n013E341C    83C4 04         add esp,0x4 //esp += 4。平衡栈顶\n013E341F    33C0            xor eax,eax\n013E3421    5F              pop edi                                  ; kernel32.762D38F4\n013E3422    5E              pop esi                                  ; kernel32.762D38F4\n013E3423    5B              pop ebx                                  ; kernel32.762D38F4\n013E3424    81C4 C0000000   add esp,0xC0\n013E342A    3BEC            cmp ebp,esp\n013E342C    E8 AADDFFFF     call TestCode.013E11DB\n013E3431    8BE5            mov esp,ebp\n013E3433    5D              pop ebp                                  ; kernel32.762D38F4\n013E3434    C3              retn\nShowStd函数\n013E2FA0 >  55              push ebp\n013E2FA1    8BEC            mov ebp,esp\n013E2FA3    81EC C0000000   sub esp,0xC0\n013E2FA9    53              push ebx\n013E2FAA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n013E2FAB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n013E2FAC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n013E2FB2    B9 30000000     mov ecx,0x30\n013E2FB7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n013E2FBC    F3:AB           rep stos dword ptr es:[edi]\n013E2FBE    8BF4            mov esi,esp\n013E2FC0    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n013E2FC3    50              push eax\n013E2FC4    68 A8583E01     push offset TestCode.??_C@_03PMGGPEJJ@?$>; ASCII 25,\"d\\n\"\n013E2FC9    FF15 14913E01   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n013E2FCF    83C4 08         add esp,0x8\n013E2FD2    3BF4            cmp esi,esp\n013E2FD4    E8 02E2FFFF     call TestCode.013E11DB\n013E2FD9    5F              pop edi                                  ; kernel32.762D38F4\n013E2FDA    5E              pop esi                                  ; kernel32.762D38F4\n013E2FDB    5B              pop ebx                                  ; kernel32.762D38F4\n013E2FDC    81C4 C0000000   add esp,0xC0\n013E2FE2    3BEC            cmp ebp,esp\n013E2FE4    E8 F2E1FFFF     call TestCode.013E11DB\n013E2FE9    8BE5            mov esp,ebp\n013E2FEB    5D              pop ebp                                  ; kernel32.762D38F4\n013E2FEC    C2 0400         retn 0x4 //return 4相当于esp += 4\nShowCde函数\n013E29E0 >  55              push ebp\n013E29E1    8BEC            mov ebp,esp\n013E29E3    81EC C0000000   sub esp,0xC0\n013E29E9    53              push ebx\n013E29EA    56              push esi                                         ; TestCode.<ModuleEntryPoint>\n013E29EB    57              push edi                                         ; TestCode.<ModuleEntryPoint>\n013E29EC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n013E29F2    B9 30000000     mov ecx,0x30\n013E29F7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n013E29FC    F3:AB           rep stos dword ptr es:[edi]\n013E29FE    8BF4            mov esi,esp\n013E2A00    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n013E2A03    50              push eax\n013E2A04    68 A8583E01     push offset TestCode.??_C@_03PMGGPEJJ@?$CFd?6?$A>; ASCII 25,\"d\\n\"\n013E2A09    FF15 14913E01   call dword ptr ds:[<&MSVCR120D.printf>]          ; msvcr120.printf\n013E2A0F    83C4 08         add esp,0x8\n013E2A12    3BF4            cmp esi,esp\n013E2A14    E8 C2E7FFFF     call TestCode.013E11DB\n013E2A19    5F              pop edi                                          ; kernel32.762D38F4\n013E2A1A    5E              pop esi                                          ; kernel32.762D38F4\n013E2A1B    5B              pop ebx                                          ; kernel32.762D38F4\n013E2A1C    81C4 C0000000   add esp,0xC0\n013E2A22    3BEC            cmp ebp,esp\n013E2A24    E8 B2E7FFFF     call TestCode.013E11DB\n013E2A29    8BE5            mov esp,ebp\n013E2A2B    5D              pop ebp                                          ; kernel32.762D38F4\n013E2A2C    C3              retn //直接返回没有平衡栈操作\n```\n\nPrintf函数在debug和release的区别：\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    printf(\"Hello\");\n    printf(\"World\");\n    printf(\"C++\");\n    printf(\"\\r\\n\");\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n013533F0 >  55              push ebp\n013533F1    8BEC            mov ebp,esp\n013533F3    81EC C0000000   sub esp,0xC0\n013533F9    53              push ebx\n013533FA    56              push esi                                         ; TestCode.<ModuleEntryPoint>\n013533FB    57              push edi                                         ; TestCode.<ModuleEntryPoint>\n013533FC    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n01353402    B9 30000000     mov ecx,0x30\n01353407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0135340C    F3:AB           rep stos dword ptr es:[edi]\n0135340E    8BF4            mov esi,esp\n01353410    68 AC583501     push offset TestCode.??_C@_05COLMCDPH@Hello?$AA@>; ASCII 48,\"ello\"\n01353415    FF15 14913501   call dword ptr ds:[<&MSVCR120D.printf>]          ; msvcr120.printf\n0135341B    83C4 04         add esp,0x4\n0135341E    3BF4            cmp esi,esp\n01353420    E8 B6DDFFFF     call TestCode.013511DB\n01353425    8BF4            mov esi,esp\n01353427    68 18593501     push offset TestCode.??_C@_05MFLOHCHP@World?$AA@>\n0135342C    FF15 14913501   call dword ptr ds:[<&MSVCR120D.printf>]          ; msvcr120.printf\n01353432    83C4 04         add esp,0x4\n01353435    3BF4            cmp esi,esp\n01353437    E8 9FDDFFFF     call TestCode.013511DB\n0135343C    8BF4            mov esi,esp\n0135343E    68 B4583501     push offset TestCode.??_C@_03BFHCIDFI@C?$CL?$CL?>\n01353443    FF15 14913501   call dword ptr ds:[<&MSVCR120D.printf>]          ; msvcr120.printf\n01353449    83C4 04         add esp,0x4\n0135344C    3BF4            cmp esi,esp\n0135344E    E8 88DDFFFF     call TestCode.013511DB\n01353453    8BF4            mov esi,esp\n01353455    68 20593501     push offset TestCode.??_C@_02PCIJFNDE@?$AN?6?$AA>\n0135345A    FF15 14913501   call dword ptr ds:[<&MSVCR120D.printf>]          ; msvcr120.printf\n01353460    83C4 04         add esp,0x4\n01353463    3BF4            cmp esi,esp\n01353465    E8 71DDFFFF     call TestCode.013511DB\n0135346A    33C0            xor eax,eax\n0135346C    5F              pop edi                                          ; kernel32.762D38F4\n0135346D    5E              pop esi                                          ; kernel32.762D38F4\n0135346E    5B              pop ebx                                          ; kernel32.762D38F4\n0135346F    81C4 C0000000   add esp,0xC0\n01353475    3BEC            cmp ebp,esp\n01353477    E8 5FDDFFFF     call TestCode.013511DB\n0135347C    8BE5            mov esp,ebp\n0135347E    5D              pop ebp                                          ; kernel32.762D38F4\n0135347F    C3              retn\n```\n\n这里可以看出来每次调用后都进行堆栈平衡。\n\n对应反汇编Release：\n\n```\n00181000 >/$  56            push esi                                                     ;  TestCode.<ModuleEntryPoint>\n00181001  |.  8B35 90201800 mov esi,dword ptr ds:[<&MSVCR120.printf>]                    ;  msvcr120.printf\n00181007  |.  68 00211800   push offset TestCode.??_C@_05COLMCDPH@Hello?$AA@ime@4        ; /Hello\n0018100C  |.  FFD6          call esi                                                     ; \\printf\n0018100E  |.  68 08211800   push offset TestCode.??_C@_05MFLOHCHP@World?$AA@2ptionFilter>;  World\n00181013  |.  FFD6          call esi                                                     ;  TestCode.<ModuleEntryPoint>\n00181015  |.  68 10211800   push offset TestCode.??_C@_03BFHCIDFI@C?$CL?$CL?$AA@4        ;  C++\n0018101A  |.  FFD6          call esi                                                     ;  TestCode.<ModuleEntryPoint>\n0018101C  |.  68 14211800   push offset TestCode.??_C@_02PCIJFNDE@?$AN?6?$AA@ilter       ;  \\r\\n\n00181021  |.  FFD6          call esi                                                     ;  TestCode.<ModuleEntryPoint>\n00181023  |.  83C4 10       add esp,0x10\n00181026  |.  33C0          xor eax,eax\n00181028  |.  5E            pop esi                                                      ;  kernel32.762D38F4\n00181029  \\.  C3            retn\n```\n\n这里可以看出来最后一个printf函数执行完后，一次对堆栈进行平衡，这种优化方式为复写传播。\n因此在Release版本优化之后，由于_cdecl方式使用的函数外栈平衡，所以可以将多次平衡合并，会在效率上比_stdcall方式高一些。\n\n## __fastcall调用方式：\n\nC代码：\n\n```c\nvoid _fastcall ShowFast(int n1,int n2,int n3,int n4)\n{\n    printf(\"%d%d%d%d\\n\", n1,n2, n3, n4);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    ShowFast(1, 2, 3, 4);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\nMain函数\n00891790 >  55              push ebp\n00891791    8BEC            mov ebp,esp\n00891793    81EC C0000000   sub esp,0xC0\n00891799    53              push ebx\n0089179A    56              push esi                                                     ; TestCode.<ModuleEntryPoint>\n0089179B    57              push edi                                                     ; TestCode.<ModuleEntryPoint>\n0089179C    8DBD 40FFFFFF   lea edi,dword ptr ss:[ebp-0xC0]\n008917A2    B9 30000000     mov ecx,0x30\n008917A7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n008917AC    F3:AB           rep stos dword ptr es:[edi]\n008917AE    6A 04           push 0x4//用栈传参\n008917B0    6A 03           push 0x3//用栈传参\n008917B2    BA 02000000     mov edx,0x2//寄存器传参\n008917B7    B9 01000000     mov ecx,0x1//寄存器传参\n008917BC    E8 38FAFFFF     call TestCode.008911F9\nShowFast函数\n00892FA0 >  55              push ebp\n00892FA1    8BEC            mov ebp,esp\n00892FA3    81EC D8000000   sub esp,0xD8\n00892FA9    53              push ebx\n00892FAA    56              push esi                                                     ; TestCode.<ModuleEntryPoint>\n00892FAB    57              push edi                                                     ; TestCode.<ModuleEntryPoint>\n00892FAC    51              push ecx                                                     ; TestCode.<ModuleEntryPoint>\n00892FAD    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00892FB3    B9 36000000     mov ecx,0x36\n00892FB8    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00892FBD    F3:AB           rep stos dword ptr es:[edi]\n00892FBF    59              pop ecx                                                      ; kernel32.762D38F4\n00892FC0    8955 EC         mov dword ptr ss:[ebp-0x14],edx //保存参数                              ; TestCode.<ModuleEntryPoint>\n00892FC3    894D F8         mov dword ptr ss:[ebp-0x8],ecx //保存参数                              ; TestCode.<ModuleEntryPoint>\n00892FC6    8BF4            mov esi,esp\n00892FC8    8B45 0C         mov eax,dword ptr ss:[ebp+0xC] //参数给eax\n00892FCB    50              push eax\n00892FCC    8B4D 08         mov ecx,dword ptr ss:[ebp+0x8] ////参数给ecx\n00892FCF    51              push ecx                                                     ; TestCode.<ModuleEntryPoint>\n00892FD0    8B55 EC         mov edx,dword ptr ss:[ebp-0x14]\n00892FD3    52              push edx                                                     ; TestCode.<ModuleEntryPoint>\n00892FD4    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]                               ; kernel32.BaseThreadInitThunk\n00892FD7    50              push eax\n00892FD8    68 E45A8900     push offset TestCode.??_C@_09GDOPBKAD@?$CFd?$CFd?$CFd?$CFd?6>; ASCII \"%d%d%d%d\\n\"\n00892FDD    FF15 14918900   call dword ptr ds:[<&MSVCR120D.printf>]                      ; msvcr120.printf //调用printf\n00892FE3    83C4 14         add esp,0x14 //平衡堆栈，五个参数\n00892FE6    3BF4            cmp esi,esp\n00892FE8    E8 EEE1FFFF     call TestCode.008911DB\n00892FED    5F              pop edi                                                      ; kernel32.762D38F4\n00892FEE    5E              pop esi                                                      ; kernel32.762D38F4\n00892FEF    5B              pop ebx                                                      ; kernel32.762D38F4\n00892FF0    81C4 D8000000   add esp,0xD8\n00892FF6    3BEC            cmp ebp,esp\n00892FF8    E8 DEE1FFFF     call TestCode.008911DB\n00892FFD    8BE5            mov esp,ebp\n00892FFF    5D              pop ebp                                                      ; kernel32.762D38F4\n00893000    C2 0800         retn 0x8 //\n```\n\n函数有四个参数，只有两个用栈传递，所以平衡堆栈+8就可以了\n\n## 使用ebp和esp寻址（栈的寻址）\n\n寄存器ebp和esp分别用来存储当前函数的栈底和栈顶指针，而局部变量是存储在栈中的，因此可以利用这两个寄存器进行寻址来找到相应的局部变量。\nC代码：\n\n```c\nvoid InNumber()\n{\n    int nInt = 1;\n    scanf_s(\"%d\",&nInt);\n    char cChar = 2;\n    scanf_s(\"%c\",&cChar);\n    printf(\"%d %c\", nInt, cChar);\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    InNumber();\n    return 0;\n}\n```\n\n对应反汇编Release：\n编译器优化掉了\n\n```\ntext:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)\n.text:00401000 _main           proc near               ; CODE XREF: ___tmainCRTStartup+F8\n.text:00401000\n.text:00401000 var_C           = dword ptr -0Ch\n.text:00401000 var_5           = byte ptr -5\n.text:00401000 var_4           = dword ptr -4\n.text:00401000 argc            = dword ptr  8\n.text:00401000 argv            = dword ptr  0Ch\n.text:00401000 envp            = dword ptr  10h\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 sub     esp, 0Ch\n.text:00401006                 mov     eax, ___security_cookie\n.text:0040100B                 xor     eax, ebp\n.text:0040100D                 mov     [ebp+var_4], eax\n.text:00401010                 lea     eax, [ebp+var_C] //取地址\n.text:00401013                 mov     [ebp+var_C], 1 //初始化变量1\n.text:0040101A                 push    eax\n.text:0040101B                 push    offset Format   ; \"%d\"\n.text:00401020                 call    ds:scanf_s\n.text:00401026                 lea     eax, [ebp+var_5] //取地址\n.text:00401029                 mov     [ebp+var_5], 2 //初始化变量2\n.text:0040102D                 push    eax\n.text:0040102E                 push    offset aC       ; \"%c\"\n.text:00401033                 call    ds:scanf_s\n.text:00401039                 movsx   eax, [ebp+var_5]\n.text:0040103D                 push    eax\n.text:0040103E                 push    [ebp+var_C]\n.text:00401041                 push    offset aDC      ; \"%d %c\"\n.text:00401046                 call    ds:printf\n.text:0040104C                 mov     ecx, [ebp+var_4]\n.text:0040104F                 add     esp, 1Ch //平衡堆栈\n.text:00401052                 xor     ecx, ebp\n.text:00401054                 xor     eax, eax\n.text:00401056                 call    @__security_check_cookie@4 ; __security_check_cookie(x)\n.text:0040105B                 mov     esp, ebp\n.text:0040105D                 pop     ebp\n.text:0040105E                 retn\n.text:0040105E _main           endp\n```\n\n这里用ebp寄存器来寻址。\n\n## 函数的参数\n\n函数参数通过栈结构进行传递，在C++代码中，其传参顺序为从右向左一次入栈，最先定义的参数最后入栈。参数也是函数中的一个变量，才用正数标号法来表示局部变量偏移标号时，函数的参数标号和局部变量的标号值都是正数，无法区分，不利于分析。如果使用负数标号法表示，则可以将两者区分，正数表示参数，负数表示局部变量，0值表示返回地址。\n\nC代码：\n\n```c\nvoid AddNum(int n1)\n{\n    n1 += 1;\n    printf(\"%d\\n\", n1);\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int n1 = 0;\n    scanf_s(\"%d\", &n1);\n    AddNum(n1);\n    return 0;\n}\n```\n\n对应反汇编Release：\n编译器又把函数优化掉了，换个编译器。\nMain函数\n\n```\ntext:00401020 ; int __cdecl main(int argc, const char **argv, const char **envp)\n.text:00401020 _main           proc near               ; CODE XREF: start+AF\n.text:00401020\n.text:00401020 var_4           = dword ptr -4 //局部变量，负数\n.text:00401020 argc            = dword ptr  4\n.text:00401020 argv            = dword ptr  8\n.text:00401020 envp            = dword ptr  0Ch\n.text:00401020\n.text:00401020                 push    ecx\n.text:00401021                 lea     eax, [esp+4+var_4] //取局部变量地址到eax\n.text:00401025                 mov     [esp+4+var_4], 0 //初始化\n.text:0040102D                 push    eax //参数压栈\n.text:0040102E                 push    offset aD_0     ; \"%d\"\n.text:00401033                 call    _scanf\n.text:00401038                 mov     ecx, [esp+0Ch+var_4] //取局部变量内容到ecx\n.text:0040103C                 push    ecx //参数压栈\n.text:0040103D                 call    sub_401000 //调用AddNum函数\n.text:00401042                 xor     eax, eax\n.text:00401044                 add     esp, 10h //堆栈平衡\n.text:00401047                 retn\n.text:00401047 _main           endp\nAddNum函数\n.text:00401000 sub_401000      proc near               ; CODE XREF: _main+1D\n.text:00401000\n.text:00401000 arg_0           = dword ptr  4 //参数，正数\n.text:00401000\n.text:00401000                 mov     eax, [esp+arg_0] 参数1给eax\n.text:00401004                 inc     eax //eax +=1\n.text:00401005                 push    eax //参数压栈\n.text:00401006                 push    offset aD       ; \"%d\\n\"\n.text:0040100B                 call    _printf\n.text:00401010                 add     esp, 8 //堆栈平衡\n.text:00401013                 retn\n.text:00401013 sub_401000      endp\n```\n\n通过这两段代码的比较，可以看到局部变量和函数的参数定义是不一样的。局部变量是相对于栈顶指针的负数值，而参数则是正数偏移，我们知道内存是从大到小分配空间的，所以参数先于局部变量分配空间，并且先于调用函数。\n\n## 函数的返回值\n\n### 基本类型作为返回值\n\nC代码：\n\n```c\nint GetAddr(int nNum)\n{\n    int nAddr = *(int *)(&nNum - 1);\n    return nAddr;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    GetAddr(1);\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00322FA0 >  55              push ebp\n00322FA1    8BEC            mov ebp,esp\n00322FA3    81EC CC000000   sub esp,0xCC\n00322FA9    53              push ebx\n00322FAA    56              push esi                                                     ; TestCode.<ModuleEntryPoint>\n00322FAB    57              push edi                                                     ; TestCode.<ModuleEntryPoint>\n00322FAC    8DBD 34FFFFFF   lea edi,dword ptr ss:[ebp-0xCC]\n00322FB2    B9 33000000     mov ecx,0x33\n00322FB7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00322FBC    F3:AB           rep stos dword ptr es:[edi]\n00322FBE    8D45 08         lea eax,dword ptr ss:[ebp+0x8] //取参数1的地址\n00322FC1    83E8 04         sub eax,0x4 //地址-4，相当于指针-1\n00322FC4    8B08            mov ecx,dword ptr ds:[eax] //取内容给ecx\n00322FC6    894D F8         mov dword ptr ss:[ebp-0x8],ecx                               ; TestCode.<ModuleEntryPoint>\n00322FC9    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]    //把地址eax返回                           ; kernel32.BaseThreadInitThunk\n00322FCC    5F              pop edi                                                      ; kernel32.762D38F4\n00322FCD    5E              pop esi                                                      ; kernel32.762D38F4\n00322FCE    5B              pop ebx                                                      ; kernel32.762D38F4\n00322FCF    8BE5            mov esp,ebp\n00322FD1    5D              pop ebp                                                      ; kernel32.762D38F4\n00322FD2    C3              retn\n```\n\n### 结构体作为返回值\n\nC代码：\n\n```c\nstruct tagTest\n{\n    int m_nOne;\n    int m_nTwo;\n};\ntagTest RetSruct()\n{\n    tagTest test;\n    test.m_nOne = 1;\n    test.m_nTwo = 2;\n    return test;\n}\nint _tmain(int argc, _TCHAR* argv[])\n{\n    tagTest test = RetSruct();\n    return 0;\n}\n```\n\n对应反汇编Debug：\nMain函数\n\n```\n00953C20 >  55              push ebp\n00953C21    8BEC            mov ebp,esp\n00953C23    81EC E0000000   sub esp,0xE0\n00953C29    53              push ebx\n00953C2A    56              push esi                                                          ; TestCode.<ModuleEntryPoint>\n00953C2B    57              push edi                                                          ; TestCode.<ModuleEntryPoint>\n00953C2C    8DBD 20FFFFFF   lea edi,dword ptr ss:[ebp-0xE0]\n00953C32    B9 38000000     mov ecx,0x38\n00953C37    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00953C3C    F3:AB           rep stos dword ptr es:[edi]\n00953C3E    E8 CFD5FFFF     call TestCode.00951212 //函数调用\n00953C43    8985 24FFFFFF   mov dword ptr ss:[ebp-0xDC],eax //eax给局部变量ebp-0xdc\n00953C49    8995 28FFFFFF   mov dword ptr ss:[ebp-0xD8],edx  //edx给局部变量ebp-0xd8                                 ; TestCode.<ModuleEntryPoint>\n00953C4F    8B85 24FFFFFF   mov eax,dword ptr ss:[ebp-0xDC]\n00953C55    8945 F4         mov dword ptr ss:[ebp-0xC],eax\n00953C58    8B8D 28FFFFFF   mov ecx,dword ptr ss:[ebp-0xD8]\n00953C5E    894D F8         mov dword ptr ss:[ebp-0x8],ecx                                    ; TestCode.<ModuleEntryPoint>\n00953C61    33C0            xor eax,eax\n00953C63    52              push edx                                                          ; TestCode.<ModuleEntryPoint>\n00953C64    8BCD            mov ecx,ebp\n00953C66    50              push eax\n00953C67    8D15 883C9500   lea edx,dword ptr ds:[0x953C88]\n00953C6D    E8 5AD5FFFF     call TestCode.009511CC\n00953C72    58              pop eax                                                           ; kernel32.762D38F4\n00953C73    5A              pop edx                                                           ; kernel32.762D38F4\n00953C74    5F              pop edi                                                           ; kernel32.762D38F4\n00953C75    5E              pop esi                                                           ; kernel32.762D38F4\n00953C76    5B              pop ebx                                                           ; kernel32.762D38F4\n00953C77    81C4 E0000000   add esp,0xE0\nRetStruct函数\n009533F0 >  55              push ebp\n009533F1    8BEC            mov ebp,esp\n009533F3    81EC D0000000   sub esp,0xD0\n009533F9    53              push ebx\n009533FA    56              push esi                                                          ; TestCode.<ModuleEntryPoint>\n009533FB    57              push edi                                                          ; TestCode.<ModuleEntryPoint>\n009533FC    8DBD 30FFFFFF   lea edi,dword ptr ss:[ebp-0xD0]\n00953402    B9 34000000     mov ecx,0x34\n00953407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n0095340C    F3:AB           rep stos dword ptr es:[edi]\n0095340E    C745 F4 0100000>mov dword ptr ss:[ebp-0xC],0x1 //对结构体变量赋值\n00953415    C745 F8 0200000>mov dword ptr ss:[ebp-0x8],0x2 //对结构体变量赋值\n0095341C    8B45 F4         mov eax,dword ptr ss:[ebp-0xC] //变量1给eax\n0095341F    8B55 F8         mov edx,dword ptr ss:[ebp-0x8] //变量2给edx                                   ; kernel32.BaseThreadInitThunk\n00953422    52              push edx                                                          ; TestCode.<ModuleEntryPoint>\n00953423    8BCD            mov ecx,ebp\n00953425    50              push eax\n00953426    8D15 3C349500   lea edx,dword ptr ds:[0x95343C]\n0095342C    E8 9BDDFFFF     call TestCode.009511CC\n00953431    58              pop eax                                                           ; kernel32.762D38F4\n00953432    5A              pop edx                                                           ; kernel32.762D38F4\n00953433    5F              pop edi                                                           ; kernel32.762D38F4\n00953434    5E              pop esi                                                           ; kernel32.762D38F4\n00953435    5B              pop ebx                                                           ; kernel32.762D38F4\n00953436    8BE5            mov esp,ebp\n00953438    5D              pop ebp                                                           ; kernel32.762D38F4\n00953439    C3              retn\n```\n\n由此可以看出大于4字节的返回值，可以用eax和edx两个寄存器来传递返回值。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(二)","url":"/2016/11/22/逆向笔记-二/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之循环语句。\n\n## Do循环\n\n首先先看利用goto语句模拟循环的例子。\n\nC代码：\n\n```c\nint GoToDo(int nCount)\n{\n    int nSum = 0;\n    int nIndex = 0;\nGOTO_DO:\n    nSum += nIndex;\n    nIndex++;\n    if (nIndex <= nCount)\n    {\n        goto GOTO_DO;\n    }\n    return nSum;\n}\n```\n\n上面代码的功能和do…while循环语句实现的功能相同，是一个循环，并且至少执行一遍。\n\n来看看do循环的代码\n\nC代码：\n\n```c\nint LoopDo(int nCount)\n{\n    printf(\"LoopDo\\n\");\n    int nSum = 0;\n    int nIndex = 0;\n    do \n    {\n        nSum += nIndex;\n        nIndex++;\n    } while (nIndex < nCount);\n    return nSum;\n}\n```\n\n对应反汇编Debug：\n\n```\n00C02FA0 >  55              push ebp\n00C02FA1    8BEC            mov ebp,esp\n00C02FA3    81EC D8000000   sub esp,0xD8\n00C02FA9    53              push ebx\n00C02FAA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n00C02FAB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n00C02FAC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00C02FB2    B9 36000000     mov ecx,0x36\n00C02FB7    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00C02FBC    F3:AB           rep stos dword ptr es:[edi]\n00C02FBE    8BF4            mov esi,esp\n00C02FC0    68 B058C000     push offset TestCode.??_C@_07DEHDDNIF@Lo>; LoopDo\\n\n00C02FC5    FF15 1491C000   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n00C02FCB    83C4 04         add esp,0x4\n00C02FCE    3BF4            cmp esi,esp\n00C02FD0    E8 06E2FFFF     call TestCode.00C011DB\n00C02FD5    C745 F8 0000000>mov dword ptr ss:[ebp-0x8],0x0   //初始化变量1\n00C02FDC    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0  //初始化变量2\n00C02FE3    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n00C02FE6    0345 EC         add eax,dword ptr ss:[ebp-0x14] //变量1 + 1\n00C02FE9    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n00C02FEC    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C02FEF    83C0 01         add eax,0x1 //变量2 + 1\n00C02FF2    8945 EC         mov dword ptr ss:[ebp-0x14],eax\n00C02FF5    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00C02FF8    3B45 08         cmp eax,dword ptr ss:[ebp+0x8] //变量2与参数1比较\n00C02FFB  ^ 7C E6           jle short TestCode.00C02FE3 //小于等于则跳\n00C02FFD    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n00C03000    5F              pop edi                                  ; kernel32.764D38F4\n00C03001    5E              pop esi                                  ; kernel32.764D38F4\n00C03002    5B              pop ebx                                  ; kernel32.764D38F4\n```\n\n总结：\nDo_Begin\n…循环体\n执行影响标志位的指令\nCmp xx,xx\n执行跳转指令，向上跳转\nJxx Do_Begin\nDo_End0\n\n## While循环\n\nC代码：\n\n```c\nint LoopWhile(int nCount)\n{\n    printf(\"LoopWhile\\n\");\n    int nSum = 0;\n    int nIndex = 0;\n    while (nIndex <= nCount)\n    {\n        nSum += nIndex;\n        nIndex++;\n    }\n    return nSum;\n}\n```\n\n对应反汇编Debug：\n\n```\n00FD33F0 >  55              push ebp\n00FD33F1    8BEC            mov ebp,esp\n00FD33F3    81EC D8000000   sub esp,0xD8\n00FD33F9    53              push ebx\n00FD33FA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n00FD33FB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n00FD33FC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n00FD3402    B9 36000000     mov ecx,0x36\n00FD3407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n00FD340C    F3:AB           rep stos dword ptr es:[edi]\n00FD340E    8BF4            mov esi,esp\n00FD3410    68 1859FD00     push offset TestCode.??_C@_0L@BELIKDOL@L>; LoopWhile\\n\n00FD3415    FF15 1491FD00   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n00FD341B    83C4 04         add esp,0x4\n00FD341E    3BF4            cmp esi,esp\n00FD3420    E8 B6DDFFFF     call TestCode.00FD11DB\n00FD3425    C745 F8 0000000>mov dword ptr ss:[ebp-0x8],0x0 //初始化变量1\n00FD342C    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0 //初始化变量2\n00FD3433    8B45 EC         mov eax,dword ptr ss:[ebp-0x14] \n00FD3436    3B45 08         cmp eax,dword ptr ss:[ebp+0x8] //变量2与参数1比较\n00FD3439    7F 14           jg short TestCode.00FD344F //大于则跳到结尾处\n00FD343B    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n00FD343E    0345 EC         add eax,dword ptr ss:[ebp-0x14]\n00FD3441    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n00FD3444    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n00FD3447    83C0 01         add eax,0x1\n00FD344A    8945 EC         mov dword ptr ss:[ebp-0x14],eax\n00FD344D  ^ EB E4           jmp short TestCode.00FD3433 //向上跳转\n00FD344F    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n00FD3452    5F              pop edi                                  ; kernel32.764D38F4\n00FD3453    5E              pop esi                                  ; kernel32.764D38F4\n00FD3454    5B              pop ebx                                  ; kernel32.764D38F4\n```\n\n总结：\nWhile_Begin\n执行影响标志位的指令\nCmp xx,xx\n执行跳转指令\nJxx While_End\n…循环体\n执行跳转指令，向上跳转\nJmp While_Begin\nWhile_End\n\n由此可以看出while循环要进行两次跳转，效率会比do循环低。可以将其优化成如下格式：\nIf(xxx)\n{\nDo\n{\n}while(xxx)\n}\n\n## For循环\n\nC代码：\n\n```c\nint LoopFor(int nCount)\n{\n    printf(\"LoopFor\\n\");\n    int nSum = 0;\n    int nIndex = 0;\n    for (nIndex; nIndex <= nCount;nIndex++)\n    {\n        nSum += nIndex;\n    }\n    return nSum;\n}\n```\n\n对应反汇编Debug：\n\n```\n002A33F0 >  55              push ebp\n002A33F1    8BEC            mov ebp,esp\n002A33F3    81EC D8000000   sub esp,0xD8\n002A33F9    53              push ebx\n002A33FA    56              push esi                                 ; TestCode.<ModuleEntryPoint>\n002A33FB    57              push edi                                 ; TestCode.<ModuleEntryPoint>\n002A33FC    8DBD 28FFFFFF   lea edi,dword ptr ss:[ebp-0xD8]\n002A3402    B9 36000000     mov ecx,0x36\n002A3407    B8 CCCCCCCC     mov eax,0xCCCCCCCC\n002A340C    F3:AB           rep stos dword ptr es:[edi]\n002A340E    8BF4            mov esi,esp\n002A3410    68 E45A2A00     push offset TestCode.??_C@_08EHCLIGJA@Lo>; LoopFor\\n\n002A3415    FF15 14912A00   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n002A341B    83C4 04         add esp,0x4\n002A341E    3BF4            cmp esi,esp\n002A3420    E8 B6DDFFFF     call TestCode.002A11DB\n002A3425    C745 F8 0000000>mov dword ptr ss:[ebp-0x8],0x0 //初始化变量1\n002A342C    C745 EC 0000000>mov dword ptr ss:[ebp-0x14],0x0 //初始化变量2\n002A3433    EB 09           jmp short TestCode.002A343E\n002A3435    8B45 EC         mov eax,dword ptr ss:[ebp-0x14]\n002A3438    83C0 01         add eax,0x1\n002A343B    8945 EC         mov dword ptr ss:[ebp-0x14],eax\n002A343E    8B45 EC         mov eax,dword ptr ss:[ebp-0x14] \n002A3441    3B45 08         cmp eax,dword ptr ss:[ebp+0x8] //变量2与参数1比较\n002A3444    7F 0B           jg short TestCode.002A3451 //大于则跳转到结尾处\n002A3446    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n002A3449    0345 EC         add eax,dword ptr ss:[ebp-0x14]\n002A344C    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n002A344F  ^ EB E4           jmp short TestCode.002A3435 //向上跳转\n002A3451    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.BaseThreadInitThunk\n002A3454    5F              pop edi                                  ; kernel32.764D38F4\n002A3455    5E              pop esi                                  ; kernel32.764D38F4\n002A3456    5B              pop ebx                                  ; kernel32.764D38F4\n```\n\n总结：\nFor_Begin\nMov xx,xx 赋初值\n执行跳转指令\nJmp xxx\n修改循环变量Step\nMov xx,Step\n修改循环变量的计算过程\nAdd xx.xx\nMov Step,xx\nFor_Cmp\n执行影响标志位的指令\nCmp xx,xx\n执行跳转指令\nJxx For_End\n…循环体\n执行跳转指令，向上跳转\nJmp For_Begin\nFor_End\n\n这里可以看到，for循环与while循环一样，都是先判断后执行，但是for循环共有3次跳转，是循环语句中效率最低的，但是如果把赋初值部分移动到循环之外即可转化为while循环然后再转化为do…while循环。\n\n## 循环结构优化——代码外提\n\n例子：IDA Pro反汇编的Release版本\nC代码：\n\n```c\n// 代码外提\nint CodePick(int nCount)\n{\n    int nSum =0;\n    int nIndex =0;\n    do\n    {\n        nSum += nIndex;\n        nIndex++;\n    } while(nIndex< nCount - 1);\n    return nSum;\n}\n```\n\n对应反汇编：\n\n```\n.text:00401000 arg_0           = dword ptr  8\n.text:00401000\n.text:00401000                 push    ebp\n.text:00401001                 mov     ebp, esp\n.text:00401003                 mov     edx, [ebp+arg_0]\n.text:00401006                 xor     eax, eax\n.text:00401008                 xor     ecx, ecx\n.text:0040100A                 dec     edx\n.text:0040100B                 jmp     short loc_401010\n.text:0040100B ;---------------------------------------------------------------------------\n.text:0040100D                 align 10h\n.text:00401010\n.text:00401010 loc_401010:                             ; CODE XREF:sub_401000+Bj\n.text:00401010                                         ;sub_401000+15j\n.text:00401010                 add     eax, ecx\n.text:00401012                 inc     ecx\n.text:00401013                 cmp     ecx,edx\n.text:00401015                 jl      short loc_401010\n```\n\n可以很明显的看到.text:0040100A dec edx这条语句不在循环中，这就是代码外提。把不需要重复的计算都放到循环之外，这样可以减少计算量，提高计算效率。\n\n## 强度降低\n\n\nC代码：\n\n```c\n// 强度降低\nvoid DoRate(int argc)\n{\n  int t = 0;\n  int i = 0;\n  while (t <argc)\n  {\n    t = i * 99;\n    i++;\n  }\n  printf(\"%d\",t);\n}\n```\n\n这里只列出循环的反汇编代码：\n.text:00401030 loc_401030:                       ; CODE XREF: sub_401020+17j\n.text:00401030                 mov     eax, ecx\n.text:00401032                 add     ecx, 63h\n.text:00401035                 cmp    eax, edx\n.text:00401037                 jl      short loc_401030\n这里把乘法转化成了加法从而大大减少了运算量，提高了程序的执行效率。","tags":["reverse"],"categories":["reverse"]},{"title":"逆向笔记(一)","url":"/2016/11/21/逆向笔记-一/","content":"\n最近闲了下来，总结一下之前的知识，这些东西都是好久之前留下的了，现在在回味一遍，梳理梳理。\n\n逆向笔记之流程控制语句。\n\n## if语句\n\n```c\nC代码：\n    if (argc > 0)\n    {\n        printf(\"%d\\n\", argc);\n    }\n```\n\n对应反汇编Debug：\n\n```\n008B13DE    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0 //参数1与0比较\n008B13E2    7E 1B           jle short TestCode.008B13FF //小于等于0则跳转，使用了相反的跳转指令\n008B13E4    8BF4            mov esi,esp\n008B13E6    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n008B13E9    50              push eax\n008B13EA    68 58588B00     push offset TestCode.??_C@_03PMGGPEJJ@?$>; %d\\n\n008B13EF    FF15 14918B00   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n008B13F5    83C4 08         add esp,0x8\n008B13F8    3BF4            cmp esi,esp\n008B13FA    E8 41FDFFFF     call TestCode.008B1140\n008B13FF    33C0            xor eax,eax\n```\n\n总结：\n执行影响标志位的指令\ncmp xx,xx\n执行跳转指令\njxx xx\n\n## if-else语句\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    if (argc == 0)\n    {\n        printf(\"argc == 0\");\n    }\n    else\n    {\n        printf(\"argc != 0\");\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00871A0E    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0 //参数1与0比较\n00871A12    75 19           jnz short TestCode.00871A2D //不等于0跳转到else语句块\n00871A14    8BF4            mov esi,esp\n00871A16    68 20598700     push offset TestCode.??_C@_08EMJPKIIM@ar>; argc ==0\n00871A1B    FF15 14918700   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n00871A21    83C4 04         add esp,0x4\n00871A24    3BF4            cmp esi,esp\n00871A26    E8 15F7FFFF     call TestCode.00871140\n00871A2B    EB 17           jmp short TestCode.00871A44 //条件成立跳到结尾处，与if语句相比只多了这句跳转指令\n00871A2D    8BF4            mov esi,esp\n00871A2F    68 B0588700     push offset TestCode.??_C@_09ICDCLPKD@ar>; argc != 0\n00871A34    FF15 14918700   call dword ptr ds:[<&MSVCR120D.printf>]  ; msvcr120.printf\n00871A3A    83C4 04         add esp,0x4\n00871A3D    3BF4            cmp esi,esp\n00871A3F    E8 FCF6FFFF     call TestCode.00871140\n00871A44    33C0            xor eax,eax\n```\n\n总结：\n执行影响标志位的指令\ncmp xx,xx\n执行跳转指令\njxx Else_Begin\nIf_Begin\n…if语句块\nIf_End\njmp Else_End\nElse_Begin\n…else语句块\nElse_End\n\n## if-else if-else语句\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    if (argc > 0)\n    {\n        printf(\"argc > 0\");\n    }\n    else if (argc == 0)\n    {\n        printf(\"argc == 0\");\n    }\n    else\n    {\n        printf(\"argc <= 0\");\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00C313DE    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0 //参数1与0比较\n00C313E2    7E 19           jle short 00C313FD //小于等于0则跳转，使用了相反的跳转指令                      ; 00C313FD\n00C313E4    8BF4            mov esi,esp\n00C313E6    68 5858C300     push 0xC35858                            ; argc > 0\n00C313EB    FF15 1491C300   call dword ptr ds:[0xC39114]             ; msvcr120.printf\n00C313F1    83C4 04         add esp,0x4\n00C313F4    3BF4            cmp esi,esp\n00C313F6    E8 45FDFFFF     call 00C31140                            ; 00C31140\n00C313FB    EB 36           jmp short 00C31433 //条件成立跳到结尾处                      ; 00C31433\n00C313FD    837D 08 00      cmp dword ptr ss:[ebp+0x8],0x0 //参数1与0比较\n00C31401    75 19           jnz short 00C3141C //不等于0则跳转                      ; 00C3141C\n00C31403    8BF4            mov esi,esp\n00C31405    68 6458C300     push 0xC35864                            ; argc == 0\n00C3140A    FF15 1491C300   call dword ptr ds:[0xC39114]             ; msvcr120.printf\n00C31410    83C4 04         add esp,0x4\n00C31413    3BF4            cmp esi,esp\n00C31415    E8 26FDFFFF     call 00C31140                            ; 00C31140\n00C3141A    EB 17           jmp short 00C31433                       ; 00C31433\n00C3141C    8BF4            mov esi,esp\n00C3141E    68 7058C300     push 0xC35870                            ; argc <= 0\n00C31423    FF15 1491C300   call dword ptr ds:[0xC39114]             ; msvcr120.printf\n00C31429    83C4 04         add esp,0x4\n00C3142C    3BF4            cmp esi,esp\n00C3142E    E8 0DFDFFFF     call 00C31140                            ; 00C31140\n00C31433    33C0            xor eax,eax\n```\n\n总结：\n执行影响标志位的指令\ncmp xx,xx\n执行跳转指令\njxx xx\nIf_Begin\n…if语句块\nIf_End\njmp Else_End\nElse_If_Begin\n…else if语句块\nElse_If_End\njmp Else_End\nElse_Begin\n…else语句块\nElse_End\n\n==========================================================================================\n\n## 小于等于3条case语句块的Switch结构\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nIndex = 0;\n    scanf_s(\"%d\", &nIndex);\n    switch (nIndex)\n    {\n    case 1:printf(\"case 1\\n\"); break;\n    case 2:printf(\"case 2\\n\"); break;\n    case 100:printf(\"case 100\\n\"); break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n01303C55    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n01303C58    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0 //ebp-0xC为nIndex\n01303C5F    8BF4            mov esi,esp\n01303C61    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01303C64    50              push eax\n01303C65    68 58583001     push 0x1305858                           ; %d\n01303C6A    FF15 18913001   call dword ptr ds:[0x1309118]            ; msvcr120.scanf_s\n01303C70    83C4 08         add esp,0x8\n01303C73    3BF4            cmp esi,esp\n01303C75    E8 C6D4FFFF     call 01301140         //Stack_Check                   ; 01301140\n01303C7A    8B45 F4         mov eax,dword ptr ss:[ebp-0xC]\n01303C7D    8985 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],eax   //ebp-0xD4为nIndex\n01303C83    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x1   //nIndex与1比较\n01303C8A    74 14           je short 01303CA0                 //相等则跳入对应语句块        ; 01303CA0\n01303C8C    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x2   //nIndex与2比较\n01303C93    74 24           je short 01303CB9                 //相等则跳入对应语句块        ; 01303CB9\n01303C95    83BD 2CFFFFFF 6>cmp dword ptr ss:[ebp-0xD4],0x64  //nIndex与100比较\n01303C9C    74 34           je short 01303CD2                 //相等则跳入对应语句块       ; 01303CD2\n01303C9E    EB 49           jmp short 01303CE9                //不符合条件跳到结尾处       ; 01303CE9\n01303CA0    8BF4            mov esi,esp\n01303CA2    68 64583001     push 0x1305864                           ; case 1\\n\n01303CA7    FF15 14913001   call dword ptr ds:[0x1309114]            ; msvcr120.printf\n01303CAD    83C4 04         add esp,0x4\n01303CB0    3BF4            cmp esi,esp\n01303CB2    E8 89D4FFFF     call 01301140                            ; 01301140\n01303CB7    EB 30           jmp short 01303CE9      //执行完跳到结尾处                 ; 01303CE9\n01303CB9    8BF4            mov esi,esp\n01303CBB    68 70583001     push 0x1305870                           ; case 2\\n\n01303CC0    FF15 14913001   call dword ptr ds:[0x1309114]            ; msvcr120.printf\n01303CC6    83C4 04         add esp,0x4\n01303CC9    3BF4            cmp esi,esp\n01303CCB    E8 70D4FFFF     call 01301140                            ; 01301140\n01303CD0    EB 17           jmp short 01303CE9                       ; 01303CE9\n01303CD2    8BF4            mov esi,esp\n01303CD4    68 D0583001     push 0x13058D0                           ; case 100\\n\n01303CD9    FF15 14913001   call dword ptr ds:[0x1309114]            ; msvcr120.printf\n01303CDF    83C4 04         add esp,0x4\n01303CE2    3BF4            cmp esi,esp\n01303CE4    E8 57D4FFFF     call 01301140                            ; 01301140\n01303CE9    33C0            xor eax,eax\n```\n\n总结：\n获取switch变量的值\nmov xxx，reg\n执行影响标志位的指令\ncmp xxx，xxx\n执行跳转指令\njxx xxx\n执行影响标志位的指令\ncmp xxx，xxx\n执行跳转指令\njxx xxx\n执行影响标志位的指令\ncmp xxx，xxx\n执行跳转指令\njxx xxx\n执行跳转到结尾处\njmp End\n… case语句块\n… case语句块\n… case语句块\nEnd\n\n## 分支数大于3且存在线性关系的Switch结构\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nIndex = 0;\n    scanf_s(\"%d\", &nIndex);\n    switch (nIndex)\n    {\n    case 1:printf(\"case 1\\n\"); break;\n    case 2:printf(\"case 2\\n\"); break;\n    case 3:printf(\"case 3\\n\"); break;\n    case 4:printf(\"case 4\\n\"); break;\n    case 5:printf(\"case 5\\n\"); break;\n    case 6:printf(\"case 6\\n\"); break;\n    case 7:printf(\"case 7\\n\"); break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n01233C58    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0\n01233C5F    8BF4            mov esi,esp\n01233C61    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n01233C64    50              push eax\n01233C65    68 58582301     push 0x1235858                           ; %d\n01233C6A    FF15 18912301   call dword ptr ds:[0x1239118]            ; msvcr120.scanf_s\n01233C70    83C4 08         add esp,0x8\n01233C73    3BF4            cmp esi,esp\n01233C75    E8 C6D4FFFF     call 01231140                            ; 01231140\n01233C7A    8B45 F4         mov eax,dword ptr ss:[ebp-0xC] \n01233C7D    8985 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],eax //ebp-0xD4为nIndex\n01233C83    8B8D 2CFFFFFF   mov ecx,dword ptr ss:[ebp-0xD4] //nIndex给ecx\n01233C89    83E9 01         sub ecx,0x1 //ecx -1 做下标对齐\n01233C8C    898D 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],ecx          ; TestCode.<ModuleEntryPoint>\n01233C92    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x6 检查范围\n01233C99    0F87 BD000000   ja 01233D5C       //大于则跳转到结尾                       ; 01233D5C\n01233C9F    8B95 2CFFFFFF   mov edx,dword ptr ss:[ebp-0xD4] //以edx为下标进行寻址\n01233CA5    FF2495 AC3D2301 jmp dword ptr ds:[edx*4+0x1233DAC] //0x1233DAC为跳转表地址\n01233CAC    8BF4            mov esi,esp\n01233CAE    68 64582301     push 0x1235864                           ; case 1\\n\n01233CB3    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233CB9    83C4 04         add esp,0x4\n01233CBC    3BF4            cmp esi,esp\n01233CBE    E8 7DD4FFFF     call 01231140                            ; 01231140\n01233CC3    E9 94000000     jmp 01233D5C                             ; 01233D5C\n01233CC8    8BF4            mov esi,esp\n01233CCA    68 70582301     push 0x1235870                           ; case 2\\n\n01233CCF    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233CD5    83C4 04         add esp,0x4\n01233CD8    3BF4            cmp esi,esp\n01233CDA    E8 61D4FFFF     call 01231140                            ; 01231140\n01233CDF    EB 7B           jmp short 01233D5C                       ; 01233D5C\n01233CE1    8BF4            mov esi,esp\n01233CE3    68 D0582301     push 0x12358D0                           ; case 3\\n\n01233CE8    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233CEE    83C4 04         add esp,0x4\n01233CF1    3BF4            cmp esi,esp\n01233CF3    E8 48D4FFFF     call 01231140                            ; 01231140\n01233CF8    EB 62           jmp short 01233D5C                       ; 01233D5C\n01233CFA    8BF4            mov esi,esp\n01233CFC    68 5C582301     push 0x123585C                           ; case 4\\n\n01233D01    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233D07    83C4 04         add esp,0x4\n01233D0A    3BF4            cmp esi,esp\n01233D0C    E8 2FD4FFFF     call 01231140                            ; 01231140\n01233D11    EB 49           jmp short 01233D5C                       ; 01233D5C\n01233D13    8BF4            mov esi,esp\n01233D15    68 78582301     push 0x1235878                           ; case 5\\n\n01233D1A    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233D20    83C4 04         add esp,0x4\n01233D23    3BF4            cmp esi,esp\n01233D25    E8 16D4FFFF     call 01231140                            ; 01231140\n01233D2A    EB 30           jmp short 01233D5C                       ; 01233D5C\n01233D2C    8BF4            mov esi,esp\n01233D2E    68 D8582301     push 0x12358D8                           ; case 6\\n\n01233D33    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233D39    83C4 04         add esp,0x4\n01233D3C    3BF4            cmp esi,esp\n01233D3E    E8 FDD3FFFF     call 01231140                            ; 01231140\n01233D43    EB 17           jmp short 01233D5C                       ; 01233D5C\n01233D45    8BF4            mov esi,esp\n01233D47    68 40592301     push 0x1235940                           ; case 7\\n\n01233D4C    FF15 14912301   call dword ptr ds:[0x1239114]            ; msvcr120.printf\n01233D52    83C4 04         add esp,0x4\n01233D55    3BF4            cmp esi,esp\n01233D57    E8 E4D3FFFF     call 01231140                            ; 01231140\n01233D5C    33C0            xor eax,eax\n```\n\n跳转表：\n\n\n总结：\n获取switch变量的值\nmov xxx,reg\n对下标进行对齐\nmov reg,xx\nSub xx,xx\n执行影响标志位的指令，进行范围检查\nCmp xx,xx\n执行跳转指令\nJxx End\n查表，xxx为跳转表首地址\njmp dword ptr ds:[edx*4+xxx]\n\n## 难以构成跳转表的Switch结构\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nIndex = 0;\n    scanf_s(\"%d\", &nIndex);\n    switch (nIndex)\n    {\n    case 1:printf(\"case 1\\n\"); break;\n    case 2:printf(\"case 2\\n\"); break;\n    case 3:printf(\"case 3\\n\"); break;\n    case 5:printf(\"case 5\\n\"); break;\n    case 6:printf(\"case 6\\n\"); break;\n    case 255:printf(\"case 255\\n\"); break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00BB3C55    8945 FC         mov dword ptr ss:[ebp-0x4],eax\n00BB3C58    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0\n00BB3C5F    8BF4            mov esi,esp\n00BB3C61    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00BB3C64    50              push eax\n00BB3C65    68 5858BB00     push 0xBB5858                            ; %d\n00BB3C6A    FF15 1891BB00   call dword ptr ds:[0xBB9118]             ; msvcr120.scanf_s\n00BB3C70    83C4 08         add esp,0x8\n00BB3C73    3BF4            cmp esi,esp\n00BB3C75    E8 C6D4FFFF     call 00BB1140                            ; 00BB1140\n00BB3C7A    8B45 F4         mov eax,dword ptr ss:[ebp-0xC] \n00BB3C7D    8985 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],eax ebp-0xd4为nIndex\n00BB3C83    8B8D 2CFFFFFF   mov ecx,dword ptr ss:[ebp-0xD4] \n00BB3C89    83E9 01         sub ecx,0x1 //进行下标对齐\n00BB3C8C    898D 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],ecx          ; TestCode.<ModuleEntryPoint>\n00BB3C92    81BD 2CFFFFFF F>cmp dword ptr ss:[ebp-0xD4],0xFE //检查范围\n00BB3C9C    0F87 A8000000   ja 00BB3D4A                              ; 00BB3D4A\n00BB3CA2    8B95 2CFFFFFF   mov edx,dword ptr ss:[ebp-0xD4]  //以edx为下标进行寻址        ; case 1\\n\n00BB3CA8    0FB682 B43DBB00 movzx eax,byte ptr ds:[edx+0xBB3DB4] //查索引表\n00BB3CAF    FF2485 983DBB00 jmp dword ptr ds:[eax*4+0xBB3D98]  //根据索引查跳转表\n00BB3CB6    8BF4            mov esi,esp\n00BB3CB8    68 6458BB00     push 0xBB5864                            ; case 1\\n\n00BB3CBD    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3CC3    83C4 04         add esp,0x4\n00BB3CC6    3BF4            cmp esi,esp\n00BB3CC8    E8 73D4FFFF     call 00BB1140                            ; 00BB1140\n00BB3CCD    EB 7B           jmp short 00BB3D4A                       ; 00BB3D4A\n00BB3CCF    8BF4            mov esi,esp\n00BB3CD1    68 7058BB00     push 0xBB5870                            ; case 2\\n\n00BB3CD6    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3CDC    83C4 04         add esp,0x4\n00BB3CDF    3BF4            cmp esi,esp\n00BB3CE1    E8 5AD4FFFF     call 00BB1140                            ; 00BB1140\n00BB3CE6    EB 62           jmp short 00BB3D4A                       ; 00BB3D4A\n00BB3CE8    8BF4            mov esi,esp\n00BB3CEA    68 D058BB00     push 0xBB58D0                            ; case 3\\n\n00BB3CEF    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3CF5    83C4 04         add esp,0x4\n00BB3CF8    3BF4            cmp esi,esp\n00BB3CFA    E8 41D4FFFF     call 00BB1140                            ; 00BB1140\n00BB3CFF    EB 49           jmp short 00BB3D4A                       ; 00BB3D4A\n00BB3D01    8BF4            mov esi,esp\n00BB3D03    68 5C58BB00     push 0xBB585C                            ; case 5\\n\n00BB3D08    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3D0E    83C4 04         add esp,0x4\n00BB3D11    3BF4            cmp esi,esp\n00BB3D13    E8 28D4FFFF     call 00BB1140                            ; 00BB1140\n00BB3D18    EB 30           jmp short 00BB3D4A                       ; 00BB3D4A\n00BB3D1A    8BF4            mov esi,esp\n00BB3D1C    68 7858BB00     push 0xBB5878                            ; case 6\\n\n00BB3D21    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3D27    83C4 04         add esp,0x4\n00BB3D2A    3BF4            cmp esi,esp\n00BB3D2C    E8 0FD4FFFF     call 00BB1140                            ; 00BB1140\n00BB3D31    EB 17           jmp short 00BB3D4A                       ; 00BB3D4A\n00BB3D33    8BF4            mov esi,esp\n00BB3D35    68 EC59BB00     push 0xBB59EC                            ; case 255\\n\n00BB3D3A    FF15 1491BB00   call dword ptr ds:[0xBB9114]             ; msvcr120.printf\n00BB3D40    83C4 04         add esp,0x4\n00BB3D43    3BF4            cmp esi,esp\n00BB3D45    E8 F6D3FFFF     call 00BB1140                            ; 00BB1140\n00BB3D4A    33C0            xor eax,eax\n```\n\n索引表：\n\n索引表每一项大小一字节\n\n跳转表：\n\n\n总结：\nMov xxx,reg\nsub reg,1\ncmp dword ptr [ebp-0D4h],0FEh 影响标志位的指令，进行范围检查\njxx xxxx 超出范围跳到结尾处\nmov edx,dword ptr [ebp-0D4h]\nmovzx eax,byte ptr [edx+xxx]edx为下标，后面的是下标索引表首地址\njmp dword ptr [eax*4+xxx]\n在这种情况下，编译器会为switch建立两张表，一张是前面类似的地址表，一张则是索引表。\n\n## 降低判断树\n\nC代码：\n\n```c\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int nIndex = 0;\n    scanf_s(\"%d\", &nIndex);\n    switch (nIndex)\n    {\n    case 2:printf(\"case 2\\n\"); break;\n    case 3:printf(\"case 3\\n\"); break;\n    case 8:printf(\"case 8\\n\"); break;\n    case 10:printf(\"case 10\\n\"); break;\n    case 35:printf(\"case 35\\n\"); break;\n    case 37:printf(\"case 37\\n\"); break;\n    case 666:printf(\"case 666\\n\"); break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n\n对应反汇编Debug：\n\n```\n00DB3C58    C745 F4 0000000>mov dword ptr ss:[ebp-0xC],0x0\n00DB3C5F    8BF4            mov esi,esp\n00DB3C61    8D45 F4         lea eax,dword ptr ss:[ebp-0xC]\n00DB3C64    50              push eax\n00DB3C65    68 5858DB00     push 0xDB5858                            ; %d\n00DB3C6A    FF15 1891DB00   call dword ptr ds:[0xDB9118]             ; msvcr120.scanf_s\n00DB3C70    83C4 08         add esp,0x8\n00DB3C73    3BF4            cmp esi,esp\n00DB3C75    E8 C6D4FFFF     call 00DB1140                            ; 00DB1140\n00DB3C7A    8B45 F4         mov eax,dword ptr ss:[ebp-0xC]\n00DB3C7D    8985 2CFFFFFF   mov dword ptr ss:[ebp-0xD4],eax\n00DB3C83    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0xA\n00DB3C8A    7F 2D           jg short 00DB3CB9                        ; 00DB3CB9\n00DB3C8C    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0xA\n00DB3C93    0F84 9D000000   je 00DB3D36                              ; 00DB3D36\n00DB3C99    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x2\n00DB3CA0    74 46           je short 00DB3CE8                        ; 00DB3CE8\n00DB3CA2    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x3          ; case 1\\n\n00DB3CA9    74 59           je short 00DB3D04                        ; 00DB3D04\n00DB3CAB    83BD 2CFFFFFF 0>cmp dword ptr ss:[ebp-0xD4],0x8\n00DB3CB2    74 69           je short 00DB3D1D                        ; 00DB3D1D\n00DB3CB4    E9 DF000000     jmp 00DB3D98                             ; 00DB3D98\n00DB3CB9    83BD 2CFFFFFF 2>cmp dword ptr ss:[ebp-0xD4],0x23\n00DB3CC0    0F84 89000000   je 00DB3D4F                              ; 00DB3D4F\n00DB3CC6    83BD 2CFFFFFF 2>cmp dword ptr ss:[ebp-0xD4],0x25\n00DB3CCD    0F84 95000000   je 00DB3D68                              ; 00DB3D68\n00DB3CD3    81BD 2CFFFFFF 9>cmp dword ptr ss:[ebp-0xD4],0x29A\n00DB3CDD    0F84 9E000000   je 00DB3D81                              ; 00DB3D81\n00DB3CE3    E9 B0000000     jmp 00DB3D98                             ; case 3\\n\n00DB3CE8    8BF4            mov esi,esp\n00DB3CEA    68 6458DB00     push 0xDB5864                            ; case 2\\n\n00DB3CEF    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3CF5    83C4 04         add esp,0x4\n00DB3CF8    3BF4            cmp esi,esp\n00DB3CFA    E8 41D4FFFF     call 00DB1140                            ; 00DB1140\n00DB3CFF    E9 94000000     jmp 00DB3D98                             ; 00DB3D98\n00DB3D04    8BF4            mov esi,esp\n00DB3D06    68 7058DB00     push 0xDB5870                            ; case 3\\n\n00DB3D0B    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D11    83C4 04         add esp,0x4\n00DB3D14    3BF4            cmp esi,esp\n00DB3D16    E8 25D4FFFF     call 00DB1140                            ; 00DB1140\n00DB3D1B    EB 7B           jmp short 00DB3D98                       ; 00DB3D98\n00DB3D1D    8BF4            mov esi,esp\n00DB3D1F    68 D058DB00     push 0xDB58D0                            ; case 8\\n\n00DB3D24    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D2A    83C4 04         add esp,0x4\n00DB3D2D    3BF4            cmp esi,esp\n00DB3D2F    E8 0CD4FFFF     call 00DB1140                            ; 00DB1140\n00DB3D34    EB 62           jmp short 00DB3D98                       ; 00DB3D98\n00DB3D36    8BF4            mov esi,esp\n00DB3D38    68 4059DB00     push 0xDB5940                            ; case 10\\n\n00DB3D3D    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D43    83C4 04         add esp,0x4\n00DB3D46    3BF4            cmp esi,esp\n00DB3D48    E8 F3D3FFFF     call 00DB1140                            ; 00DB1140\n00DB3D4D    EB 49           jmp short 00DB3D98                       ; 00DB3D98\n00DB3D4F    8BF4            mov esi,esp\n00DB3D51    68 F859DB00     push 0xDB59F8                            ; case 35\\n\n00DB3D56    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D5C    83C4 04         add esp,0x4\n00DB3D5F    3BF4            cmp esi,esp\n00DB3D61    E8 DAD3FFFF     call 00DB1140                            ; 00DB1140\n00DB3D66    EB 30           jmp short 00DB3D98                       ; 00DB3D98\n00DB3D68    8BF4            mov esi,esp\n00DB3D6A    68 EC59DB00     push 0xDB59EC                            ; case 37\\n\n00DB3D6F    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D75    83C4 04         add esp,0x4\n00DB3D78    3BF4            cmp esi,esp\n00DB3D7A    E8 C1D3FFFF     call 00DB1140                            ; 00DB1140\n00DB3D7F    EB 17           jmp short 00DB3D98                       ; 00DB3D98\n00DB3D81    8BF4            mov esi,esp\n00DB3D83    68 045ADB00     push 0xDB5A04                            ; case 666\\n\n00DB3D88    FF15 1491DB00   call dword ptr ds:[0xDB9114]             ; msvcr120.printf\n00DB3D8E    83C4 04         add esp,0x4\n00DB3D91    3BF4            cmp esi,esp\n00DB3D93    E8 A8D3FFFF     call 00DB1140                            ; 00DB1140\n00DB3D98    33C0            xor eax,eax\n```\n\n在这里，由于case值相差过大，因此采取类似于二叉树的结构来进行查找。首先判断是否大于35，之后分成两部分进行判断，小于35的由于比较接近因此采用线性查找法，而大于35的部分则采用if…else…模拟法即使用第一种优化方式进行优化。\nRelease版结构图：","tags":["reverse"],"categories":["reverse"]},{"title":"某P保护学习","url":"/2016/08/21/某P保护学习/","content":"\n这个是在15年研究xx保护时记录的笔记，年代久远了。\n\n## 双机调试\nX64首先Hook IoAllocateMdl，代码如下\n```\nPMDL MyIoAllocateMdl(\n    __in_opt PVOID  VirtualAddress,\n    __in ULONG  Length,\n    __in BOOLEAN  SecondaryBuffer,\n    __in BOOLEAN  ChargeQuota,\n    __inout_opt PIRP  Irp  OPTIONAL)\n{\n    ULONG* KdEnteredDebugger = (ULONG*)GetKdEnteredDebuggerAddress();\n    if (VirtualAddress == KdEnteredDebugger)\n    {\n        DbgPrint(\"[KdEnteredDebugger] address: %p\\n\", KdEnteredDebugger);\n        VirtualAddress = (PUCHAR)KdEnteredDebugger + 0x30;  //据观察，+0x30 的位置恒为0     \n    }\n\n\n    //KdDebuggerNotPresent也是一个判断是否是内核调试状态的标志\n    if (VirtualAddress == &KdDebuggerNotPresent)\n    {\n        DbgPrint(\"[KdDebuggerNotPresent] address: %llx\\n\", &KdDebuggerNotPresent);\n    }\n\n    return old_IoAllocateMdl(VirtualAddress, Length, SecondaryBuffer, ChargeQuota, Irp);\n\n}\n```\nStartSearchAddress就是搜索的开始位置，通过刚才的反汇编我们肯定特征码在0x500范围内，所以EndSearchAddress = StartSearchAddress + 0x500;\n下面就是一个循环一个字节一个字节的找，找到后memcpy_s(&temp, 4, i + 3, 4);、\n复制指令的后四个字节到temp；然后计算出KeServiceDescriptorTable的真实位置。\naddr = (ULONGLONG)temp + (ULONGLONG)i + 7;\n\n## 调试权限清零\n我们先来看看ValidAccessMask的值。\n通过NtCreateDebugObject来定位。\n\nuf  NtCreateDebugObject\n<!-- ![](某P调试权限清零/1.png) -->\n{% asset_img 1.png %}\n\n地址为fffff800`04011f40\n\n<!-- ![](某P调试权限清零/2.png) -->\n{% asset_img 2.png %}\n\n第一个四字节就是_object_type的地址\n<!-- ![](某P调试权限清零/3.png) -->\n{% asset_img 3.png %}\n\n我们想得到的ValidAccessMask存在TypeInfo中，偏移为0x40\n<!-- ![](某P调试权限清零/4.png) -->\n{% asset_img 4.png %}\n由上图可以看出ValidAccessMask的默认值为0x1f000f，此值为0时OD将无法附加，测试一下看看，我们将ValidAccessMask修改为0\n<!-- ![](某P调试权限清零/5.png) -->\n{% asset_img 5.png %}\n\n<!-- ![](某P调试权限清零/6.png) -->\n{% asset_img 6.png %}\n\n进程已无法附加，可见ValidAccessMask的值的确对我们附加进程造成影响，参考资料得TP是循环的将ValidAccessMask清0，即得出解决方法，我们也开个定时器恢复ValidAccessMask的值。\n写代码时候发现了许多问题。NtCreateDebugObject这个函数在SSDT中，而X64已经没有导出KeServiceDescriptorTable，这里参考了TA大的Win64驱动开发教程，代码拿来即可用，抱着学习的心态来，学习方法和原理，动手。\n反汇编KiSystemCall64,这里是内核函数入口。\n\nuf KiSystemCall64，代码很多，贴出关键部分\n<!-- ![](某P调试权限清零/7.png) -->\n{% asset_img 7.png %}\n\n特征码是：4c8d15c\n内核代码开始的地址保存在C0000082寄存器中，读取这个寄存器也很方便，可用__readmsr()函数读取（MSR中文是特别寄存器块），\nWinDbg测试看看。\n<!-- ![](某P调试权限清零/8.png) -->\n{% asset_img 8.png %}\n地址相同。\n\n```c\n************************************************************************\n函数名称：GetKeServiceDescriptorTable64\n函数功能：得到GetKeServiceDescriptorTable64地址\n************************************************************************/\nULONGLONG GetKeServiceDescriptorTable64()\n{\n    PUCHAR StatrtSearchAddr = (PUCHAR)__readmsr(0xc0000082);\n    PUCHAR EndSearchAddr = StatrtSearchAddr + 0x500;\n    PUCHAR i = NULL;\n    UCHAR b1 = 0, b2 = 0, b3 = 0;\n    ULONG templong = 0;\n    ULONGLONG addr = 0;\n    for (i = StatrtSearchAddr; i < EndSearchAddr; i++)\n    {\n        if (MmIsAddressValid(i) && MmIsAddressValid(i + 1) && MmIsAddressValid(i + 2))\n        {\n            b1 = *i;\n            b2 = *(i + 1);\n            b3 = *(i + 2);\n            //fffff800`01ad0772 4c8d15c7202300 lea r10,[nt!KeServiceDescriptorTable (fffff800`01d02840)]\n            if (b1 == 0x4c && b2 == 0x8d && b3 == 0x15)\n            {\n                memcpy(&templong,i + 3,4);\n                addr = (ULONGLONG)templong + (ULONGLONG)i + 7;\n                return addr;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n具体实现参考代码。\n接下来就是获取SSDT函数的地址了，获取地址需要得到函数的Index，方法也简单，也可通过工具获得，还是为了学知识，简单了解一下了。\n<!-- ![](某P调试权限清零/9.png) -->\n{% asset_img 9.png %}\nWin7:\n看框内代码几乎相同，唯一不同的就是第二行代码。（注：这里出了一些问题，在Win10上测试与Win7不同，后续继续研究。）\nxxH即为Index，90h转为十进制为144。\n<!-- ![](某P调试权限清零/10.png) -->\n{% asset_img 10.png %}\n\n```c\n/************************************************************************\n函数名称：GetSSDTFunctionAddress\n函数功能：获得SSDT表地址\n参 数 ：ID号\n注意：计算方法 ServiceTableBase[index] >> 4 + ServiceTableBase\n************************************************************************/\nULONGLONG GetSSDTFunctionAddress(ULONG id)\n{\n    LONG dwtmp = 0;\n    PULONG ServiceTableBase = NULL;\n    PSYSTEM_SERVICE_TABLE ssdt = (PSYSTEM_SERVICE_TABLE)GetKeServiceDescriptorTable64();\n    ServiceTableBase = (PULONG)ssdt->ServiceTableBase;\n    dwtmp = ServiceTableBase[id];\n    dwtmp = dwtmp >> 4;\n    return dwtmp + (ULONGLONG)ServiceTableBase;\n}\n```\n\n至此NtCreateDebugObject地址也得到。\n接下来我们要取得ValidAccessMask的地址，还是用特征码定位的方式\n\n```c\nVOID PassValidAccessMask()\n{\n    PUCHAR StartSearchAddress = (PUCHAR)GetSSDTFunctionAddress(144);\n \n    pNtCreateDebugObject = (PVOID)GetSSDTFunctionAddress(144);\n    DbgPrint(\"pNtCreateDebugObject:%p\\n\",pNtCreateDebugObject);\n \n    pTargetAddr = (PVOID)(((ULONG64)pNtCreateDebugObject) + 0x7c);\n    DbgPrint(\"pTargetAddr:%p\\n\", pTargetAddr);\n \n    PUCHAR EndSearchAddress = StartSearchAddress + 0x100;\n    PUCHAR i = 0;\n    UCHAR b1 = 0, b2 = 0, b3 = 0;\n    LONG temp = 0;\n    LONGLONG addr = 0;\n    for (i = StartSearchAddress; i < EndSearchAddress; i++)\n    {\n        if (MmIsAddressValid(i) && MmIsAddressValid(i + 1) && MmIsAddressValid(i + 2))\n        {\n            b1 = *i;\n            b2 = *(i + 1);\n            b3 = *(i + 2);\n            if (b1 == 0x48 && b2 == 0x8b && b3 == 0x15)\n            {\n                memcpy_s(&temp, 4, i + 3, 4);\n                addr = (LONGLONG)temp + (LONGLONG)i + 7;\n                DbgPrint(\"ValidAccessMask:%llx\\n\", *(ULONG *)((*(ULONGLONG *)addr) + 0x40 + 0x1C));\n                *(ULONG *)((*(ULONGLONG *)addr) + 0x40 + 0x1C) = 0x1f000f;\n            }\n        }\n    }\n}\n```\n\n至此全部完成，开个定时器修改ValidAccessMask的值就行了。\n<!-- ![](某P调试权限清零/11.png) -->\n{% asset_img 11.png %}\n<!-- ![](某P调试权限清零/12.png) -->\n{% asset_img 12.png %}\n学习的还有很多，感谢TA大牛提供的Win64驱动编程基础教程与前辈们分享的文章。\n\n","tags":["reverse"],"categories":["reverse"]},{"title":"某CrackMe分析","url":"/2016/06/16/某CrackMe分析/","content":"\n调试分析后定位算法 \n\n```c\nint __fastcall sub_1634(const char *a1, int a2) \n{\n\tint v2; // r6@1\n\tsigned int v3; // r5@1\n\tint result; // r0@2\n\tsigned int v5; // r4@3\n\tchar *v6; // r7@4\n\tint v7; // r3@4\n\tint v8; // r4@6\n\tint v9; // r4@7\n\tint v10; // r1@8\n\tconst char *v11; // [sp+Ch] [bp-464h]@1 int v12[5]; // [sp+18h] [bp-458h]@7\n\tint v13; // [sp+1Ch] [bp-454h]@10\n\tint v14; // [sp+20h] [bp-450h]@11\n\tint v15; // [sp+24h] [bp-44Ch]@12\n\tint v16; // [sp+28h] [bp-448h]@13\n\tchar v17[20]; // [sp+2Ch] [bp-444h]@7 int v18; // [sp+30h] [bp-440h]@13\n\tint v19; // [sp+34h] [bp-43Ch]@9\n\tint v20; // [sp+38h] [bp-438h]@11\n\tint v21; // [sp+3Ch] [bp-434h]@9\n\tchar s[20]; // [sp+40h] [bp-430h]@3 char v23[936]; // [sp+54h] [bp-41Ch]@5 int v24; // [sp+454h] [bp-1Ch]@1\n\n\tv2 = a2;\n\tv11 = a1;\n\tv24 = _stack_chk_guard;\n\tv3 = j_j_strlen(a1);\n\tif ( (unsigned int)(v3 - 6) > 0xE )\n\t goto LABEL_18;\n\tj_j_memset(s, 0, 0x14u);\n\tv5 = 0;\n\tdo\n\t{\n\t\tv6 = &s[v5];\n\t\tv7 = v11[v5 % v3] * (v5 + 20160126) * v3; ++v5;\n\t\t*(_DWORD *)v6 += v7;\n\t}\n\twhile ( v5 != 16 );\n \tj_j_memset(v23, 0, 0x400u);\n \tif ( sub_146C(v2) > 1024 || (v8 = sub_1498(v23, v2), v8 != 20) )\n \t{\n\tLABEL_18:\n\t result = 0;\n\t}\n\telse\n\t{\n\t j_j_memset(v12, 0, 0x14u);\n\t j_j_memset(v17, 0, 0x14u);\n\t v9 = 0;\n\t do\n\t {\n\t v10 = *(_DWORD *)&v23[v9 * 4];\n\t v12[v9] = *(_DWORD *)&s[v9 * 4] / 10;\n\t *(_DWORD *)&v17[v9 * 4] = v10;\n\t ++v9;\n\t }\n\t while ( v9 != 5 );\n\t result = 0;\n\t if ( v21 + v12[0] == v19\n\t && v21 + v12[0] + v13 == 2 * v21\n\t && v14 + v20 == *(_DWORD *)v17\n\t && v14 + v20 + v15 == 2 * v20 )\n\t {\n\t result = (unsigned int)(v16 + v18 - 3 * v14) <= 0;\n\t }\n\t }\n\tif ( v24 != _stack_chk_guard )\n\tj_j___stack_chk_fail(result); \n\treturn result;\n}\n```\n\n整个流程是首先检测用户名长度，根据输入的用户名生成表 1，将输入的密码进行 base64，存入表 2，然后根 据表 1 产生表 3，分五次对表 2，表 3 的内容进行计算，五次比较。\n\n还原出的解密算法\n\n```c\nvoid GetKey(const char *name) \n{\n\tchar *vPass;\n\tsigned int vNameLen; int result;\n\tint i;\n\tint *v6;\n\tint v7;\n\tint baseDecLen;\n\tint idx;\n\tint v10;\n\tconst char *vName; int eName[5];\n\tint ePass[5];\n\tint nameTable[5]; char passDec[936]; int v16;\n\n\tvName = name;\n\tvNameLen = strlen(name);\n\n\tif ((unsigned int)(vNameLen - 6) > 0xE) \n\t{\n\t\tcout << \"长度错误\" << endl;\n\t}\n\n\tmemset(nameTable, 0, 0x14); i = 0;\n\n\tdo\n\t{\n\t\tv6 = (int*)((char*)nameTable + i);\n\t\tv7 = vName[i % vNameLen] * (i + 20160126) *vNameLen;\n\t\t++i;\n\t\t*v6 += v7; \n\t} while (i != 0x10);\n\tmemset(eName, 0, 0x14); idx = 0;\n\n\tdo\n\t{\n\t\teName[idx] = nameTable[idx] / 10;\n\t\t++idx;\n\t} while (idx != 5);\n\tePass[3] = eName[2] + eName[3];\n\tePass[4] = eName[0] + eName[1];\n\tePass[2] = ePass[4] + eName[0];\n\tePass[0] = eName[2] + ePass[3];\n\tePass[1] = 3 * eName[2] - eName[4];\n\tprintf(\"%x\", ePass);\n\tchar *enc = base64_encode((char*)ePass, 20);\n\tstd::string str = base64encode((unsigned char*)ePass, 20); printf(\"%s\\n\", enc);\n\tprintf(\"%s\\n\", str.c_str());\n}\n\nint _tmain(int argc, _TCHAR* argv[]) \n{\n\tchar name[20] = {0}; scanf(\"%s\", name);\n\tGetKey(name);\n\tsystem(\"pause\"); \n\treturn 0;\n}\n```","tags":["reverse"],"categories":["reverse"]},{"title":"Hello World","url":"/2016/06/15/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]